/* * Copyright (C) 2012 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include <android-base/logging.h> #include <android-base/stringprintf.h> #include <cutils/properties.h> #include <errno.h> #include <nativehelper/JNIPlatformHelp.h> #include <nativehelper/ScopedLocalRef.h> #include <nativehelper/ScopedPrimitiveArray.h> #include <nativehelper/ScopedUtfChars.h> #include <semaphore.h> #include "HciEventManager.h" #include "JavaClassConstants.h" #include "NativeWlcManager.h" #include "NfcAdaptation.h" #ifdef DTA_ENABLED #include "NfcDta.h" #endif /* DTA_ENABLED */ #include "NativeT4tNfcee.h" #include "NfcJniUtil.h" #include "NfcTag.h" #include "NfceeManager.h" #include "RoutingManager.h" #include "SyncEvent.h" #include "android_nfc.h" #include "ce_api.h" #include "com_android_nfc_module_flags.h" #include "debug_lmrt.h" #include "nfa_api.h" #include "nfa_ee_api.h" #include "nfa_nfcee_int.h" #include "nfc_brcm_defs.h" #include "nfc_config.h" #include "rw_api.h" using android::base::StringPrintf; using com::android::nfc::module::flags::reader_mode_ignore_frame; extern tNFA_DM_DISC_FREQ_CFG* p_nfa_dm_rf_disc_freq_cfg;  // defined in stack namespace android { extern bool gIsTagDeactivating; extern bool gIsSelectingRfInterface; extern bool gTagJustActivated; extern void nativeNfcTag_doTransceiveStatus(tNFA_STATUS status, uint8_t* buf,                                            uint32_t buflen); extern void nativeNfcTag_notifyRfTimeout(); extern void nativeNfcTag_doConnectStatus(jboolean is_connect_ok); extern void nativeNfcTag_doDeactivateStatus(int status); extern void nativeNfcTag_doWriteStatus(jboolean is_write_ok); extern jboolean nativeNfcTag_doDisconnect(JNIEnv*, jobject); extern void nativeNfcTag_doCheckNdefResult(tNFA_STATUS status,                                           uint32_t max_size,                                           uint32_t current_size,                                           uint8_t flags); extern void nativeNfcTag_doMakeReadonlyResult(tNFA_STATUS status); extern void nativeNfcTag_doPresenceCheckResult(tNFA_STATUS status); extern void nativeNfcTag_formatStatus(bool is_ok); extern void nativeNfcTag_resetPresenceCheck(); extern void nativeNfcTag_doReadCompleted(tNFA_STATUS status); extern void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface); extern void nativeNfcTag_setActivatedRfProtocol(tNFA_INTF_TYPE rfProtocol); extern void nativeNfcTag_setActivatedRfMode(uint8_t rfMode); extern void nativeNfcTag_abortWaits(); extern void nativeNfcTag_registerNdefTypeHandler(); extern void nativeNfcTag_acquireRfInterfaceMutexLock(); extern void nativeNfcTag_releaseRfInterfaceMutexLock(); extern void updateNfcID0Param(uint8_t* nfcID0); }  // namespace android /***************************************************************************** ** ** public variables and functions ** *****************************************************************************/ bool gActivated = false; SyncEvent gDeactivatedEvent; SyncEvent sNfaSetPowerSubState; int recovery_option = 0; int always_on_nfcee_power_and_link_conf = 0; int disable_always_on_nfcee_power_and_link_conf = 0; namespace android { jmethodID gCachedNfcManagerNotifyNdefMessageListeners; jmethodID gCachedNfcManagerNotifyTransactionListeners; jmethodID gCachedNfcManagerNotifyHostEmuActivated; jmethodID gCachedNfcManagerNotifyHostEmuData; jmethodID gCachedNfcManagerNotifyHostEmuDeactivated; jmethodID gCachedNfcManagerNotifyRfFieldActivated; jmethodID gCachedNfcManagerNotifyRfFieldDeactivated; jmethodID gCachedNfcManagerNotifyEeUpdated; jmethodID gCachedNfcManagerNotifyTagDiscovered; jmethodID gCachedNfcManagerNotifyHwErrorReported; jmethodID gCachedNfcManagerNotifyPollingLoopFrame; jmethodID gCachedNfcManagerNotifyWlcStopped; jmethodID gCachedNfcManagerNotifyVendorSpecificEvent; jmethodID gCachedNfcManagerNotifyCommandTimeout; jmethodID gCachedNfcManagerNotifyObserveModeChanged; jmethodID gCachedNfcManagerNotifyRfDiscoveryEvent; jmethodID gCachedNfcManagerNotifyEeAidSelected; jmethodID gCachedNfcManagerNotifyEeProtocolSelected; jmethodID gCachedNfcManagerNotifyEeTechSelected; jmethodID gCachedNfcManagerNotifyEeListenActivated; jmethodID gCachedNfcManagerOnRestartRfDiscovery; jmethodID gCachedNfcManagerOnObserveModeDisabledInFirmware; jmethodID gCachedNfcManagerOnObserveModeEnabledInFirmware; jmethodID gCachedNfcManagerNotifyEndpointRemoved; const char* gNativeNfcTagClassName = "com/android/nfc/dhimpl/NativeNfcTag"; const char* gNativeNfcManagerClassName =    "com/android/nfc/dhimpl/NativeNfcManager"; const char* gNfcVendorNciResponseClassName =    "com/android/nfc/NfcVendorNciResponse"; const char* gNativeT4tNfceeClassName =    "com/android/nfc/dhimpl/NativeT4tNfceeManager"; void doStartupConfig(); void startStopPolling(bool isStartPolling); void startRfDiscovery(bool isStart); bool isDiscoveryStarted(); }  // namespace android /***************************************************************************** ** ** private variables and functions ** *****************************************************************************/ namespace android { static SyncEvent sNfaEnableEvent;                // event for NFA_Enable() static SyncEvent sNfaDisableEvent;               // event for NFA_Disable() static SyncEvent sNfaEnableDisablePollingEvent;  // event for                                                 // NFA_EnablePolling(),                                                 // NFA_DisablePolling() SyncEvent gNfaSetConfigEvent;                    // event for Set_Config.... SyncEvent gNfaGetConfigEvent;                    // event for Get_Config.... SyncEvent gNfaVsCommand;                         // event for VS commands SyncEvent gSendRawVsCmdEvent;  // event for NFA_SendRawVsCommand() SyncEvent gNfaRemoveEpEvent;   // event for StartRemoval.... static bool sIsEpDetectStarted = false; static bool sIsNfaEnabled = false; static bool sDiscoveryEnabled = false;  // is polling or listening static bool sPollingEnabled = false;    // is polling for tag? bool sIsDisabling = false; static bool sRfEnabled = false;   // whether RF discovery is enabled static bool sSeRfActive = false;  // whether RF with SE is likely active static bool sReaderModeEnabled = false;  // whether we're only reading tags, not allowing card emu static bool sAbortConnlessWait = false; static jint sLfT3tMax = 0; static bool sRoutingInitialized = false; static bool sIsRecovering = false; static bool sIsAlwaysPolling = false; static std::vector<uint8_t> sRawVendorCmdResponse; static bool sEnableVendorNciNotifications = false; static bool sIsShuttingDown = false; #define CONFIG_UPDATE_TECH_MASK (1 << 1) #define DEFAULT_TECH_MASK                                                  \  (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B | NFA_TECHNOLOGY_MASK_F | \   NFA_TECHNOLOGY_MASK_V | NFA_TECHNOLOGY_MASK_B_PRIME |                   \   NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE |           \   NFA_TECHNOLOGY_MASK_KOVIO) #define DEFAULT_DISCOVERY_DURATION 500 #define READER_MODE_DISCOVERY_DURATION 200 #define FLAG_SET_DEFAULT_TECH 0x40000000 static void nfaConnectionCallback(uint8_t event, tNFA_CONN_EVT_DATA* eventData); static void nfaDeviceManagementCallback(uint8_t event,                                        tNFA_DM_CBACK_DATA* eventData); static bool isListenMode(tNFA_ACTIVATED& activated); static tNFA_STATUS stopPolling_rfDiscoveryDisabled(); static tNFA_STATUS startPolling_rfDiscoveryDisabled(    tNFA_TECHNOLOGY_MASK tech_mask); static void nfcManager_doSetScreenState(JNIEnv* e, jobject o,                                        jint screen_state_mask,                                        jboolean alwaysPoll); static jboolean nfcManager_doSetPowerSavingMode(JNIEnv* e, jobject o,                                                bool flag); static void sendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                 uint8_t* p_param); static jbyteArray nfcManager_getProprietaryCaps(JNIEnv* e, jobject o); static jboolean nfcManager_setFirmwareExitFrameTable(JNIEnv* env, jobject o,                                                     jobjectArray exit_frames,                                                     jbyteArray timeout_ms); static void nfcManager_restartRfDiscovery(JNIEnv* e, jobject o); tNFA_STATUS gVSCmdStatus = NFA_STATUS_OK; uint16_t gCurrentConfigLen; uint8_t gConfig[256]; std::vector<uint8_t> gCaps(0); static int prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED; static int NFA_SCREEN_POLLING_TAG_MASK = 0x10; bool gIsDtaEnabled = false; static bool gObserveModeEnabled = false; static int gPartialInitMode = ENABLE_MODE_DEFAULT; ///////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////// namespace { void initializeGlobalDebugEnabledFlag() {  bool nfc_debug_enabled =      (NfcConfig::getUnsigned(NAME_NFC_DEBUG_ENABLED, 1) != 0) ||      property_get_bool("persist.nfc.debug_enabled", true);   android::base::SetMinimumLogSeverity(nfc_debug_enabled ? android::base::DEBUG                                                         : android::base::INFO); } void initializeRecoveryOption() {  recovery_option = NfcConfig::getUnsigned(NAME_RECOVERY_OPTION, 0);   LOG(DEBUG) << __func__ << ": recovery option=" << recovery_option; } void initializeNfceePowerAndLinkConf() {  always_on_nfcee_power_and_link_conf =      NfcConfig::getUnsigned(NAME_ALWAYS_ON_SET_EE_POWER_AND_LINK_CONF, 0);   LOG(DEBUG) << __func__ << ": Always on set NFCEE_POWER_AND_LINK_CONF="             << always_on_nfcee_power_and_link_conf; } void initializeDisableAlwaysOnNfceePowerAndLinkConf() {  disable_always_on_nfcee_power_and_link_conf = NfcConfig::getUnsigned(      NAME_DISABLE_ALWAYS_ON_SET_EE_POWER_AND_LINK_CONF, 0);   LOG(DEBUG) << __func__ << ": Always on set NFCEE_POWER_AND_LINK_CONF="             << disable_always_on_nfcee_power_and_link_conf; } }  // namespace /******************************************************************************* ** ** Function:        getNative ** ** Description:     Get native data ** ** Returns:         Native data structure. ** *******************************************************************************/ nfc_jni_native_data* getNative(JNIEnv* e, jobject o) {  static struct nfc_jni_native_data* sCachedNat = NULL;  if (e) {    sCachedNat = nfc_jni_get_nat(e, o);  }  return sCachedNat; } /******************************************************************************* ** ** Function:        handleRfDiscoveryEvent ** ** Description:     Handle RF-discovery events from the stack. **                  discoveredDevice: Discovered device. ** ** Returns:         None ** *******************************************************************************/ static void handleRfDiscoveryEvent(tNFC_RESULT_DEVT* discoveredDevice) {  NfcTag& natTag = NfcTag::getInstance();   LOG(DEBUG) << StringPrintf("%s: ", __func__);   if (gIsSelectingRfInterface && !natTag.getMultiProtocolTagSupport()) {    if (discoveredDevice->more == NCI_DISCOVER_NTF_MORE) return;    LOG(WARNING) << StringPrintf(        "%s: reselecting, mismatch in nb of detected interfaces, "        "restarting discovery",        __func__);    nativeNfcTag_doConnectStatus(false);    natTag.setReselect(false);    NFA_Deactivate(FALSE);  }  if (discoveredDevice->protocol != NFA_PROTOCOL_NFC_DEP) {    natTag.setNumDiscNtf(natTag.getNumDiscNtf() + 1);  }  if (discoveredDevice->more == NCI_DISCOVER_NTF_MORE) {    // there is more discovery notification coming    return;  }   if (natTag.getNumDiscNtf() > 1) {    natTag.setMultiProtocolTagSupport(true);  }   natTag.setNumDiscNtf(natTag.getNumDiscNtf() - 1);  // select the first of multiple tags that is discovered  natTag.selectFirstTag(); } /******************************************************************************* ** ** Function:        nfaConnectionCallback ** ** Description:     Receive connection-related events from stack. **                  connEvent: Event code. **                  eventData: Event data. ** ** Returns:         None ** *******************************************************************************/ static void nfaConnectionCallback(uint8_t connEvent,                                  tNFA_CONN_EVT_DATA* eventData) {  tNFA_STATUS status = NFA_STATUS_FAILED;   switch (connEvent) {    case NFA_LISTEN_ENABLED_EVT:  // whether listening successfully started    {      LOG(DEBUG) << StringPrintf("%s: NFA_LISTEN_ENABLED_EVT:status= %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_POLL_ENABLED_EVT:  // whether polling successfully started    {      LOG(DEBUG) << StringPrintf("%s: NFA_POLL_ENABLED_EVT: status = %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_POLL_DISABLED_EVT:  // Listening/Polling stopped    {      LOG(DEBUG) << StringPrintf("%s: NFA_POLL_DISABLED_EVT: status = %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_RF_DISCOVERY_STARTED_EVT:  // RF Discovery started    {      LOG(DEBUG) << StringPrintf(          "%s: NFA_RF_DISCOVERY_STARTED_EVT: status = %u", __func__,          eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();      struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (!nat) {        LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);        return;      }      JNIEnv* e = NULL;      ScopedAttach attach(nat->vm, &e);      if (e == NULL) {        LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);        return;      }      e->CallVoidMethod(nat->manager,                        android::gCachedNfcManagerNotifyRfDiscoveryEvent,                        JNI_TRUE);    } break;     case NFA_RF_DISCOVERY_STOPPED_EVT:  // RF Discovery stopped event    {      LOG(DEBUG) << StringPrintf(          "%s: NFA_RF_DISCOVERY_STOPPED_EVT: status = %u", __func__,          eventData->status);       gActivated = false;       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();      struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (!nat) {        LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);        return;      }      JNIEnv* e = NULL;      ScopedAttach attach(nat->vm, &e);      if (e == NULL) {        LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);        return;      }      e->CallVoidMethod(nat->manager,                        android::gCachedNfcManagerNotifyRfDiscoveryEvent,                        JNI_FALSE);    } break;     case NFA_DISC_RESULT_EVT:  // NFC link/protocol discovery notificaiton      status = eventData->disc_result.status;      LOG(DEBUG) << StringPrintf("%s: NFA_DISC_RESULT_EVT: status = %d",                                 __func__, status);      if (status != NFA_STATUS_OK) {        NfcTag::getInstance().setNumDiscNtf(0);        LOG(ERROR) << StringPrintf("%s: NFA_DISC_RESULT_EVT error: status = %d",                                   __func__, status);      } else {        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        handleRfDiscoveryEvent(&eventData->disc_result.discovery_ntf);      }      break;     case NFA_SELECT_RESULT_EVT:  // NFC link/protocol discovery select response      LOG(DEBUG) << StringPrintf(          "%s: NFA_SELECT_RESULT_EVT: status = %d, gIsSelectingRfInterface = "          "%d, "          "sIsDisabling=%d",          __func__, eventData->status, gIsSelectingRfInterface, sIsDisabling);       if (sIsDisabling) break;       if (eventData->status != NFA_STATUS_OK) {        if (gIsSelectingRfInterface) {          nativeNfcTag_doConnectStatus(false);        }         LOG(ERROR) << StringPrintf(            "%s: NFA_SELECT_RESULT_EVT error: status = %d", __func__,            eventData->status);        if (NfcTag::getInstance().retrySelect() == NFA_STATUS_OK) {          break;        }        NFA_Deactivate(FALSE);      }      break;     case NFA_DEACTIVATE_FAIL_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_DEACTIVATE_FAIL_EVT: status = %d",                                 __func__, eventData->status);      break;     case NFA_ACTIVATED_EVT:  // NFC link/protocol activated    {      bool notListen = !isListenMode(eventData->activated);      LOG(DEBUG) << StringPrintf(          "%s: NFA_ACTIVATED_EVT: gIsSelectingRfInterface=%d, sIsDisabling=%d",          __func__, gIsSelectingRfInterface, sIsDisabling);      uint8_t activatedProtocol =          (tNFA_INTF_TYPE)eventData->activated.activate_ntf.protocol;      uint8_t activatedMode =          eventData->activated.activate_ntf.rf_tech_param.mode;      gTagJustActivated = true;      if (NFC_PROTOCOL_T5T == activatedProtocol &&          NfcTag::getInstance().getNumDiscNtf()) {        /* T5T doesn't support multiproto detection logic */        NfcTag::getInstance().setNumDiscNtf(0);      }      NfcTag::getInstance().clearSelectRetryCount();      if ((eventData->activated.activate_ntf.protocol !=           NFA_PROTOCOL_NFC_DEP) &&          (!isListenMode(eventData->activated))) {        nativeNfcTag_setRfInterface(            (tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param.type);        nativeNfcTag_setActivatedRfProtocol(activatedProtocol);        nativeNfcTag_setActivatedRfMode(activatedMode);      }      NfcTag::getInstance().setActive(notListen);      if (sIsDisabling || !sIsNfaEnabled) break;      gActivated = true;       if (notListen) {        updateNfcID0Param(            eventData->activated.activate_ntf.rf_tech_param.param.pb.nfcid0);        NfcTag::getInstance().setActivationState();        if (gIsSelectingRfInterface) {          nativeNfcTag_doConnectStatus(true);          break;        }         nativeNfcTag_resetPresenceCheck();        if (!isListenMode(eventData->activated) &&            (prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||             prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED)) {          if (!sIsAlwaysPolling) {            NFA_Deactivate(FALSE);          }        }         NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        if (NfcTag::getInstance().getNumDiscNtf()) {          /*If its multiprotocol tag, deactivate tag with current selected          protocol to sleep . Select tag with next supported protocol after          deactivation event is received*/          if (((tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param                   .type == NFA_INTERFACE_FRAME)) {            uint8_t RW_TAG_SLP_REQ[] = {0x50, 0x00};            SyncEvent waitSome;            SyncEventGuard g(waitSome);            NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);            waitSome.wait(4);          }          NFA_Deactivate(true);        }       } else {        // If it activated in        // listen mode then it is likely for an SE transaction.        // Send the RF Event.        sSeRfActive = true;        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << __func__ << ": jni env is null";          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyEeListenActivated,                          JNI_TRUE);      }    } break;    case NFA_DEACTIVATED_EVT:  // NFC link/protocol deactivated      LOG(DEBUG) << StringPrintf(          "%s: NFA_DEACTIVATED_EVT   Type=%u, gIsTagDeactivating=%d", __func__,          eventData->deactivated.type, gIsTagDeactivating);      NfcTag::getInstance().setDeactivationState(eventData->deactivated);       if (eventData->deactivated.type != NFA_DEACTIVATE_TYPE_SLEEP) {        {          SyncEventGuard g(gDeactivatedEvent);          gActivated = false;  // guard this variable from multi-threaded access          gDeactivatedEvent.notifyOne();        }        nativeNfcTag_resetPresenceCheck();        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        nativeNfcTag_abortWaits();        NfcTag::getInstance().abort();      } else if (gIsTagDeactivating) {        NfcTag::getInstance().setActive(false);        nativeNfcTag_doDeactivateStatus(0);      } else if (!sIsDisabling) {        NfcTag::getInstance().selectNextTagIfExists();      }       // If RF is activated for what we think is a Secure Element transaction      // and it is deactivated to either IDLE or DISCOVERY mode, notify w/event.      if ((eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE) ||          (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_DISCOVERY)) {        if (sSeRfActive) {          sSeRfActive = false;          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {            LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);            return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {            LOG(ERROR) << __func__ << ": jni env is null";            return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyEeListenActivated,                            JNI_FALSE);        }      }       break;     case NFA_DETECT_REMOVAL_STARTED_EVT: {  // whether EP Removal Detection                                            // successfully started      LOG(DEBUG) << StringPrintf(          "%s:  NFA_DETECT_REMOVAL_STARTED_EVT: status = %d", __func__, status);       sIsEpDetectStarted = eventData->status == NFA_STATUS_OK;      SyncEventGuard guard(gNfaRemoveEpEvent);      gNfaRemoveEpEvent.notifyOne();    } break;     case NFA_DETECT_REMOVAL_RESULT_EVT: {  // Removal Detection complete      LOG(DEBUG) << StringPrintf(          "%s:  NFA_DETECT_REMOVAL_RESULT_EVT: status = %d, reason = %d",          __func__, status, eventData->removal_detect.reason);       /* Return REMOVAL_DETECTION deactivation reason to service */      {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s:  jni env is null", __func__);          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyEndpointRemoved,                          (int)eventData->removal_detect.reason);        if (e->ExceptionCheck()) {          e->ExceptionClear();          LOG(ERROR) << StringPrintf("%s: fail notify", __func__);        }      }    } break;     case NFA_TLV_DETECT_EVT:  // TLV Detection complete      status = eventData->tlv_detect.status;      LOG(DEBUG) << StringPrintf(          "%s: NFA_TLV_DETECT_EVT: status = %d, protocol = %d, num_tlvs = %d, "          "num_bytes = %d",          __func__, status, eventData->tlv_detect.protocol,          eventData->tlv_detect.num_tlvs, eventData->tlv_detect.num_bytes);      if (status != NFA_STATUS_OK) {        LOG(ERROR) << StringPrintf("%s: NFA_TLV_DETECT_EVT error: status = %d",                                   __func__, status);      }      break;     case NFA_NDEF_DETECT_EVT:  // NDEF Detection complete;      // if status is failure, it means the tag does not contain any or valid      // NDEF data;  pass the failure status to the NFC Service;      status = eventData->ndef_detect.status;      LOG(DEBUG) << StringPrintf(          "%s: NFA_NDEF_DETECT_EVT: status = 0x%X, protocol = %u, "          "max_size = %u, cur_size = %u, flags = 0x%X",          __func__, status, eventData->ndef_detect.protocol,          eventData->ndef_detect.max_size, eventData->ndef_detect.cur_size,          eventData->ndef_detect.flags);      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);      nativeNfcTag_doCheckNdefResult(status, eventData->ndef_detect.max_size,                                     eventData->ndef_detect.cur_size,                                     eventData->ndef_detect.flags);      break;     case NFA_DATA_EVT:  // Data message received (for non-NDEF reads)      LOG(DEBUG) << StringPrintf("%s: NFA_DATA_EVT: status = 0x%X, len = %d",                                 __func__, eventData->status,                                 eventData->data.len);      nativeNfcTag_doTransceiveStatus(eventData->status, eventData->data.p_data,                                      eventData->data.len);      break;    case NFA_RW_INTF_ERROR_EVT:      LOG(DEBUG) << StringPrintf("%s: NFC_RW_INTF_ERROR_EVT", __func__);      nativeNfcTag_notifyRfTimeout();      nativeNfcTag_doReadCompleted(NFA_STATUS_TIMEOUT);      break;    case NFA_SELECT_CPLT_EVT:  // Select completed      status = eventData->status;      LOG(DEBUG) << StringPrintf("%s: NFA_SELECT_CPLT_EVT: status = %d",                                 __func__, status);      if (status != NFA_STATUS_OK) {        LOG(ERROR) << StringPrintf("%s: NFA_SELECT_CPLT_EVT error: status = %d",                                   __func__, status);      }      break;     case NFA_READ_CPLT_EVT:  // NDEF-read or tag-specific-read completed      LOG(DEBUG) << StringPrintf("%s: NFA_READ_CPLT_EVT: status = 0x%X",                                 __func__, eventData->status);      nativeNfcTag_doReadCompleted(eventData->status);      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);      break;     case NFA_WRITE_CPLT_EVT:  // Write completed      LOG(DEBUG) << StringPrintf("%s: NFA_WRITE_CPLT_EVT: status = %d",                                 __func__, eventData->status);      nativeNfcTag_doWriteStatus(eventData->status == NFA_STATUS_OK);      break;     case NFA_SET_TAG_RO_EVT:  // Tag set as Read only      LOG(DEBUG) << StringPrintf("%s: NFA_SET_TAG_RO_EVT: status = %d",                                 __func__, eventData->status);      nativeNfcTag_doMakeReadonlyResult(eventData->status);      break;     case NFA_CE_NDEF_WRITE_START_EVT:  // NDEF write started      LOG(DEBUG) << StringPrintf("%s: NFA_CE_NDEF_WRITE_START_EVT: status=%d",                                 __func__, eventData->status);       if (eventData->status != NFA_STATUS_OK)        LOG(ERROR) << StringPrintf(            "%s: NFA_CE_NDEF_WRITE_START_EVT error: status = %d", __func__,            eventData->status);      break;     case NFA_CE_NDEF_WRITE_CPLT_EVT:  // NDEF write completed      LOG(DEBUG) << StringPrintf("%s: FA_CE_NDEF_WRITE_CPLT_EVT: len = %u",                                 __func__, eventData->ndef_write_cplt.len);      break;     case NFA_PRESENCE_CHECK_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_PRESENCE_CHECK_EVT", __func__);      nativeNfcTag_doPresenceCheckResult(eventData->status);      break;    case NFA_FORMAT_CPLT_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_FORMAT_CPLT_EVT: status=0x%X",                                 __func__, eventData->status);      nativeNfcTag_formatStatus(eventData->status == NFA_STATUS_OK);      break;     case NFA_I93_CMD_CPLT_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_I93_CMD_CPLT_EVT: status=0x%X",                                 __func__, eventData->status);      break;     case NFA_CE_UICC_LISTEN_CONFIGURED_EVT:      LOG(DEBUG) << StringPrintf(          "%s: NFA_CE_UICC_LISTEN_CONFIGURED_EVT : status=0x%X", __func__,          eventData->status);      break;    case NFA_T4TNFCEE_EVT:    case NFA_T4TNFCEE_READ_CPLT_EVT:    case NFA_T4TNFCEE_WRITE_CPLT_EVT:    case NFA_T4TNFCEE_CLEAR_CPLT_EVT:    case NFA_T4TNFCEE_READ_CC_DATA_CPLT_EVT:      NativeT4tNfcee::getInstance().eventHandler(connEvent, eventData);      break;     default:      LOG(DEBUG) << StringPrintf("%s: unknown event (%d) ????", __func__,                                 connEvent);      break;  } } /******************************************************************************* ** ** Function:        nfcManager_initNativeStruc ** ** Description:     Initialize variables. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_initNativeStruc(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  initializeGlobalDebugEnabledFlag();  initializeRecoveryOption();  initializeNfceePowerAndLinkConf();  initializeDisableAlwaysOnNfceePowerAndLinkConf();  LOG(DEBUG) << StringPrintf("%s: enter", __func__);   nfc_jni_native_data* nat =      (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));  if (nat == NULL) {    LOG(ERROR) << StringPrintf("%s: fail allocate native data", __func__);    return JNI_FALSE;  }   memset(nat, 0, sizeof(*nat));  e->GetJavaVM(&(nat->vm));  nat->env_version = e->GetVersion();  nat->manager = e->NewGlobalRef(o);   ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jfieldID f = e->GetFieldID(cls.get(), "mNative", "J");  e->SetLongField(o, f, (jlong)nat);   /* Initialize native cached references */  gCachedNfcManagerNotifyNdefMessageListeners =      e->GetMethodID(cls.get(), "notifyNdefMessageListeners",                     "(Lcom/android/nfc/dhimpl/NativeNfcTag;)V");   gCachedNfcManagerNotifyHostEmuActivated =      e->GetMethodID(cls.get(), "notifyHostEmuActivated", "(I)V");   gCachedNfcManagerNotifyHostEmuData =      e->GetMethodID(cls.get(), "notifyHostEmuData", "(I[B)V");   gCachedNfcManagerNotifyHostEmuDeactivated =      e->GetMethodID(cls.get(), "notifyHostEmuDeactivated", "(I)V");   gCachedNfcManagerNotifyRfFieldActivated =      e->GetMethodID(cls.get(), "notifyRfFieldActivated", "()V");  gCachedNfcManagerNotifyRfFieldDeactivated =      e->GetMethodID(cls.get(), "notifyRfFieldDeactivated", "()V");   gCachedNfcManagerNotifyTransactionListeners = e->GetMethodID(      cls.get(), "notifyTransactionListeners", "([B[BLjava/lang/String;)V");   gCachedNfcManagerNotifyEeUpdated =      e->GetMethodID(cls.get(), "notifyEeUpdated", "()V");   gCachedNfcManagerNotifyHwErrorReported =      e->GetMethodID(cls.get(), "notifyHwErrorReported", "()V");   gCachedNfcManagerNotifyPollingLoopFrame =      e->GetMethodID(cls.get(), "notifyPollingLoopFrame", "(I[B)V");   gCachedNfcManagerNotifyVendorSpecificEvent =      e->GetMethodID(cls.get(), "notifyVendorSpecificEvent", "(II[B)V");   gCachedNfcManagerNotifyWlcStopped =      e->GetMethodID(cls.get(), "notifyWlcStopped", "(I)V");   gCachedNfcManagerNotifyTagDiscovered =      e->GetMethodID(cls.get(), "notifyTagDiscovered", "(Z)V");   gCachedNfcManagerNotifyCommandTimeout =      e->GetMethodID(cls.get(), "notifyCommandTimeout", "()V");   gCachedNfcManagerNotifyObserveModeChanged =      e->GetMethodID(cls.get(), "notifyObserveModeChanged", "(Z)V");   gCachedNfcManagerNotifyRfDiscoveryEvent =      e->GetMethodID(cls.get(), "notifyRFDiscoveryEvent", "(Z)V");   gCachedNfcManagerNotifyEeListenActivated =      e->GetMethodID(cls.get(), "notifyEeListenActivated", "(Z)V");   gCachedNfcManagerNotifyEeAidSelected = e->GetMethodID(      cls.get(), "notifyEeAidSelected", "([BLjava/lang/String;)V");   gCachedNfcManagerNotifyEeProtocolSelected = e->GetMethodID(      cls.get(), "notifyEeProtocolSelected", "(ILjava/lang/String;)V");   gCachedNfcManagerNotifyEeTechSelected = e->GetMethodID(      cls.get(), "notifyEeTechSelected", "(ILjava/lang/String;)V");   gCachedNfcManagerNotifyEndpointRemoved =      e->GetMethodID(cls.get(), "notifyEndpointRemoved", "(I)V");   gCachedNfcManagerOnRestartRfDiscovery =      e->GetMethodID(cls.get(), "onRestartRfDiscovery", "()V");   gCachedNfcManagerOnObserveModeDisabledInFirmware =      e->GetMethodID(cls.get(), "onObserveModeDisabledInFirmware", "(I[B)V");   gCachedNfcManagerOnObserveModeEnabledInFirmware =      e->GetMethodID(cls.get(), "onObserveModeEnabledInFirmware", "()V");   if (nfc_jni_cache_object(e, gNativeNfcTagClassName, &(nat->cached_NfcTag)) ==      -1) {    LOG(ERROR) << StringPrintf("%s: fail cache NativeNfcTag", __func__);    return JNI_FALSE;  }   // Cache the reference to the manager  (void)getNative(e,o);   LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        nfaDeviceManagementCallback ** ** Description:     Receive device management events from stack. **                  dmEvent: Device-management event ID. **                  eventData: Data associated with event ID. ** ** Returns:         None ** *******************************************************************************/ void nfaDeviceManagementCallback(uint8_t dmEvent,                                 tNFA_DM_CBACK_DATA* eventData) {  LOG(DEBUG) << StringPrintf("%s: enter; event=0x%X", __func__, dmEvent);   switch (dmEvent) {    case NFA_DM_ENABLE_EVT: /* Result of NFA_Enable */    {      SyncEventGuard guard(sNfaEnableEvent);      LOG(DEBUG) << StringPrintf("%s: NFA_DM_ENABLE_EVT; status=0x%X", __func__,                                 eventData->status);      sIsNfaEnabled = eventData->status == NFA_STATUS_OK;      sIsDisabling = false;      sNfaEnableEvent.notifyOne();    } break;     case NFA_DM_DISABLE_EVT: /* Result of NFA_Disable */    {      SyncEventGuard guard(sNfaDisableEvent);      LOG(DEBUG) << StringPrintf("%s: NFA_DM_DISABLE_EVT", __func__);      sIsNfaEnabled = false;      sIsDisabling = false;      sNfaDisableEvent.notifyOne();    } break;     case NFA_DM_SET_CONFIG_EVT:  // result of NFA_SetConfig      LOG(DEBUG) << StringPrintf("%s: NFA_DM_SET_CONFIG_EVT", __func__);      {        SyncEventGuard guard(gNfaSetConfigEvent);        gNfaSetConfigEvent.notifyOne();      }      break;     case NFA_DM_GET_CONFIG_EVT: /* Result of NFA_GetConfig */      LOG(DEBUG) << StringPrintf("%s: NFA_DM_GET_CONFIG_EVT", __func__);      {        SyncEventGuard guard(gNfaGetConfigEvent);        if (eventData->status == NFA_STATUS_OK &&            eventData->get_config.tlv_size <= sizeof(gConfig)) {          gCurrentConfigLen = eventData->get_config.tlv_size;          memcpy(gConfig, eventData->get_config.param_tlvs,                 eventData->get_config.tlv_size);        } else {          LOG(ERROR) << StringPrintf("%s: NFA_DM_GET_CONFIG failed", __func__);          gCurrentConfigLen = 0;        }        gNfaGetConfigEvent.notifyOne();      }      break;     case NFA_DM_RF_FIELD_EVT:      LOG(DEBUG) << StringPrintf(          "%s: NFA_DM_RF_FIELD_EVT; status=0x%X; field status=%u", __func__,          eventData->rf_field.status, eventData->rf_field.rf_field_status);      if (eventData->rf_field.status == NFA_STATUS_OK) {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);          return;        }        if (eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON)          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyRfFieldActivated);        else          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyRfFieldDeactivated);      }      break;     case NFA_DM_NFCC_TRANSPORT_ERR_EVT:    case NFA_DM_NFCC_TIMEOUT_EVT: {      if (dmEvent == NFA_DM_NFCC_TIMEOUT_EVT)        LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TIMEOUT_EVT; abort",                                   __func__);      else if (dmEvent == NFA_DM_NFCC_TRANSPORT_ERR_EVT)        LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TRANSPORT_ERR_EVT; abort",                                   __func__);       struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (recovery_option && nat != NULL) {        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);          return;        }        LOG(ERROR) << StringPrintf("%s: toggle NFC state to recovery nfc",                                   __func__);        sIsRecovering = true;        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyHwErrorReported);        {          LOG(DEBUG) << StringPrintf(              "%s: aborting  sNfaEnableDisablePollingEvent", __func__);          SyncEventGuard guard(sNfaEnableDisablePollingEvent);          sNfaEnableDisablePollingEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaEnableEvent", __func__);          SyncEventGuard guard(sNfaEnableEvent);          sNfaEnableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaDisableEvent",                                     __func__);          SyncEventGuard guard(sNfaDisableEvent);          sNfaDisableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaSetPowerSubState",                                     __func__);          SyncEventGuard guard(sNfaSetPowerSubState);          sNfaSetPowerSubState.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting gNfaSetConfigEvent",                                     __func__);          SyncEventGuard guard(gNfaSetConfigEvent);          gNfaSetConfigEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting gNfaGetConfigEvent",                                     __func__);          SyncEventGuard guard(gNfaGetConfigEvent);          gNfaGetConfigEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf(              "%s: aborting RoutingManager::getInstance().mEeUpdateEvent",              __func__);          SyncEventGuard guard(RoutingManager::getInstance().mEeUpdateEvent);          RoutingManager::getInstance().mEeUpdateEvent.notifyOne();        }      } else {        nativeNfcTag_abortWaits();        NfcTag::getInstance().abort();        sAbortConnlessWait = true;        {          LOG(DEBUG) << StringPrintf(              "%s: aborting  sNfaEnableDisablePollingEvent", __func__);          SyncEventGuard guard(sNfaEnableDisablePollingEvent);          sNfaEnableDisablePollingEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaEnableEvent", __func__);          SyncEventGuard guard(sNfaEnableEvent);          sNfaEnableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaDisableEvent",                                     __func__);          SyncEventGuard guard(sNfaDisableEvent);          sNfaDisableEvent.notifyOne();        }        sDiscoveryEnabled = false;        sPollingEnabled = false;         if (!sIsDisabling && sIsNfaEnabled) {          if (gIsDtaEnabled == true) {            LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                       __func__);            NFA_DisableDtamode();          }           NFA_Disable(FALSE);          sIsDisabling = true;        } else {          sIsNfaEnabled = false;          sIsDisabling = false;        }        LOG(ERROR) << StringPrintf("%s: crash NFC service", __func__);        if (nat != NULL) {          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e != NULL) {            e->CallVoidMethod(nat->manager,                              android::gCachedNfcManagerNotifyCommandTimeout);          }        }        //////////////////////////////////////////////        // crash the NFC service process so it can restart automatically        abort();        //////////////////////////////////////////////      }    } break;     case NFA_DM_SET_POWER_SUB_STATE_EVT: {      LOG(DEBUG) << StringPrintf(          "%s: NFA_DM_SET_POWER_SUB_STATE_EVT; status=0x%X", __FUNCTION__,          eventData->power_sub_state.status);      SyncEventGuard guard(sNfaSetPowerSubState);      sNfaSetPowerSubState.notifyOne();    } break;    default:      LOG(DEBUG) << StringPrintf("%s: unhandled event", __func__);      break;  } } /******************************************************************************* ** ** Function:        nfcManager_sendRawFrame ** ** Description:     Send a raw frame. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_sendRawFrame(JNIEnv* e, jobject, jbyteArray data) {  if (sIsShuttingDown) return false;  ScopedByteArrayRO bytes(e, data);  uint8_t* buf =      const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  size_t bufLen = bytes.size();  tNFA_STATUS status = NFA_SendRawFrame(buf, bufLen, 0);   return (status == NFA_STATUS_OK); } /******************************************************************************* ** ** Function:        nfcManager_routeAid ** ** Description:     Route an AID to an EE **                  e: JVM environment. **                  aid: aid to be added to routing table. **                  route: aid route location. i.e. DH/eSE/UICC **                  aidInfo: prefix or suffix aid. ** ** Returns:         True if aid is accpted by NFA Layer. ** *******************************************************************************/ static jboolean nfcManager_routeAid(JNIEnv* e, jobject, jbyteArray aid,                                    jint route, jint aidInfo, jint power) {  if (sIsShuttingDown) return false;  uint8_t* buf;  size_t bufLen;  if (sIsDisabling || !sIsNfaEnabled) {    return false;  }   if (aid == NULL) {    buf = NULL;    bufLen = 0;    return RoutingManager::getInstance().addAidRouting(buf, bufLen, route,                                                       aidInfo, power);  }  ScopedByteArrayRO bytes(e, aid);  buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  bufLen = bytes.size();  if (NfcConfig::hasKey(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {    if (route == (int)NfcConfig::getUnsigned(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {      NativeT4tNfcee::getInstance().checkAndUpdateT4TAid(buf,                                                         (uint8_t*)&bufLen);    }  }  return RoutingManager::getInstance().addAidRouting(buf, bufLen, route,                                                     aidInfo, power); } /******************************************************************************* ** ** Function:        nfcManager_unrouteAid ** ** Description:     Remove a AID routing **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_unrouteAid(JNIEnv* e, jobject, jbyteArray aid) {  if (sIsShuttingDown) return false;  uint8_t* buf;  size_t bufLen;  if (sIsDisabling || !sIsNfaEnabled) {    return false;  }   if (aid == NULL) {    buf = NULL;    bufLen = 0;    return RoutingManager::getInstance().removeAidRouting(buf, bufLen);  }  ScopedByteArrayRO bytes(e, aid);  buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  bufLen = bytes.size();  return RoutingManager::getInstance().removeAidRouting(buf, bufLen); } /******************************************************************************* ** ** Function:        nfcManager_commitRouting ** ** Description:     Sends the AID routing table to the controller **                  e: JVM environment. **                  o: Java object. ** ** Returns:         NFA_STATUS_OK if successfully initiated **                  NFA_STATUS_SEMANTIC_ERROR is update is currently in progress **                  NFA_STATUS_FAILED otherwise ** *******************************************************************************/ static jint nfcManager_commitRouting(JNIEnv* e, jobject) {  if (sIsShuttingDown) return -1;  if (sRfEnabled) {    /*Update routing table only in Idle state.*/    startRfDiscovery(false);  }  jint commitStatus = RoutingManager::getInstance().commitRouting();  startRfDiscovery(true);  return commitStatus; } void static nfaVSCallback(uint8_t event, uint16_t param_len, uint8_t* p_param) {  switch (event & NCI_OID_MASK) {    case NCI_MSG_PROP_ANDROID: {      uint8_t android_sub_opcode = p_param[3];      switch (android_sub_opcode) {        case NCI_QUERY_ANDROID_PASSIVE_OBSERVE: {          gObserveModeEnabled = p_param[5];          LOG(INFO) << StringPrintf("%s: Query Observe mode state is %s",                                    __func__,                                    gObserveModeEnabled ? "TRUE" : "FALSE");        }          FALLTHROUGH_INTENDED;        case NCI_ANDROID_SET_PASSIVE_OBSERVER_TECH:        case NCI_ANDROID_PASSIVE_OBSERVE:        case NCI_ANDROID_SET_TECH_A_POLLING_LOOP_ANNOTATION:        case NCI_ANDROID_SET_PASSIVE_OBSERVER_EXIT_FRAME: {          gVSCmdStatus = p_param[4];          LOG(INFO) << StringPrintf(              "%s: RSP status: %x to Android proprietary cmd %x", __func__,              gVSCmdStatus, android_sub_opcode);          SyncEventGuard guard(gNfaVsCommand);          gNfaVsCommand.notifyOne();        } break;        case NCI_ANDROID_GET_CAPS: {          gVSCmdStatus = p_param[4];          SyncEventGuard guard(gNfaVsCommand);          if (param_len > 8) {            gCaps.assign(p_param + 8, p_param + param_len);          }          gNfaVsCommand.notifyOne();        } break;        case NCI_ANDROID_POLLING_FRAME_NTF: {          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {            LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);            return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {            LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);            return;          }          ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(param_len));          if (dataJavaArray.get() == NULL) {            LOG(ERROR) << __func__ << ": fail allocate array";            return;          }          e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, param_len,                                (jbyte*)(p_param));          if (e->ExceptionCheck()) {            e->ExceptionClear();            LOG(ERROR) << __func__ << ": failed to fill array";            return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyPollingLoopFrame,                            (jint)param_len, dataJavaArray.get());        } break;        case NCI_ANDROID_PASSIVE_OBSERVER_SUSPENDED_NTF: {          LOG(INFO) << "Observe mode suspended NTF received";          gObserveModeEnabled = false;          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {              LOG(ERROR) << StringPrintf("cached nat is null");              return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {              LOG(ERROR) << StringPrintf("jni env is null");              return;          }          if (param_len <= 2) {              LOG(ERROR) <<                    "Cannot parse exit frame from NCI_ANDROID_PASSIVE_OBSERVER_SUSPENDED_NTF";              return;          }          jint exit_frame_type = (jint) p_param[4];          uint16_t exit_frame_len = p_param[5];          ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(exit_frame_len));          if (dataJavaArray.get() == NULL) {              LOG(ERROR) << "fail allocate array";              return;          }          if (exit_frame_len > 0) {              e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, exit_frame_len,                                    (jbyte*)(p_param + 6));              if (e->ExceptionCheck()) {                  e->ExceptionClear();                  LOG(ERROR) << "failed to fill array";                  return;              }          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerOnObserveModeDisabledInFirmware,                            exit_frame_type, dataJavaArray.get());          return;        } break;        case NCI_ANDROID_PASSIVE_OBSERVER_RESUMED_NTF: {          LOG(INFO) << "Observe mode resumed NTF received";          gObserveModeEnabled = true;          struct nfc_jni_native_data *nat = getNative(NULL, NULL);          if (!nat) {              LOG(ERROR) << StringPrintf("cached nat is null");              return;          }          JNIEnv *e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {              LOG(ERROR) << StringPrintf("jni env is null");              return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerOnObserveModeEnabledInFirmware);          return;        } break;        case NCI_ANDROID_RESTART_RF_DISCOVERY_REQUEST_NTF: {                struct nfc_jni_native_data* nat = getNative(NULL, NULL);                if (!nat) {                  LOG(ERROR)                      << StringPrintf("%s: cached nat is null", __func__);                  return;                }                JNIEnv* e = NULL;                ScopedAttach attach(nat->vm, &e);                if (e == NULL) {                  LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);                  return;                }                e->CallVoidMethod(nat->manager,                                  android::gCachedNfcManagerOnRestartRfDiscovery);        } break;        default:          LOG(DEBUG) << StringPrintf("%s: Unknown Android sub opcode %x",                                     __func__, android_sub_opcode);      }    } break;    default: {      if (sEnableVendorNciNotifications) {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __FUNCTION__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __FUNCTION__);          return;        }        ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(param_len));        if (dataJavaArray.get() == NULL) {          LOG(ERROR) << StringPrintf("%s: fail allocate array", __FUNCTION__);          return;        }        e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, param_len,                              (jbyte*)(p_param));        if (e->ExceptionCheck()) {          e->ExceptionClear();          LOG(ERROR) << StringPrintf("%s failed to fill array", __FUNCTION__);          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyVendorSpecificEvent,                          (jint)event, (jint)param_len, dataJavaArray.get());      }    } break;  } } static void nfcManager_injectNtf(JNIEnv* e, jobject, jbyteArray data) {  if (sIsShuttingDown) return;  ScopedByteArrayRO bytes(e, data);  size_t bufLen = bytes.size();  tNFC_HAL_EVT_MSG* p_msg;  p_msg = (tNFC_HAL_EVT_MSG*)GKI_getbuf(sizeof(tNFC_HAL_EVT_MSG) + bufLen + 1);  if (p_msg != NULL) {    p_msg->hdr.len = bufLen + 3;    p_msg->hdr.event = BT_EVT_TO_NFC_NCI;    p_msg->hdr.offset = sizeof(tNFC_HAL_EVT_MSG) - 7;    p_msg->hdr.layer_specific = 0;    memcpy(((uint8_t*)p_msg) + sizeof(tNFC_HAL_EVT_MSG) + 1, bytes.get(),           bufLen);    GKI_send_msg(NFC_TASK, NFC_MBOX_ID, p_msg);  } } static jboolean isObserveModeSupported(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported =      e->GetMethodID(cls.get(), "isObserveModeSupported", "()Z");  return e->CallBooleanMethod(o, isSupported); } static jboolean nfcManager_isObserveModeEnabled(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  if (isObserveModeSupported(e, o) == JNI_FALSE) {    return false;  }   uint8_t cmd[] = {NCI_QUERY_ANDROID_PASSIVE_OBSERVE};  SyncEventGuard guard(gNfaVsCommand);  tNFA_STATUS status =      NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, sizeof(cmd), cmd, nfaVSCallback);   if (status == NFA_STATUS_OK) {    if (!gNfaVsCommand.wait(1000)) {      LOG(ERROR) << StringPrintf(          "%s: Timed out waiting for a response to get observe mode ",          __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  } else {    LOG(DEBUG) << StringPrintf("%s: Failed to get observe mode ", __FUNCTION__);  }  LOG(DEBUG) << StringPrintf(      "%s: returning %s", __FUNCTION__,      (gObserveModeEnabled != JNI_FALSE ? "TRUE" : "FALSE"));  return gObserveModeEnabled; } static void nfaSendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                    uint8_t* p_param) {  if (param_len == 5) {    gVSCmdStatus = p_param[4];  } else {    gVSCmdStatus = NFA_STATUS_FAILED;  }  SyncEventGuard guard(gNfaVsCommand);  gNfaVsCommand.notifyOne(); } bool isObserveModeSupportedWithoutRfDeactivation(JNIEnv* e, jobject o) {  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported = e->GetMethodID(      cls.get(), "isObserveModeSupportedWithoutRfDeactivation", "()Z");  return e->CallBooleanMethod(o, isSupported); } static jboolean nfcManager_setObserveMode(JNIEnv* e, jobject o,                                          jboolean enable) {  if (sIsShuttingDown) return false;  if (isObserveModeSupported(e, o) == JNI_FALSE) {    LOG(DEBUG) << "setObserveMode called when it isn't supported, returning false";    return false;  }   if (isObserveModeSupportedWithoutRfDeactivation(e, o) == JNI_FALSE) {    LOG(DEBUG) << "setObserveMode called when it requires RF off/on, returning false";    return false;  }   if ((gObserveModeEnabled == enable) &&      ((enable != JNI_FALSE) ==       (nfcManager_isObserveModeEnabled(e, o) != JNI_FALSE))) {    LOG(DEBUG) << StringPrintf(        "%s: called with %s but it is already %s, returning early",        __FUNCTION__, (enable != JNI_FALSE ? "TRUE" : "FALSE"),        (gObserveModeEnabled != JNI_FALSE ? "TRUE" : "FALSE"));    return true;  }  uint8_t cmd[] = {      static_cast<uint8_t>(NCI_ANDROID_SET_PASSIVE_OBSERVER_TECH),      static_cast<uint8_t>(          enable != JNI_FALSE              ? (NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_A |                           NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_B |                           NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_V)              : NCI_ANDROID_PASSIVE_OBSERVE_PARAM_DISABLE)};  {    SyncEventGuard guard(gNfaVsCommand);    tNFA_STATUS status = NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, sizeof(cmd),                                           cmd, nfaVSCallback);     if (status == NFA_STATUS_OK) {      if (!gNfaVsCommand.wait(1000)) {        LOG(ERROR) << StringPrintf(            "%s: Timed out waiting for a response to set observe mode ",            __FUNCTION__);        gVSCmdStatus = NFA_STATUS_FAILED;      }    } else {      LOG(DEBUG) << StringPrintf("%s: Failed to set observe mode ",                                 __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  }   if (gVSCmdStatus == NFA_STATUS_OK) {    gObserveModeEnabled = enable;  } else {    gObserveModeEnabled = nfcManager_isObserveModeEnabled(e, o);  }   LOG(DEBUG) << StringPrintf(      "%s: Set observe mode to %s with result %x, observe mode is now %s.",      __FUNCTION__, (enable != JNI_FALSE ? "TRUE" : "FALSE"), gVSCmdStatus,      (gObserveModeEnabled ? "enabled" : "disabled"));  if (gObserveModeEnabled == enable) {    e->CallVoidMethod(o, android::gCachedNfcManagerNotifyObserveModeChanged,                      enable);    return true;  } else {    return false;  } } /******************************************************************************* ** ** Function:        nfcManager_doRegisterT3tIdentifier ** ** Description:     Registers LF_T3T_IDENTIFIER for NFC-F. **                  e: JVM environment. **                  o: Java object. **                  t3tIdentifier: LF_T3T_IDENTIFIER value (10 or 18 bytes) ** ** Returns:         Handle retrieve from RoutingManager. ** *******************************************************************************/ static jint nfcManager_doRegisterT3tIdentifier(JNIEnv* e, jobject,                                               jbyteArray t3tIdentifier) {  if (sIsShuttingDown) return -1;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);   ScopedByteArrayRO bytes(e, t3tIdentifier);  uint8_t* buf =      const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  size_t bufLen = bytes.size();  int handle = RoutingManager::getInstance().registerT3tIdentifier(buf, bufLen);   LOG(DEBUG) << StringPrintf("%s: handle=%d", __func__, handle);  if (handle != NFA_HANDLE_INVALID)    RoutingManager::getInstance().commitRouting();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);   return handle; } /******************************************************************************* ** ** Function:        nfcManager_doDeregisterT3tIdentifier ** ** Description:     Deregisters LF_T3T_IDENTIFIER for NFC-F. **                  e: JVM environment. **                  o: Java object. **                  handle: Handle retrieve from libnfc-nci. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doDeregisterT3tIdentifier(JNIEnv*, jobject,                                                 jint handle) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter; handle=%d", __func__, handle);   RoutingManager::getInstance().deregisterT3tIdentifier(handle);  RoutingManager::getInstance().commitRouting();   LOG(DEBUG) << StringPrintf("%s: exit", __func__); } /******************************************************************************* ** ** Function:        nfcManager_getLfT3tMax ** ** Description:     Returns LF_T3T_MAX value. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         LF_T3T_MAX value. ** *******************************************************************************/ static jint nfcManager_getLfT3tMax(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  LOG(DEBUG) << StringPrintf("%s: LF_T3T_MAX=%d", __func__, sLfT3tMax);  return sLfT3tMax; } /******************************************************************************* ** ** Function:        doPartialInit ** ** Description:     Partial Nfc initialization based on mode set **	            ENABLE_MODE_TRANSPARENT : Minimum initialization to allow **                                 NFCC transport **	            ENABLE_MODE_EE : Minimum Initialization to allow card **                                 emulation operation ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean doPartialInit() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  tNFA_STATUS stat = NFA_STATUS_OK;   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Initialize();  // start GKI, NCI task, NFC task   {    SyncEventGuard guard(sNfaEnableEvent);    tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();    NFA_Partial_Init(halFuncEntries, gPartialInitMode);    LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);    NFA_RegVSCback(true, &nfaVSCallback);     LOG(DEBUG) << StringPrintf("%s: calling enable", __func__);    stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);    if (stat == NFA_STATUS_OK) {      sNfaEnableEvent.wait();  // wait for NFA command to finish    }    NFA_SetNfccMode(ENABLE_MODE_DEFAULT);  }   // sIsNfaEnabled indicates whether stack started successfully  if (!sIsNfaEnabled) {    NFA_Disable(false /* ungraceful */);    theInstance.Finalize();    return JNI_FALSE;  }  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        nfcManager_doInitialize ** ** Description:     Turn on NFC. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  initializeGlobalDebugEnabledFlag();  tNFA_STATUS stat = NFA_STATUS_OK;  sIsRecovering = false;   struct nfc_jni_native_data* nat = getNative(e, o);   if (sIsNfaEnabled) {    LOG(DEBUG) << StringPrintf("%s: already enabled", __func__);    goto TheEnd;  }  if (gPartialInitMode != ENABLE_MODE_DEFAULT) {    return doPartialInit();  }   {     NfcAdaptation& theInstance = NfcAdaptation::GetInstance();    theInstance.Initialize();  // start GKI, NCI task, NFC task     {      SyncEventGuard guard(sNfaEnableEvent);      tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();       NFA_Init(halFuncEntries);       LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);      NFA_RegVSCback(true, &nfaVSCallback);       if (gIsDtaEnabled == true) {        // Allows to set appl_dta_mode_flag        LOG(DEBUG) << StringPrintf("%s: DTA; set dta flag in core stack",                                   __func__);        NFA_EnableDtamode((tNFA_eDtaModes)NFA_DTA_APPL_MODE);      }       stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);      if (stat == NFA_STATUS_OK) {        sNfaEnableEvent.wait();  // wait for NFA command to finish      }    }     if (stat == NFA_STATUS_OK) {      // sIsNfaEnabled indicates whether stack started successfully      if (sIsNfaEnabled) {        sRoutingInitialized =            RoutingManager::getInstance().initialize(getNative(e, o));        nativeNfcTag_registerNdefTypeHandler();        NfcTag::getInstance().initialize(getNative(e, o));        HciEventManager::getInstance().initialize(getNative(e, o));        NativeWlcManager::getInstance().initialize(getNative(e, o));        NativeT4tNfcee::getInstance().initialize();         /////////////////////////////////////////////////////////////////////////////////        // Add extra configuration here (work-arounds, etc.)         if (nat) {          nat->tech_mask =              NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);          LOG(DEBUG) << StringPrintf("%s: tag polling tech mask=0x%X", __func__,                                     nat->tech_mask);           // if this value exists, set polling interval.          nat->discovery_duration = NfcConfig::getUnsigned(              NAME_NFA_DM_DISC_DURATION_POLL, DEFAULT_DISCOVERY_DURATION);          NFA_SetRfDiscoveryDuration(nat->discovery_duration);        } else {          LOG(ERROR) << StringPrintf("nat is null");        }         // get LF_T3T_MAX        {          SyncEventGuard guard(gNfaGetConfigEvent);          tNFA_PMID configParam[1] = {NCI_PARAM_ID_LF_T3T_MAX};          stat = NFA_GetConfig(1, configParam);          if (stat == NFA_STATUS_OK) {            gNfaGetConfigEvent.wait();            if (gCurrentConfigLen >= 4 ||                gConfig[1] == NCI_PARAM_ID_LF_T3T_MAX) {              LOG(DEBUG) << StringPrintf("%s: lfT3tMax=%d", __func__,                                         gConfig[3]);              sLfT3tMax = gConfig[3];            }          }        }         prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED;         // Do custom NFCA startup configuration.        doStartupConfig(); #ifdef DTA_ENABLED        NfcDta::getInstance().setNfccConfigParams(); #endif /* DTA_ENABLED */        goto TheEnd;      }    }     if (gIsDtaEnabled == true) {      LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                 __func__);      NFA_DisableDtamode();    }     LOG(ERROR) << StringPrintf("%s: fail nfa enable; error=0x%X", __func__,                               stat);     if (sIsNfaEnabled) {      stat = NFA_Disable(FALSE /* ungraceful */);    }     theInstance.Finalize();  } TheEnd:  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return sIsNfaEnabled ? JNI_TRUE : JNI_FALSE; } static void nfcManager_doSetPartialInitMode(JNIEnv*, jobject, jint mode) {  if (sIsShuttingDown) return;  gPartialInitMode = mode; } static void nfcManager_doEnableDtaMode(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  gIsDtaEnabled = true; } static void nfcManager_doDisableDtaMode(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  gIsDtaEnabled = false; } static void nfcManager_doFactoryReset(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.FactoryReset(); } static void nfcManager_doShutdown(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  NativeT4tNfcee::getInstance().onNfccShutdown();  theInstance.DeviceShutdown();  sIsShuttingDown = true; } static void nfcManager_configNfccConfigControl(bool flag) {    // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.    if (NFC_GetNCIVersion() != NCI_VERSION_1_0) {        uint8_t nfa_set_config[] = { 0x00 };         nfa_set_config[0] = (flag == true ? 1 : 0);         tNFA_STATUS status = NFA_SetConfig(NCI_PARAM_ID_NFCC_CONFIG_CONTROL,                                           sizeof(nfa_set_config),                                           &nfa_set_config[0]);        if (status != NFA_STATUS_OK) {            LOG(ERROR) << __func__            << ": Failed to configure NFCC_CONFIG_CONTROL";        }    } } static bool isReaderModeAnnotationSupported(JNIEnv* e, jobject o) {  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported =      e->GetMethodID(cls.get(), "isReaderModeAnnotationSupportedCaps", "()Z");  return e->CallBooleanMethod(o, isSupported); } static tNFA_STATUS setTechAPollingLoopAnnotation(JNIEnv* env, jobject o,                                                  const uint8_t* annotation_data,                                                  size_t annotation_size) {    std::vector<uint8_t> command;    command.push_back(NCI_ANDROID_SET_TECH_A_POLLING_LOOP_ANNOTATION);    if (annotation_data == NULL || annotation_size == 0) {      // Annotation is null or size is 0, setting 0 annotations      command.push_back(0x00);    } else {      command.push_back(0x01);                 // Number of frame entries.      command.push_back(0x21);                 // Position and type.      command.push_back(annotation_size + 3);  // Length      command.push_back(0x0a);                 // Waiting time      command.insert(command.end(), annotation_data, annotation_data + annotation_size);      command.push_back(0x00);      command.push_back(0x00);    }    SyncEventGuard guard(gNfaVsCommand);    tNFA_STATUS status =        NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, command.size(), command.data(), nfaVSCallback);    if (status == NFA_STATUS_OK) {      if (!gNfaVsCommand.wait(1000)) {        LOG(ERROR) << StringPrintf(            "%s: Timed out waiting for a response to setting a polling loop annotation ",            __FUNCTION__);        gVSCmdStatus = NFA_STATUS_FAILED;      }    } else {      gVSCmdStatus = status;    }    return gVSCmdStatus; } /******************************************************************************* ** ** Function:        nfcManager_enableDiscovery ** ** Description:     Start polling and listening for devices. **                  e: JVM environment. **                  o: Java object. **                  technologies_mask: the bitmask of technologies for which to *enable discovery **                  enable_lptd: whether to enable low power polling (default: *false) ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_enableDiscovery(JNIEnv* e, jobject o,                                       jint technologies_mask,                                       jboolean enable_lptd,                                       jboolean reader_mode,                                       jboolean enable_host_routing,                                       jbyteArray tech_a_polling_loop_annotation,                                       jboolean restart) {  if (sIsShuttingDown) return;  tNFA_TECHNOLOGY_MASK tech_mask = DEFAULT_TECH_MASK;  struct nfc_jni_native_data* nat = getNative(e, o);   if (technologies_mask == -1 && nat)    tech_mask = (tNFA_TECHNOLOGY_MASK)nat->tech_mask;  else if (technologies_mask != -1)    tech_mask = (tNFA_TECHNOLOGY_MASK)technologies_mask;  LOG(DEBUG) << StringPrintf("%s: enter; tech_mask = %02x", __func__,                             tech_mask);   if (sDiscoveryEnabled && !restart) {    LOG(ERROR) << StringPrintf("%s: already discovering", __func__);    return;  }   if (sRfEnabled) {    // Stop RF discovery to reconfigure    startRfDiscovery(false);  }   // Check polling configuration  if (tech_mask != 0) {    stopPolling_rfDiscoveryDisabled();    if (isReaderModeAnnotationSupported(e, o)) {      if (reader_mode) {        if (tech_a_polling_loop_annotation == NULL) {          setTechAPollingLoopAnnotation(e, o, NULL, 0);        } else {          ScopedByteArrayRO annotationBytes(e, tech_a_polling_loop_annotation);          setTechAPollingLoopAnnotation(e, o,                                        (const uint8_t*)annotationBytes.get(),                                        annotationBytes.size());        }      } else if (reader_mode_ignore_frame()) {        uint8_t ignoreFrame[] = {0x6a, 0x01, 0xcf, 0x00, 0x00};        setTechAPollingLoopAnnotation(e, 0, ignoreFrame, 5);      }    }     startPolling_rfDiscoveryDisabled(tech_mask);     if (sPollingEnabled) {      if (reader_mode && !sReaderModeEnabled) {        sReaderModeEnabled = true;        NFA_DisableListening();         // configure NFCC_CONFIG_CONTROL- NFCC not allowed to manage RF configuration.        nfcManager_configNfccConfigControl(false);         NFA_SetRfDiscoveryDuration(READER_MODE_DISCOVERY_DURATION);      } else if (!reader_mode && sReaderModeEnabled) {        struct nfc_jni_native_data* nat = getNative(e, o);        sReaderModeEnabled = false;        NFA_EnableListening();         // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.        nfcManager_configNfccConfigControl(true);         if (nat) {          NFA_SetRfDiscoveryDuration(nat->discovery_duration);        } else {          LOG(ERROR) << StringPrintf("%s: nat is null", __func__);        }      }    }  } else {    if (!reader_mode && sReaderModeEnabled) {      LOG(DEBUG) << StringPrintf(          "%s: if reader mode disable, enable listen again", __func__);      struct nfc_jni_native_data* nat = getNative(e, o);      sReaderModeEnabled = false;      NFA_EnableListening();       // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.      nfcManager_configNfccConfigControl(true);       if (nat) {        NFA_SetRfDiscoveryDuration(nat->discovery_duration);      } else {        LOG(ERROR) << StringPrintf("%s: nat is null", __func__);      }    }    // No technologies configured, stop polling    stopPolling_rfDiscoveryDisabled();  }   // Checking if RT should be updated  RoutingManager::getInstance().commitRouting();   // Actually start discovery.  startRfDiscovery(true);  sDiscoveryEnabled = true;   LOG(DEBUG) << StringPrintf("%s: exit", __func__); } /******************************************************************************* ** ** Function:        nfcManager_disableDiscovery ** ** Description:     Stop polling and listening for devices. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         None ** *******************************************************************************/ void nfcManager_disableDiscovery(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return;  tNFA_STATUS status = NFA_STATUS_OK;  LOG(DEBUG) << StringPrintf("%s: enter;", __func__);   if (sDiscoveryEnabled == false) {    LOG(DEBUG) << StringPrintf("%s: already disabled", __func__);    goto TheEnd;  }   // Stop RF Discovery.  startRfDiscovery(false);  sDiscoveryEnabled = false;  if (sPollingEnabled) status = stopPolling_rfDiscoveryDisabled(); TheEnd:  LOG(DEBUG) << StringPrintf("%s: exit: Status = 0x%X", __func__, status); } /******************************************************************************* ** ** Function:        doPartialDeinit ** ** Description:     Partial DeInit for mode TRANSPARENT, CE .. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean doPartialDeinit() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  tNFA_STATUS stat = NFA_STATUS_OK;  sIsDisabling = true;  if (sIsNfaEnabled) {    SyncEventGuard guard(sNfaDisableEvent);    stat = NFA_Disable(TRUE /* graceful */);    if (stat == NFA_STATUS_OK) {      LOG(DEBUG) << StringPrintf("%s: wait for completion", __func__);      sNfaDisableEvent.wait();  // wait for NFA command to finish    } else {      LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,                                 stat);    }  }  sIsDisabling = false;   LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);  NFA_RegVSCback(false, &nfaVSCallback);   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  theInstance.Finalize();   return stat == NFA_STATUS_OK ? JNI_TRUE : JNI_FALSE; } /******************************************************************************* ** ** Function:        nfcManager_doDeinitialize ** ** Description:     Turn off NFC. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doDeinitialize(JNIEnv*, jobject) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter, sIsRecovering=%d", __func__,                             sIsRecovering);  if (gPartialInitMode != ENABLE_MODE_DEFAULT) {    return doPartialDeinit();  }  sIsDisabling = true;   NativeT4tNfcee::getInstance().onNfccShutdown();  if (!recovery_option || !sIsRecovering) {    RoutingManager::getInstance().onNfccShutdown();  }  HciEventManager::getInstance().finalize();   if (sIsNfaEnabled) {    SyncEventGuard guard(sNfaDisableEvent);     if (gIsDtaEnabled == true) {      LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                 __func__);      NFA_DisableDtamode();    }     tNFA_STATUS stat = NFA_Disable(!sIsRecovering);    if (stat == NFA_STATUS_OK) {      LOG(DEBUG) << StringPrintf("%s: wait for completion", __func__);      if (!sNfaDisableEvent.wait(5000)) {        LOG(ERROR) << StringPrintf(            "%s: NFA_Disable() timeout, keep disabling anyway", __func__);      }    } else {      LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,                                 stat);    }  }  nativeNfcTag_abortWaits();  NfcTag::getInstance().abort();  sAbortConnlessWait = true;  sIsNfaEnabled = false;  sRoutingInitialized = false;  sDiscoveryEnabled = false;  sPollingEnabled = false;  sIsDisabling = false;  sReaderModeEnabled = false;  gActivated = false;  sRfEnabled = false;  sLfT3tMax = 0;   {    // unblock NFA_EnablePolling() and NFA_DisablePolling()    SyncEventGuard guard(sNfaEnableDisablePollingEvent);    sNfaEnableDisablePollingEvent.notifyOne();  }   LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);  NFA_RegVSCback(false, &nfaVSCallback);  // abort any active waits  {    SyncEventGuard guard(sNfaSetPowerSubState);    sNfaSetPowerSubState.notifyOne();  }  {    SyncEventGuard guard(sNfaEnableDisablePollingEvent);    sNfaEnableDisablePollingEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaSetConfigEvent);    gNfaSetConfigEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaGetConfigEvent);    gNfaGetConfigEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaVsCommand);    gNfaVsCommand.notifyOne();  }  {    SyncEventGuard guard(gSendRawVsCmdEvent);    gSendRawVsCmdEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaRemoveEpEvent);    gNfaRemoveEpEvent.notifyOne();  }   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Finalize();   LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        isListenMode ** ** Description:     Indicates whether the activation data indicates it is **                  listen mode. ** ** Returns:         True if this listen mode. ** *******************************************************************************/ static bool isListenMode(tNFA_ACTIVATED& activated) {  return (      (NFC_DISCOVERY_TYPE_LISTEN_A ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_B ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_F ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_ISO15693 ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_B_PRIME ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_INTERFACE_EE_DIRECT_RF == activated.activate_ntf.intf_param.type)); } /******************************************************************************* ** ** Function:        nfcManager_doAbort ** ** Description:     Not used. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doAbort(JNIEnv* e, jobject, jstring msg) {  ScopedUtfChars message = {e, msg};  e->FatalError(message.c_str());  abort();  // <-- Unreachable } /******************************************************************************* ** ** Function:        nfcManager_doDownload ** ** Description:     Download firmware patch files.  Do not turn on NFC. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doDownload(JNIEnv*, jobject) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  bool result = JNI_FALSE;  theInstance.Initialize();  // start GKI, NCI task, NFC task  tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();  NFA_Partial_Init(halFuncEntries, ENABLE_MODE_TRANSPARENT);  NFA_RegVSCback(true, &nfaVSCallback);  result = theInstance.DownloadFirmware();  NFA_RegVSCback(false, &nfaVSCallback);  theInstance.Finalize();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return result; } /******************************************************************************* ** ** Function:        nfcManager_doResetTimeouts ** ** Description:     Not used. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doResetTimeouts(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s", __func__);  NfcTag::getInstance().resetAllTransceiveTimeouts(true); } /******************************************************************************* ** ** Function:        nfcManager_doSetTimeout ** ** Description:     Set timeout value. **                  e: JVM environment. **                  o: Java object. **                  tech: technology ID. **                  timeout: Timeout value. ** ** Returns:         True if ok. ** *******************************************************************************/ static bool nfcManager_doSetTimeout(JNIEnv*, jobject, jint tech, jint timeout) {  if (sIsShuttingDown) return false;  if (timeout <= 0) {    LOG(ERROR) << StringPrintf("%s: Timeout must be positive.", __func__);    return false;  }  LOG(DEBUG) << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech,                             timeout);  NfcTag::getInstance().setTransceiveTimeout(tech, timeout);  return true; } /******************************************************************************* ** ** Function:        nfcManager_doGetTimeout ** ** Description:     Get timeout value. **                  e: JVM environment. **                  o: Java object. **                  tech: technology ID. ** ** Returns:         Timeout value. ** *******************************************************************************/ static jint nfcManager_doGetTimeout(JNIEnv*, jobject, jint tech) {  if (sIsShuttingDown) return -1;  int timeout = NfcTag::getInstance().getTransceiveTimeout(tech);  LOG(DEBUG) << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech,                             timeout);  return timeout; } /******************************************************************************* ** ** Function:        nfcManager_doDump ** ** Description:     Get libnfc-nci dump **                  e: JVM environment. **                  obj: Java object. **                  fdobj: File descriptor to be used ** ** Returns:         Void ** *******************************************************************************/ static void nfcManager_doDump(JNIEnv* e, jobject obj, jobject fdobj) {  if (sIsShuttingDown) return;  int fd = jniGetFDFromFileDescriptor(e, fdobj);  if (fd < 0) return;   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Dump(fd); } static jint nfcManager_doGetNciVersion(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  return NFC_GetNCIVersion(); } static void nfcManager_doSetScreenState(JNIEnv* e, jobject o,                                        jint screen_state_mask,                                        jboolean alwaysPoll) {  if (sIsShuttingDown) return;  tNFA_STATUS status = NFA_STATUS_OK;  uint8_t state = (screen_state_mask & NFA_SCREEN_STATE_MASK);  uint8_t discovry_param =      NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;  sIsAlwaysPolling = alwaysPoll;   LOG(DEBUG) << StringPrintf(      "%s: state = %d prevScreenState= %d, discovry_param = %d", __FUNCTION__,      state, prevScreenState, discovry_param);   if (prevScreenState == state) {    LOG(DEBUG) << StringPrintf(        "%s: New screen state is same as previous state. No action taken",        __func__);    return;  }   if (sIsDisabling || !sIsNfaEnabled ||      (NFC_GetNCIVersion() != NCI_VERSION_2_0)) {    prevScreenState = state;    return;  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||      prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED ||      prevScreenState == NFA_SCREEN_STATE_ON_LOCKED) {    SyncEventGuard guard(sNfaSetPowerSubState);    status = NFA_SetPowerSubStateForScreenState(state);    if (status != NFA_STATUS_OK) {      LOG(ERROR) << StringPrintf("%s: fail enable SetScreenState; error=0x%X",                                 __FUNCTION__, status);      return;    } else {      sNfaSetPowerSubState.wait();    }  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (state == NFA_SCREEN_STATE_OFF_LOCKED ||      state == NFA_SCREEN_STATE_OFF_UNLOCKED) {    // disable poll and enable listen on DH 0x00    discovry_param =        NCI_POLLING_DH_DISABLE_MASK | NCI_LISTEN_DH_NFCEE_ENABLE_MASK;  }   if (state == NFA_SCREEN_STATE_ON_LOCKED) {    // disable poll and enable listen on DH 0x00    discovry_param =        (screen_state_mask & NFA_SCREEN_POLLING_TAG_MASK)            ? (NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK)            : (NCI_POLLING_DH_DISABLE_MASK | NCI_LISTEN_DH_NFCEE_ENABLE_MASK);  }   if (state == NFA_SCREEN_STATE_ON_UNLOCKED) {    // enable both poll and listen on DH 0x01    discovry_param =        NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;  }   if (!sIsAlwaysPolling) {    SyncEventGuard guard(gNfaSetConfigEvent);    status = NFA_SetConfig(NCI_PARAM_ID_CON_DISCOVERY_PARAM,                           NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);    if (status == NFA_STATUS_OK) {      gNfaSetConfigEvent.wait();    } else {      LOG(ERROR) << StringPrintf("%s: Failed to update CON_DISCOVER_PARAM",                                 __FUNCTION__);      return;    }  }  // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED) {    SyncEventGuard guard(sNfaSetPowerSubState);    status = NFA_SetPowerSubStateForScreenState(state);    if (status != NFA_STATUS_OK) {      LOG(ERROR) << StringPrintf("%s: fail enable SetScreenState; error=0x%X",                                 __FUNCTION__, status);    } else {      sNfaSetPowerSubState.wait();    }  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if ((state == NFA_SCREEN_STATE_OFF_LOCKED ||       state == NFA_SCREEN_STATE_OFF_UNLOCKED) &&      (prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED ||       prevScreenState == NFA_SCREEN_STATE_ON_LOCKED) &&      (!sSeRfActive)) {    // screen turns off, disconnect tag if connected    nativeNfcTag_doDisconnect(NULL, NULL);  }   prevScreenState = state; } /******************************************************************************* ** ** Function:        nfcManager_getIsoDepMaxTransceiveLength ** ** Description:     Get maximum ISO DEP Transceive Length supported by the NFC **                  chip. Returns default 261 bytes if the property is not set. ** ** Returns:         max value. ** *******************************************************************************/ static jint nfcManager_getIsoDepMaxTransceiveLength(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  /* Check if extended APDU is supported by the chip.   * If not, default value is returned.   * The maximum length of a default IsoDep frame consists of:   * CLA, INS, P1, P2, LC, LE + 255 payload bytes = 261 bytes   */  return NfcConfig::getUnsigned(NAME_ISO_DEP_MAX_TRANSCEIVE, 261); } /******************************************************************************* ** ** Function:        nfcManager_getAidTableSize ** Description:     Get the maximum supported size for AID routing table. ** **                  e: JVM environment. **                  o: Java object. ** *******************************************************************************/ static jint nfcManager_getAidTableSize(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  return NFA_GetAidTableSize(); } /******************************************************************************* ** ** Function:        nfcManager_IsMultiTag ** ** Description:     Check if it a multi tag case. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         None. ** *******************************************************************************/ static bool nfcManager_isMultiTag() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter mNumRfDiscId = %d", __func__,                             NfcTag::getInstance().mNumRfDiscId);  bool status = false;  if (NfcTag::getInstance().mNumRfDiscId > 1) status = true;  LOG(DEBUG) << StringPrintf("isMultiTag = %d", status);  return status; } /******************************************************************************* ** ** Function:        nfcManager_doStartStopPolling ** ** Description:     Start or stop NFC RF polling **                  e: JVM environment. **                  o: Java object. **                  start: start or stop RF polling ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doStartStopPolling(JNIEnv* e, jobject o,                                          jboolean start) {  if (sIsShuttingDown) return;  startStopPolling(start); } /******************************************************************************* ** ** Function:        nfcManager_doSetNfcSecure ** ** Description:     Set NfcSecure enable/disable. **                  e: JVM environment. **                  o: Java object. **                  enable: Sets true/false to enable/disable NfcSecure **                  It only updates the routing table cache without commit to **                  NFCC. ** ** Returns:         True always ** *******************************************************************************/ static jboolean nfcManager_doSetNfcSecure(JNIEnv* e, jobject o,                                          jboolean enable) {  if (sIsShuttingDown) return false;  RoutingManager& routingManager = RoutingManager::getInstance();  routingManager.setNfcSecure(enable);  if (sRoutingInitialized) {    routingManager.setEeTechRouteUpdateRequired();  }  return true; } static void nfcManager_doSetNfceePowerAndLinkCtrl(JNIEnv* e, jobject o,                                                  jboolean enable) {  if (sIsShuttingDown) return;  RoutingManager& routingManager = RoutingManager::getInstance();  if (enable) {    routingManager.eeSetPwrAndLinkCtrl(        (uint8_t)always_on_nfcee_power_and_link_conf);  } else {    routingManager.eeSetPwrAndLinkCtrl(        (uint8_t)disable_always_on_nfcee_power_and_link_conf);  } } /******************************************************************************* ** ** Function:        nfcManager_doGetMaxRoutingTableSize ** ** Description:     Retrieve the max routing table size from cache **                  e: JVM environment. **                  o: Java object. ** ** Returns:         Max Routing Table size ** *******************************************************************************/ static jint nfcManager_doGetMaxRoutingTableSize(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return -1;  return lmrt_get_max_size(); } /******************************************************************************* ** ** Function:        nfcManager_doGetRoutingTable ** ** Description:     Retrieve the committed listen mode routing configuration **                  e: JVM environment. **                  o: Java object. ** ** Returns:         Committed listen mode routing configuration ** *******************************************************************************/ static jbyteArray nfcManager_doGetRoutingTable(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return nullptr;  std::vector<uint8_t>* routingTable = lmrt_get_tlvs();   CHECK(e);  jbyteArray rtJavaArray = e->NewByteArray((*routingTable).size());  CHECK(rtJavaArray);  e->SetByteArrayRegion(rtJavaArray, 0, (*routingTable).size(),                        (jbyte*)&(*routingTable)[0]);   return rtJavaArray; } static void nfcManager_clearRoutingEntry(JNIEnv* e, jobject o,                                         jint clearFlags) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: clearFlags=0x%X", __func__, clearFlags);  RoutingManager::getInstance().clearRoutingEntry(clearFlags); } /******************************************************************************* ** ** Function:        nfcManager_doDetectEpRemoval ** ** Description:     Start detection of WLC Listener removal **                  e: JVM environment. **                  waiting_time_int: ** ** Returns:         True if WLCL remove started properly ** *******************************************************************************/ static jboolean nfcManager_doDetectEpRemoval(JNIEnv* e, jobject o,                                             jint waiting_time_int) {  if (sIsShuttingDown) return false;  tNFA_STATUS stat = NFA_STATUS_FAILED;   LOG(DEBUG) << StringPrintf("%s: enter waiting_time = %04X", __func__,                             waiting_time_int);   nativeNfcTag_acquireRfInterfaceMutexLock();  stat = NFA_StartRemovalDetection((uint8_t)(waiting_time_int & 0xFF));  if (stat == NFA_STATUS_OK) {    LOG(DEBUG) << StringPrintf(        "%s: start detect EP Listener removal, wait for success confirmation",        __func__);    SyncEventGuard g(gNfaRemoveEpEvent);    gNfaRemoveEpEvent.wait();    stat = sIsEpDetectStarted ? JNI_TRUE : JNI_FALSE;  } else {    LOG(ERROR) << StringPrintf("%s: fail detect EP removal; error=0x%X",                               __func__, stat);    stat = false;  }  nativeNfcTag_releaseRfInterfaceMutexLock();  return stat; } /******************************************************************************* ** ** Function:        nfcManager_isRemovalDetectionSupported ** ** Description:     Check if the Removal Detection in Poll mode is supported. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if supports 'Removal Detection Mode' ** *******************************************************************************/ static jboolean nfcManager_isRemovalDetectionSupported(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  return NFA_IsRfRemovalDetectionSupported(); } static void nfcManager_updateIsoDepProtocolRoute(JNIEnv* e, jobject o,                                                 jint route) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateIsoDepProtocolRoute(route); } static void nfcManager_updateTechnologyABFRoute(JNIEnv* e, jobject o,                                                jint route, jint felicaRoute) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateTechnologyABFRoute(route, felicaRoute); } static void nfcManager_updateSystemCodeRoute(JNIEnv* e, jobject o,                                                jint route) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateSystemCodeRoute(route); } /******************************************************************************* ** ** Function:        nfcManager_setDiscoveryTech ** ** Description:     Temporarily changes the RF parameter **                  pollTech: RF tech parameters for poll mode **                  listenTech: RF tech parameters for listen mode ** ** Returns:         None. ** *******************************************************************************/ static void nfcManager_setDiscoveryTech(JNIEnv* e, jobject o, jint pollTech,                                        jint listenTech) {  if (sIsShuttingDown) return;  tNFA_STATUS nfaStat;  bool isRevertPoll = false;  bool isRevertListen = false;  bool changeDefaultTech = false;  LOG(DEBUG) << StringPrintf("%s  pollTech = 0x%x, listenTech = 0x%x", __func__,                             pollTech, listenTech);   if (pollTech < 0) isRevertPoll = true;  if (listenTech < 0) isRevertListen = true;  if (pollTech & FLAG_SET_DEFAULT_TECH || listenTech & FLAG_SET_DEFAULT_TECH)    changeDefaultTech = true;   // Need listen tech routing update in routing table  // for addition of blocking bit  RoutingManager::getInstance().setEeTechRouteUpdateRequired();   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);   nfaStat = NFA_ChangeDiscoveryTech(pollTech, listenTech, isRevertPoll,                                    isRevertListen, changeDefaultTech);   if (nfaStat == NFA_STATUS_OK) {    // wait for NFA_LISTEN_DISABLED_EVT    sNfaEnableDisablePollingEvent.wait();  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               nfaStat);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } /******************************************************************************* ** ** Function:        nfcManager_resetDiscoveryTech ** ** Description:     Restores the RF tech to the state before **                  nfcManager_setDiscoveryTech was called ** ** Returns:         None. ** *******************************************************************************/ static void nfcManager_resetDiscoveryTech(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return;  tNFA_STATUS nfaStat;  LOG(DEBUG) << StringPrintf("%s : enter", __func__);   // Need listen tech routing update in routing table  // for addition of blocking bit  RoutingManager::getInstance().setEeTechRouteUpdateRequired();   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);   nfaStat = NFA_ChangeDiscoveryTech(0xFF, 0xFF, true, true, false);   if (nfaStat == NFA_STATUS_OK) {    // wait for NFA_LISTEN_DISABLED_EVT    sNfaEnableDisablePollingEvent.wait();  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               nfaStat);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } static void ncfManager_nativeEnableVendorNciNotifications(JNIEnv* env,                                                          jobject o,                                                          jboolean enable) {  if (sIsShuttingDown) return;  sEnableVendorNciNotifications = (enable == JNI_TRUE); } static jobject nfcManager_dofetchActiveNfceeList(JNIEnv* e, jobject o) {  (void)o;  if (sIsShuttingDown) return nullptr;  return NfceeManager::getInstance().getActiveNfceeList(e); } static jobject nfcManager_nativeSendRawVendorCmd(JNIEnv* env, jobject o,                                                 jint mt, jint gid, jint oid,                                                 jbyteArray payload) {  if (sIsShuttingDown) return nullptr;  LOG(DEBUG) << StringPrintf("%s : enter", __func__);  ScopedByteArrayRO payloaBytes(env, payload);  ScopedLocalRef<jclass> cls(env,                             env->FindClass(gNfcVendorNciResponseClassName));  jmethodID responseConstructor =      env->GetMethodID(cls.get(), "<init>", "(BII[B)V");   jbyte mStatus = NFA_STATUS_FAILED;  jint resGid = 0;  jint resOid = 0;  jbyteArray resPayload = nullptr;   sRawVendorCmdResponse.clear();   std::vector<uint8_t> command;  command.push_back((uint8_t)((mt << NCI_MT_SHIFT) | gid));  command.push_back((uint8_t)oid);  command.push_back((uint8_t)payloaBytes.size());  if (payloaBytes.size() > 0) {    command.insert(command.end(), &payloaBytes[0],                   &payloaBytes[payloaBytes.size()]);  }   SyncEventGuard guard(gSendRawVsCmdEvent);  mStatus = NFA_SendRawVsCommand(command.size(), command.data(),                                 sendRawVsCmdCallback);  if (mStatus == NFA_STATUS_OK) {    if (gSendRawVsCmdEvent.wait(2000) == false) {      mStatus = NFA_STATUS_FAILED;      LOG(ERROR) << StringPrintf("%s: timeout ", __func__);    }     if (mStatus == NFA_STATUS_OK && sRawVendorCmdResponse.size() > 2) {      resGid = sRawVendorCmdResponse[0] & NCI_GID_MASK;      resOid = sRawVendorCmdResponse[1];      const jsize len = static_cast<jsize>(sRawVendorCmdResponse[2]);      if (sRawVendorCmdResponse.size() >= (sRawVendorCmdResponse[2] + 3)) {        resPayload = env->NewByteArray(len);        std::vector<uint8_t> payloadVec(sRawVendorCmdResponse.begin() + 3,                                        sRawVendorCmdResponse.end());        env->SetByteArrayRegion(            resPayload, 0, len,            reinterpret_cast<const jbyte*>(payloadVec.data()));      } else {        mStatus = NFA_STATUS_FAILED;        LOG(ERROR) << StringPrintf("%s: invalid payload data", __func__);      }    } else {      mStatus = NFA_STATUS_FAILED;    }  }   LOG(DEBUG) << StringPrintf("%s : exit", __func__);  return env->NewObject(cls.get(), responseConstructor, mStatus, resGid, resOid,                        resPayload); } static void sendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                 uint8_t* p_param) {  sRawVendorCmdResponse = std::vector<uint8_t>(p_param, p_param + param_len);   SyncEventGuard guard(gSendRawVsCmdEvent);  gSendRawVsCmdEvent.notifyOne(); } /* namespace android */ /***************************************************************************** ** ** JNI functions for android-4.0.1_r1 ** *****************************************************************************/ static JNINativeMethod gMethods[] = {    {"doDownload", "()Z", (void*)nfcManager_doDownload},     {"initializeNativeStructure", "()Z", (void*)nfcManager_initNativeStruc},     {"doInitialize", "()Z", (void*)nfcManager_doInitialize},     {"doSetPartialInitMode", "(I)V", (void*)nfcManager_doSetPartialInitMode},     {"doDeinitialize", "()Z", (void*)nfcManager_doDeinitialize},     {"sendRawFrame", "([B)Z", (void*)nfcManager_sendRawFrame},     {"routeAid", "([BIII)Z", (void*)nfcManager_routeAid},     {"unrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},     {"commitRouting", "()I", (void*)nfcManager_commitRouting},     {"doRegisterT3tIdentifier", "([B)I",     (void*)nfcManager_doRegisterT3tIdentifier},     {"doDeregisterT3tIdentifier", "(I)V",     (void*)nfcManager_doDeregisterT3tIdentifier},     {"getLfT3tMax", "()I", (void*)nfcManager_getLfT3tMax},     {"doEnableDiscovery", "(IZZZ[BZ)V", (void*)nfcManager_enableDiscovery},     {"doStartStopPolling", "(Z)V", (void*)nfcManager_doStartStopPolling},     {"disableDiscovery", "()V", (void*)nfcManager_disableDiscovery},     {"doSetTimeout", "(II)Z", (void*)nfcManager_doSetTimeout},     {"doGetTimeout", "(I)I", (void*)nfcManager_doGetTimeout},     {"doResetTimeouts", "()V", (void*)nfcManager_doResetTimeouts},     {"doAbort", "(Ljava/lang/String;)V", (void*)nfcManager_doAbort},     {"doSetScreenState", "(IZ)V", (void*)nfcManager_doSetScreenState},     {"doDump", "(Ljava/io/FileDescriptor;)V", (void*)nfcManager_doDump},     {"getNciVersion", "()I", (void*)nfcManager_doGetNciVersion},    {"doEnableDtaMode", "()V", (void*)nfcManager_doEnableDtaMode},    {"doDisableDtaMode", "()V", (void*)nfcManager_doDisableDtaMode},    {"doFactoryReset", "()V", (void*)nfcManager_doFactoryReset},    {"doShutdown", "()V", (void*)nfcManager_doShutdown},     {"getIsoDepMaxTransceiveLength", "()I",     (void*)nfcManager_getIsoDepMaxTransceiveLength},     {"getAidTableSize", "()I", (void*)nfcManager_getAidTableSize},     {"doSetNfcSecure", "(Z)Z", (void*)nfcManager_doSetNfcSecure},     {"doSetNfceePowerAndLinkCtrl", "(Z)V",     (void*)nfcManager_doSetNfceePowerAndLinkCtrl},     {"doSetPowerSavingMode", "(Z)Z", (void*)nfcManager_doSetPowerSavingMode},     {"getRoutingTable", "()[B", (void*)nfcManager_doGetRoutingTable},     {"getMaxRoutingTableSize", "()I",     (void*)nfcManager_doGetMaxRoutingTableSize},     {"setObserveMode", "(Z)Z", (void*)nfcManager_setObserveMode},     {"isObserveModeEnabled", "()Z", (void*)nfcManager_isObserveModeEnabled},     {"isMultiTag", "()Z", (void*)nfcManager_isMultiTag},     {"clearRoutingEntry", "(I)V", (void*)nfcManager_clearRoutingEntry},     {"setIsoDepProtocolRoute", "(I)V",     (void*)nfcManager_updateIsoDepProtocolRoute},     {"setTechnologyABFRoute", "(II)V",     (void*)nfcManager_updateTechnologyABFRoute},     {"setSystemCodeRoute", "(I)V", (void*)nfcManager_updateSystemCodeRoute},     {"setDiscoveryTech", "(II)V", (void*)nfcManager_setDiscoveryTech},     {"resetDiscoveryTech", "()V", (void*)nfcManager_resetDiscoveryTech},    {"nativeSendRawVendorCmd", "(III[B)Lcom/android/nfc/NfcVendorNciResponse;",     (void*)nfcManager_nativeSendRawVendorCmd},     {"dofetchActiveNfceeList", "()Ljava/util/Map;",     (void*)nfcManager_dofetchActiveNfceeList},     {"getProprietaryCaps", "()[B", (void*)nfcManager_getProprietaryCaps},    {"enableVendorNciNotifications", "(Z)V",     (void*)ncfManager_nativeEnableVendorNciNotifications},    {"injectNtf", "([B)V", (void*)nfcManager_injectNtf},    {"doDetectEpRemoval", "(I)Z", (void*)nfcManager_doDetectEpRemoval},    {"isRemovalDetectionInPollModeSupported", "()Z",     (void*)nfcManager_isRemovalDetectionSupported},    {"setFirmwareExitFrameTable", "([Lcom/android/nfc/ExitFrame;[B)Z",     (void*)nfcManager_setFirmwareExitFrameTable},    {"doRestartRfDiscovery", "()V", (void*)nfcManager_restartRfDiscovery}, }; /******************************************************************************* ** ** Function:        register_com_android_nfc_NativeNfcManager ** ** Description:     Regisgter JNI functions with Java Virtual Machine. **                  e: Environment of JVM. ** ** Returns:         Status of registration. ** *******************************************************************************/ int register_com_android_nfc_NativeNfcManager(JNIEnv* e) {  return jniRegisterNativeMethods(e, gNativeNfcManagerClassName, gMethods,                                  NELEM(gMethods)); } /******************************************************************************* ** ** Function:        startRfDiscovery ** ** Description:     Ask stack to start polling and listening for devices. **                  isStart: Whether to start. ** ** Returns:         None ** *******************************************************************************/ void startRfDiscovery(bool isStart) {  tNFA_STATUS status = NFA_STATUS_FAILED;   LOG(DEBUG) << StringPrintf("%s: is start=%d", __func__, isStart);  nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  status = isStart ? NFA_StartRfDiscovery() : NFA_StopRfDiscovery();  if (status == NFA_STATUS_OK) {    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_RF_DISCOVERY_xxxx_EVT    sRfEnabled = isStart;  } else {    LOG(ERROR) << StringPrintf(        "%s: Failed to start/stop RF discovery; error=0x%X", __func__, status);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } /******************************************************************************* ** ** Function:        isDiscoveryStarted ** ** Description:     Indicates whether the discovery is started. ** ** Returns:         True if discovery is started ** *******************************************************************************/ bool isDiscoveryStarted() { return sRfEnabled; } /******************************************************************************* ** ** Function:        doStartupConfig ** ** Description:     Configure the NFC controller. ** ** Returns:         None ** *******************************************************************************/ void doStartupConfig() {  // configure RF polling frequency for each technology  static tNFA_DM_DISC_FREQ_CFG nfa_dm_disc_freq_cfg;  // values in the polling_frequency[] map to members of nfa_dm_disc_freq_cfg  std::vector<uint8_t> polling_frequency;  if (NfcConfig::hasKey(NAME_POLL_FREQUENCY))    polling_frequency = NfcConfig::getBytes(NAME_POLL_FREQUENCY);  if (polling_frequency.size() == 8) {    LOG(DEBUG) << StringPrintf("%s: polling frequency", __func__);    memset(&nfa_dm_disc_freq_cfg, 0, sizeof(nfa_dm_disc_freq_cfg));    nfa_dm_disc_freq_cfg.pa = polling_frequency[0];    nfa_dm_disc_freq_cfg.pb = polling_frequency[1];    nfa_dm_disc_freq_cfg.pf = polling_frequency[2];    nfa_dm_disc_freq_cfg.pi93 = polling_frequency[3];    nfa_dm_disc_freq_cfg.pbp = polling_frequency[4];    nfa_dm_disc_freq_cfg.pk = polling_frequency[5];    nfa_dm_disc_freq_cfg.paa = polling_frequency[6];    nfa_dm_disc_freq_cfg.pfa = polling_frequency[7];    p_nfa_dm_rf_disc_freq_cfg = &nfa_dm_disc_freq_cfg;  }   // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.  nfcManager_configNfccConfigControl(true); } /******************************************************************************* ** ** Function:        nfcManager_isNfcActive ** ** Description:     Used externaly to determine if NFC is active or not. ** ** Returns:         'true' if the NFC stack is running, else 'false'. ** *******************************************************************************/ bool nfcManager_isNfcActive() { return sIsNfaEnabled; } /******************************************************************************* ** ** Function:        startStopPolling ** ** Description:     Start or stop polling. **                  isStartPolling: true to start polling; false to stop *polling. ** ** Returns:         None. ** *******************************************************************************/ void startStopPolling(bool isStartPolling) {  tNFA_STATUS status = NFA_STATUS_FAILED;  uint8_t discovry_param = 0;  LOG(DEBUG) << StringPrintf("%s: enter; isStart=%u", __func__, isStartPolling);   if (NFC_GetNCIVersion() >= NCI_VERSION_2_0) {    SyncEventGuard guard(gNfaSetConfigEvent);    if (isStartPolling) {      discovry_param =          NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;    } else {      discovry_param =          NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_DISABLE_MASK;    }    status = NFA_SetConfig(NCI_PARAM_ID_CON_DISCOVERY_PARAM,                           NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);    if (status == NFA_STATUS_OK) {      gNfaSetConfigEvent.wait();    } else {      LOG(ERROR) << StringPrintf("%s: Failed to update CON_DISCOVER_PARAM",                                 __FUNCTION__);    }  } else {    startRfDiscovery(false);    if (isStartPolling)      startPolling_rfDiscoveryDisabled(0);    else      stopPolling_rfDiscoveryDisabled();    startRfDiscovery(true);  }  LOG(DEBUG) << StringPrintf("%s: exit", __func__); } static tNFA_STATUS startPolling_rfDiscoveryDisabled(    tNFA_TECHNOLOGY_MASK tech_mask) {  tNFA_STATUS stat = NFA_STATUS_FAILED;   if (tech_mask == 0)    tech_mask =        NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  LOG(DEBUG) << StringPrintf("%s: enable polling", __func__);  stat = NFA_EnablePolling(tech_mask);  if (stat == NFA_STATUS_OK) {    LOG(DEBUG) << StringPrintf("%s: wait for enable event", __func__);    sPollingEnabled = true;    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_ENABLED_EVT  } else {    LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X", __func__,                               stat);  }  nativeNfcTag_releaseRfInterfaceMutexLock();   return stat; } static tNFA_STATUS stopPolling_rfDiscoveryDisabled() {  tNFA_STATUS stat = NFA_STATUS_FAILED;   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  LOG(DEBUG) << StringPrintf("%s: disable polling", __func__);  stat = NFA_DisablePolling();  if (stat == NFA_STATUS_OK) {    sPollingEnabled = false;    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_DISABLED_EVT  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               stat);  }  nativeNfcTag_releaseRfInterfaceMutexLock();   return stat; } static jboolean nfcManager_doSetPowerSavingMode(JNIEnv* e, jobject o,                                                bool flag) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter; ", __func__);  uint8_t cmd[] = {(NCI_MT_CMD << NCI_MT_SHIFT) | NCI_GID_PROP,                   NCI_MSG_PROP_ANDROID, NCI_ANDROID_POWER_SAVING_PARAM_SIZE,                   NCI_ANDROID_POWER_SAVING,                   NCI_ANDROID_POWER_SAVING_PARAM_DISABLE};  cmd[4] = flag ? NCI_ANDROID_POWER_SAVING_PARAM_ENABLE                : NCI_ANDROID_POWER_SAVING_PARAM_DISABLE;   SyncEventGuard guard(gNfaVsCommand);  tNFA_STATUS status =      NFA_SendRawVsCommand(sizeof(cmd), cmd, nfaSendRawVsCmdCallback);  if (status == NFA_STATUS_OK) {    gNfaVsCommand.wait();  } else {    LOG(ERROR) << StringPrintf("%s: Failed to set power-saving mode", __func__);    gVSCmdStatus = NFA_STATUS_FAILED;  }  return gVSCmdStatus == NFA_STATUS_OK; } static jbyteArray nfcManager_getProprietaryCaps(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return nullptr;  LOG(DEBUG) << StringPrintf("%s: enter; ", __func__);  uint8_t cmd[] = {(NCI_MT_CMD << NCI_MT_SHIFT) | NCI_GID_PROP,                   NCI_MSG_PROP_ANDROID, NCI_ANDROID_GET_CAPS_PARAM_SIZE,                   NCI_ANDROID_GET_CAPS};  SyncEventGuard guard(gNfaVsCommand);   tNFA_STATUS status = NFA_SendRawVsCommand(sizeof(cmd), cmd, nfaVSCallback);  if (status == NFA_STATUS_OK) {    if (!gNfaVsCommand.wait(1000)) {      LOG(ERROR) << StringPrintf(          "%s: Timed out waiting for a response to get caps ",          __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  } else {    LOG(ERROR) << StringPrintf("%s: Failed to get caps", __func__);    gVSCmdStatus = NFA_STATUS_FAILED;  }  CHECK(e);  jbyteArray rtJavaArray = e->NewByteArray(gCaps.size());  CHECK(rtJavaArray);  e->SetByteArrayRegion(rtJavaArray, 0, gCaps.size(), (jbyte*)gCaps.data());  return rtJavaArray; } static jboolean nfcManager_setFirmwareExitFrameTable(JNIEnv* env, jobject o,                                                     jobjectArray exit_frames,                                                     jbyteArray timeout) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << __func__ << ": Setting firmware exit frame table";  std::vector<uint8_t> command;  command.push_back(NCI_ANDROID_SET_PASSIVE_OBSERVER_EXIT_FRAME);   // TODO(b/380455428)  // Support more than 5 exit frames if firmware allows it. If we do so, might need to send second  // NCI command if one is too large.  uint8_t more = 0x00;  command.push_back(more);   uint8_t timeout_len = env->GetArrayLength(timeout);  auto* timeout_arr = (uint8_t*)env->GetByteArrayElements(timeout, nullptr);   for (int i = 0; i < timeout_len; ++i) {    command.push_back(timeout_arr[i]);  }  env->ReleaseByteArrayElements(timeout, (jbyte*)timeout_arr, JNI_ABORT);   uint8_t num_exit_frames = env->GetArrayLength(exit_frames);  if (num_exit_frames > 5) {      LOG(INFO)        << "Truncating exit frame table to 5 frames so it fits in a single NCI command. "        << "Original size was " << num_exit_frames;      num_exit_frames = 5;  }  command.push_back(num_exit_frames);   if (num_exit_frames > 0) {    jobject exit_frame = env->GetObjectArrayElement(exit_frames, 0);    jclass clazz = env->GetObjectClass(exit_frame);    jmethodID is_prefix_allowed =        env->GetMethodID(clazz, "isPrefixMatchingAllowed", "()Z");    jmethodID get_data = env->GetMethodID(clazz, "getData", "()[B");    jmethodID get_data_mask = env->GetMethodID(clazz, "getDataMask", "()[B");    jmethodID get_tech = env->GetMethodID(clazz, "getNfcTech", "()I");    jmethodID get_power_state = env->GetMethodID(clazz, "getPowerState", "()I");     for (int i = 0; i < num_exit_frames; ++i) {      jobject frame = env->GetObjectArrayElement(exit_frames, i);       uint8_t qualifier_type = 0x00;      if (env->CallBooleanMethod(frame, is_prefix_allowed)) {        qualifier_type |= 0b00010000;      }      qualifier_type |= env->CallIntMethod(frame, get_tech);      command.push_back(qualifier_type);       uint8_t power_state = env->CallIntMethod(frame, get_power_state);       jbyteArray data = (jbyteArray)env->CallObjectMethod(frame, get_data);      uint8_t data_len = env->GetArrayLength(data);      auto* data_arr = (uint8_t*)env->GetByteArrayElements(data, nullptr);       jbyteArray data_mask =          (jbyteArray)env->CallObjectMethod(frame, get_data_mask);      uint8_t data_mask_len = env->GetArrayLength(data_mask);      auto* data_mask_arr =          (uint8_t*)env->GetByteArrayElements(data_mask, nullptr);       uint8_t value_len = 1 + data_len + data_mask_len;       command.push_back(value_len);      command.push_back(power_state);       for (int j = 0; j < data_len; ++j) {        command.push_back(data_arr[j]);      }      for (int j = 0; j < data_mask_len; ++j) {        command.push_back(data_mask_arr[j]);      }      env->ReleaseByteArrayElements(data, (jbyte*)data_arr, JNI_ABORT);      env->ReleaseByteArrayElements(data_mask, (jbyte*)data_mask_arr,                                    JNI_ABORT);    }  }     bool reenableDiscovery = false;    if (sRfEnabled) {      startRfDiscovery(false);      reenableDiscovery = true;    }     // TODO make helper to send single command and wait on response    {        SyncEventGuard guard(gNfaVsCommand);        tNFA_STATUS status = NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, command.size(),                                               command.data(), nfaVSCallback);         if (status == NFA_STATUS_OK) {            if (!gNfaVsCommand.wait(1000)) {                LOG(ERROR) << StringPrintf(                        "%s: Timed out waiting for a response to set exit frame table ",                        __FUNCTION__);                gVSCmdStatus = NFA_STATUS_FAILED;            }        } else {            LOG(DEBUG) << StringPrintf("%s: Failed to set exit frame table",                                       __FUNCTION__);            gVSCmdStatus = NFA_STATUS_FAILED;        }    }     if (reenableDiscovery) {        startRfDiscovery(true);    }     return gVSCmdStatus == NFA_STATUS_OK; } /******************************************************************************* ** ** Function:        nfcManager_restartRfDiscovery ** Description:     Restarts RF discovery ** **                  e: JVM environment. **                  o: Java object. ** *******************************************************************************/ static void nfcManager_restartRfDiscovery(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  if (sRfEnabled) {    android::startRfDiscovery(false);  }  android::startRfDiscovery(true); } } /* namespace android */















/* * Copyright (C) 2012 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include <android-base/logging.h> #include <android-base/stringprintf.h> #include <cutils/properties.h> #include <errno.h> #include <nativehelper/JNIPlatformHelp.h> #include <nativehelper/ScopedLocalRef.h> #include <nativehelper/ScopedPrimitiveArray.h> #include <nativehelper/ScopedUtfChars.h> #include <semaphore.h> #include "HciEventManager.h" #include "JavaClassConstants.h" #include "NativeWlcManager.h" #include "NfcAdaptation.h" #ifdef DTA_ENABLED #include "NfcDta.h" #endif /* DTA_ENABLED */ #include "NativeT4tNfcee.h" #include "NfcJniUtil.h" #include "NfcTag.h" #include "NfceeManager.h" #include "RoutingManager.h" #include "SyncEvent.h" #include "android_nfc.h" #include "ce_api.h" #include "com_android_nfc_module_flags.h" #include "debug_lmrt.h" #include "nfa_api.h" #include "nfa_ee_api.h" #include "nfa_nfcee_int.h" #include "nfc_brcm_defs.h" #include "nfc_config.h" #include "rw_api.h" using android::base::StringPrintf; using com::android::nfc::module::flags::reader_mode_ignore_frame; extern tNFA_DM_DISC_FREQ_CFG* p_nfa_dm_rf_disc_freq_cfg;  // defined in stack namespace android { extern bool gIsTagDeactivating; extern bool gIsSelectingRfInterface; extern bool gTagJustActivated; extern void nativeNfcTag_doTransceiveStatus(tNFA_STATUS status, uint8_t* buf,                                            uint32_t buflen); extern void nativeNfcTag_notifyRfTimeout(); extern void nativeNfcTag_doConnectStatus(jboolean is_connect_ok); extern void nativeNfcTag_doDeactivateStatus(int status); extern void nativeNfcTag_doWriteStatus(jboolean is_write_ok); extern jboolean nativeNfcTag_doDisconnect(JNIEnv*, jobject); extern void nativeNfcTag_doCheckNdefResult(tNFA_STATUS status,                                           uint32_t max_size,                                           uint32_t current_size,                                           uint8_t flags); extern void nativeNfcTag_doMakeReadonlyResult(tNFA_STATUS status); extern void nativeNfcTag_doPresenceCheckResult(tNFA_STATUS status); extern void nativeNfcTag_formatStatus(bool is_ok); extern void nativeNfcTag_resetPresenceCheck(); extern void nativeNfcTag_doReadCompleted(tNFA_STATUS status); extern void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface); extern void nativeNfcTag_setActivatedRfProtocol(tNFA_INTF_TYPE rfProtocol); extern void nativeNfcTag_setActivatedRfMode(uint8_t rfMode); extern void nativeNfcTag_abortWaits(); extern void nativeNfcTag_registerNdefTypeHandler(); extern void nativeNfcTag_acquireRfInterfaceMutexLock(); extern void nativeNfcTag_releaseRfInterfaceMutexLock(); extern void updateNfcID0Param(uint8_t* nfcID0); }  // namespace android /***************************************************************************** ** ** public variables and functions ** *****************************************************************************/ bool gActivated = false; SyncEvent gDeactivatedEvent; SyncEvent sNfaSetPowerSubState; int recovery_option = 0; int always_on_nfcee_power_and_link_conf = 0; int disable_always_on_nfcee_power_and_link_conf = 0; namespace android { jmethodID gCachedNfcManagerNotifyNdefMessageListeners; jmethodID gCachedNfcManagerNotifyTransactionListeners; jmethodID gCachedNfcManagerNotifyHostEmuActivated; jmethodID gCachedNfcManagerNotifyHostEmuData; jmethodID gCachedNfcManagerNotifyHostEmuDeactivated; jmethodID gCachedNfcManagerNotifyRfFieldActivated; jmethodID gCachedNfcManagerNotifyRfFieldDeactivated; jmethodID gCachedNfcManagerNotifyEeUpdated; jmethodID gCachedNfcManagerNotifyTagDiscovered; jmethodID gCachedNfcManagerNotifyHwErrorReported; jmethodID gCachedNfcManagerNotifyPollingLoopFrame; jmethodID gCachedNfcManagerNotifyWlcStopped; jmethodID gCachedNfcManagerNotifyVendorSpecificEvent; jmethodID gCachedNfcManagerNotifyCommandTimeout; jmethodID gCachedNfcManagerNotifyObserveModeChanged; jmethodID gCachedNfcManagerNotifyRfDiscoveryEvent; jmethodID gCachedNfcManagerNotifyEeAidSelected; jmethodID gCachedNfcManagerNotifyEeProtocolSelected; jmethodID gCachedNfcManagerNotifyEeTechSelected; jmethodID gCachedNfcManagerNotifyEeListenActivated; jmethodID gCachedNfcManagerOnRestartRfDiscovery; jmethodID gCachedNfcManagerOnObserveModeDisabledInFirmware; jmethodID gCachedNfcManagerOnObserveModeEnabledInFirmware; jmethodID gCachedNfcManagerNotifyEndpointRemoved; const char* gNativeNfcTagClassName = "com/android/nfc/dhimpl/NativeNfcTag"; const char* gNativeNfcManagerClassName =    "com/android/nfc/dhimpl/NativeNfcManager"; const char* gNfcVendorNciResponseClassName =    "com/android/nfc/NfcVendorNciResponse"; const char* gNativeT4tNfceeClassName =    "com/android/nfc/dhimpl/NativeT4tNfceeManager"; void doStartupConfig(); void startStopPolling(bool isStartPolling); void startRfDiscovery(bool isStart); bool isDiscoveryStarted(); }  // namespace android /***************************************************************************** ** ** private variables and functions ** *****************************************************************************/ namespace android { static SyncEvent sNfaEnableEvent;                // event for NFA_Enable() static SyncEvent sNfaDisableEvent;               // event for NFA_Disable() static SyncEvent sNfaEnableDisablePollingEvent;  // event for                                                 // NFA_EnablePolling(),                                                 // NFA_DisablePolling() SyncEvent gNfaSetConfigEvent;                    // event for Set_Config.... SyncEvent gNfaGetConfigEvent;                    // event for Get_Config.... SyncEvent gNfaVsCommand;                         // event for VS commands SyncEvent gSendRawVsCmdEvent;  // event for NFA_SendRawVsCommand() SyncEvent gNfaRemoveEpEvent;   // event for StartRemoval.... static bool sIsEpDetectStarted = false; static bool sIsNfaEnabled = false; static bool sDiscoveryEnabled = false;  // is polling or listening static bool sPollingEnabled = false;    // is polling for tag? bool sIsDisabling = false; static bool sRfEnabled = false;   // whether RF discovery is enabled static bool sSeRfActive = false;  // whether RF with SE is likely active static bool sReaderModeEnabled = false;  // whether we're only reading tags, not allowing card emu static bool sAbortConnlessWait = false; static jint sLfT3tMax = 0; static bool sRoutingInitialized = false; static bool sIsRecovering = false; static bool sIsAlwaysPolling = false; static std::vector<uint8_t> sRawVendorCmdResponse; static bool sEnableVendorNciNotifications = false; static bool sIsShuttingDown = false; #define CONFIG_UPDATE_TECH_MASK (1 << 1) #define DEFAULT_TECH_MASK                                                  \  (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B | NFA_TECHNOLOGY_MASK_F | \   NFA_TECHNOLOGY_MASK_V | NFA_TECHNOLOGY_MASK_B_PRIME |                   \   NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE |           \   NFA_TECHNOLOGY_MASK_KOVIO) #define DEFAULT_DISCOVERY_DURATION 500 #define READER_MODE_DISCOVERY_DURATION 200 #define FLAG_SET_DEFAULT_TECH 0x40000000 static void nfaConnectionCallback(uint8_t event, tNFA_CONN_EVT_DATA* eventData); static void nfaDeviceManagementCallback(uint8_t event,                                        tNFA_DM_CBACK_DATA* eventData); static bool isListenMode(tNFA_ACTIVATED& activated); static tNFA_STATUS stopPolling_rfDiscoveryDisabled(); static tNFA_STATUS startPolling_rfDiscoveryDisabled(    tNFA_TECHNOLOGY_MASK tech_mask); static void nfcManager_doSetScreenState(JNIEnv* e, jobject o,                                        jint screen_state_mask,                                        jboolean alwaysPoll); static jboolean nfcManager_doSetPowerSavingMode(JNIEnv* e, jobject o,                                                bool flag); static void sendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                 uint8_t* p_param); static jbyteArray nfcManager_getProprietaryCaps(JNIEnv* e, jobject o); static jboolean nfcManager_setFirmwareExitFrameTable(JNIEnv* env, jobject o,                                                     jobjectArray exit_frames,                                                     jbyteArray timeout_ms); static void nfcManager_restartRfDiscovery(JNIEnv* e, jobject o); tNFA_STATUS gVSCmdStatus = NFA_STATUS_OK; uint16_t gCurrentConfigLen; uint8_t gConfig[256]; std::vector<uint8_t> gCaps(0); static int prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED; static int NFA_SCREEN_POLLING_TAG_MASK = 0x10; bool gIsDtaEnabled = false; static bool gObserveModeEnabled = false; static int gPartialInitMode = ENABLE_MODE_DEFAULT; ///////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////// namespace { void initializeGlobalDebugEnabledFlag() {  bool nfc_debug_enabled =      (NfcConfig::getUnsigned(NAME_NFC_DEBUG_ENABLED, 1) != 0) ||      property_get_bool("persist.nfc.debug_enabled", true);   android::base::SetMinimumLogSeverity(nfc_debug_enabled ? android::base::DEBUG                                                         : android::base::INFO); } void initializeRecoveryOption() {  recovery_option = NfcConfig::getUnsigned(NAME_RECOVERY_OPTION, 0);   LOG(DEBUG) << __func__ << ": recovery option=" << recovery_option; } void initializeNfceePowerAndLinkConf() {  always_on_nfcee_power_and_link_conf =      NfcConfig::getUnsigned(NAME_ALWAYS_ON_SET_EE_POWER_AND_LINK_CONF, 0);   LOG(DEBUG) << __func__ << ": Always on set NFCEE_POWER_AND_LINK_CONF="             << always_on_nfcee_power_and_link_conf; } void initializeDisableAlwaysOnNfceePowerAndLinkConf() {  disable_always_on_nfcee_power_and_link_conf = NfcConfig::getUnsigned(      NAME_DISABLE_ALWAYS_ON_SET_EE_POWER_AND_LINK_CONF, 0);   LOG(DEBUG) << __func__ << ": Always on set NFCEE_POWER_AND_LINK_CONF="             << disable_always_on_nfcee_power_and_link_conf; } }  // namespace /******************************************************************************* ** ** Function:        getNative ** ** Description:     Get native data ** ** Returns:         Native data structure. ** *******************************************************************************/ nfc_jni_native_data* getNative(JNIEnv* e, jobject o) {  static struct nfc_jni_native_data* sCachedNat = NULL;  if (e) {    sCachedNat = nfc_jni_get_nat(e, o);  }  return sCachedNat; } /******************************************************************************* ** ** Function:        handleRfDiscoveryEvent ** ** Description:     Handle RF-discovery events from the stack. **                  discoveredDevice: Discovered device. ** ** Returns:         None ** *******************************************************************************/ static void handleRfDiscoveryEvent(tNFC_RESULT_DEVT* discoveredDevice) {  NfcTag& natTag = NfcTag::getInstance();   LOG(DEBUG) << StringPrintf("%s: ", __func__);   if (gIsSelectingRfInterface && !natTag.getMultiProtocolTagSupport()) {    if (discoveredDevice->more == NCI_DISCOVER_NTF_MORE) return;    LOG(WARNING) << StringPrintf(        "%s: reselecting, mismatch in nb of detected interfaces, "        "restarting discovery",        __func__);    nativeNfcTag_doConnectStatus(false);    natTag.setReselect(false);    NFA_Deactivate(FALSE);  }  if (discoveredDevice->protocol != NFA_PROTOCOL_NFC_DEP) {    natTag.setNumDiscNtf(natTag.getNumDiscNtf() + 1);  }  if (discoveredDevice->more == NCI_DISCOVER_NTF_MORE) {    // there is more discovery notification coming    return;  }   if (natTag.getNumDiscNtf() > 1) {    natTag.setMultiProtocolTagSupport(true);  }   natTag.setNumDiscNtf(natTag.getNumDiscNtf() - 1);  // select the first of multiple tags that is discovered  natTag.selectFirstTag(); } /******************************************************************************* ** ** Function:        nfaConnectionCallback ** ** Description:     Receive connection-related events from stack. **                  connEvent: Event code. **                  eventData: Event data. ** ** Returns:         None ** *******************************************************************************/ static void nfaConnectionCallback(uint8_t connEvent,                                  tNFA_CONN_EVT_DATA* eventData) {  tNFA_STATUS status = NFA_STATUS_FAILED;   switch (connEvent) {    case NFA_LISTEN_ENABLED_EVT:  // whether listening successfully started    {      LOG(DEBUG) << StringPrintf("%s: NFA_LISTEN_ENABLED_EVT:status= %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_POLL_ENABLED_EVT:  // whether polling successfully started    {      LOG(DEBUG) << StringPrintf("%s: NFA_POLL_ENABLED_EVT: status = %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_POLL_DISABLED_EVT:  // Listening/Polling stopped    {      LOG(DEBUG) << StringPrintf("%s: NFA_POLL_DISABLED_EVT: status = %u",                                 __func__, eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();    } break;     case NFA_RF_DISCOVERY_STARTED_EVT:  // RF Discovery started    {      LOG(DEBUG) << StringPrintf(          "%s: NFA_RF_DISCOVERY_STARTED_EVT: status = %u", __func__,          eventData->status);       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();      struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (!nat) {        LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);        return;      }      JNIEnv* e = NULL;      ScopedAttach attach(nat->vm, &e);      if (e == NULL) {        LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);        return;      }      e->CallVoidMethod(nat->manager,                        android::gCachedNfcManagerNotifyRfDiscoveryEvent,                        JNI_TRUE);    } break;     case NFA_RF_DISCOVERY_STOPPED_EVT:  // RF Discovery stopped event    {      LOG(DEBUG) << StringPrintf(          "%s: NFA_RF_DISCOVERY_STOPPED_EVT: status = %u", __func__,          eventData->status);       gActivated = false;       SyncEventGuard guard(sNfaEnableDisablePollingEvent);      sNfaEnableDisablePollingEvent.notifyOne();      struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (!nat) {        LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);        return;      }      JNIEnv* e = NULL;      ScopedAttach attach(nat->vm, &e);      if (e == NULL) {        LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);        return;      }      e->CallVoidMethod(nat->manager,                        android::gCachedNfcManagerNotifyRfDiscoveryEvent,                        JNI_FALSE);    } break;     case NFA_DISC_RESULT_EVT:  // NFC link/protocol discovery notificaiton      status = eventData->disc_result.status;      LOG(DEBUG) << StringPrintf("%s: NFA_DISC_RESULT_EVT: status = %d",                                 __func__, status);      if (status != NFA_STATUS_OK) {        NfcTag::getInstance().setNumDiscNtf(0);        LOG(ERROR) << StringPrintf("%s: NFA_DISC_RESULT_EVT error: status = %d",                                   __func__, status);      } else {        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        handleRfDiscoveryEvent(&eventData->disc_result.discovery_ntf);      }      break;     case NFA_SELECT_RESULT_EVT:  // NFC link/protocol discovery select response      LOG(DEBUG) << StringPrintf(          "%s: NFA_SELECT_RESULT_EVT: status = %d, gIsSelectingRfInterface = "          "%d, "          "sIsDisabling=%d",          __func__, eventData->status, gIsSelectingRfInterface, sIsDisabling);       if (sIsDisabling) break;       if (eventData->status != NFA_STATUS_OK) {        if (gIsSelectingRfInterface) {          nativeNfcTag_doConnectStatus(false);        }         LOG(ERROR) << StringPrintf(            "%s: NFA_SELECT_RESULT_EVT error: status = %d", __func__,            eventData->status);        if (NfcTag::getInstance().retrySelect() == NFA_STATUS_OK) {          break;        }        NFA_Deactivate(FALSE);      }      break;     case NFA_DEACTIVATE_FAIL_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_DEACTIVATE_FAIL_EVT: status = %d",                                 __func__, eventData->status);      break;     case NFA_ACTIVATED_EVT:  // NFC link/protocol activated    {      bool notListen = !isListenMode(eventData->activated);      LOG(DEBUG) << StringPrintf(          "%s: NFA_ACTIVATED_EVT: gIsSelectingRfInterface=%d, sIsDisabling=%d",          __func__, gIsSelectingRfInterface, sIsDisabling);      uint8_t activatedProtocol =          (tNFA_INTF_TYPE)eventData->activated.activate_ntf.protocol;      uint8_t activatedMode =          eventData->activated.activate_ntf.rf_tech_param.mode;      gTagJustActivated = true;      if (NFC_PROTOCOL_T5T == activatedProtocol &&          NfcTag::getInstance().getNumDiscNtf()) {        /* T5T doesn't support multiproto detection logic */        NfcTag::getInstance().setNumDiscNtf(0);      }      NfcTag::getInstance().clearSelectRetryCount();      if ((eventData->activated.activate_ntf.protocol !=           NFA_PROTOCOL_NFC_DEP) &&          (!isListenMode(eventData->activated))) {        nativeNfcTag_setRfInterface(            (tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param.type);        nativeNfcTag_setActivatedRfProtocol(activatedProtocol);        nativeNfcTag_setActivatedRfMode(activatedMode);      }      NfcTag::getInstance().setActive(notListen);      if (sIsDisabling || !sIsNfaEnabled) break;      gActivated = true;       if (notListen) {        updateNfcID0Param(            eventData->activated.activate_ntf.rf_tech_param.param.pb.nfcid0);        NfcTag::getInstance().setActivationState();        if (gIsSelectingRfInterface) {          nativeNfcTag_doConnectStatus(true);          break;        }         nativeNfcTag_resetPresenceCheck();        if (!isListenMode(eventData->activated) &&            (prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||             prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED)) {          if (!sIsAlwaysPolling) {            NFA_Deactivate(FALSE);          }        }         NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        if (NfcTag::getInstance().getNumDiscNtf()) {          /*If its multiprotocol tag, deactivate tag with current selected          protocol to sleep . Select tag with next supported protocol after          deactivation event is received*/          if (((tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param                   .type == NFA_INTERFACE_FRAME)) {            uint8_t RW_TAG_SLP_REQ[] = {0x50, 0x00};            SyncEvent waitSome;            SyncEventGuard g(waitSome);            NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);            waitSome.wait(4);          }          NFA_Deactivate(true);        }       } else {        // If it activated in        // listen mode then it is likely for an SE transaction.        // Send the RF Event.        sSeRfActive = true;        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << __func__ << ": jni env is null";          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyEeListenActivated,                          JNI_TRUE);      }    } break;    case NFA_DEACTIVATED_EVT:  // NFC link/protocol deactivated      LOG(DEBUG) << StringPrintf(          "%s: NFA_DEACTIVATED_EVT   Type=%u, gIsTagDeactivating=%d", __func__,          eventData->deactivated.type, gIsTagDeactivating);      NfcTag::getInstance().setDeactivationState(eventData->deactivated);       if (eventData->deactivated.type != NFA_DEACTIVATE_TYPE_SLEEP) {        {          SyncEventGuard g(gDeactivatedEvent);          gActivated = false;  // guard this variable from multi-threaded access          gDeactivatedEvent.notifyOne();        }        nativeNfcTag_resetPresenceCheck();        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);        nativeNfcTag_abortWaits();        NfcTag::getInstance().abort();      } else if (gIsTagDeactivating) {        NfcTag::getInstance().setActive(false);        nativeNfcTag_doDeactivateStatus(0);      } else if (!sIsDisabling) {        NfcTag::getInstance().selectNextTagIfExists();      }       // If RF is activated for what we think is a Secure Element transaction      // and it is deactivated to either IDLE or DISCOVERY mode, notify w/event.      if ((eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE) ||          (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_DISCOVERY)) {        if (sSeRfActive) {          sSeRfActive = false;          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {            LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);            return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {            LOG(ERROR) << __func__ << ": jni env is null";            return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyEeListenActivated,                            JNI_FALSE);        }      }       break;     case NFA_DETECT_REMOVAL_STARTED_EVT: {  // whether EP Removal Detection                                            // successfully started      LOG(DEBUG) << StringPrintf(          "%s:  NFA_DETECT_REMOVAL_STARTED_EVT: status = %d", __func__, status);       sIsEpDetectStarted = eventData->status == NFA_STATUS_OK;      SyncEventGuard guard(gNfaRemoveEpEvent);      gNfaRemoveEpEvent.notifyOne();    } break;     case NFA_DETECT_REMOVAL_RESULT_EVT: {  // Removal Detection complete      LOG(DEBUG) << StringPrintf(          "%s:  NFA_DETECT_REMOVAL_RESULT_EVT: status = %d, reason = %d",          __func__, status, eventData->removal_detect.reason);       /* Return REMOVAL_DETECTION deactivation reason to service */      {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s:  jni env is null", __func__);          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyEndpointRemoved,                          (int)eventData->removal_detect.reason);        if (e->ExceptionCheck()) {          e->ExceptionClear();          LOG(ERROR) << StringPrintf("%s: fail notify", __func__);        }      }    } break;     case NFA_TLV_DETECT_EVT:  // TLV Detection complete      status = eventData->tlv_detect.status;      LOG(DEBUG) << StringPrintf(          "%s: NFA_TLV_DETECT_EVT: status = %d, protocol = %d, num_tlvs = %d, "          "num_bytes = %d",          __func__, status, eventData->tlv_detect.protocol,          eventData->tlv_detect.num_tlvs, eventData->tlv_detect.num_bytes);      if (status != NFA_STATUS_OK) {        LOG(ERROR) << StringPrintf("%s: NFA_TLV_DETECT_EVT error: status = %d",                                   __func__, status);      }      break;     case NFA_NDEF_DETECT_EVT:  // NDEF Detection complete;      // if status is failure, it means the tag does not contain any or valid      // NDEF data;  pass the failure status to the NFC Service;      status = eventData->ndef_detect.status;      LOG(DEBUG) << StringPrintf(          "%s: NFA_NDEF_DETECT_EVT: status = 0x%X, protocol = %u, "          "max_size = %u, cur_size = %u, flags = 0x%X",          __func__, status, eventData->ndef_detect.protocol,          eventData->ndef_detect.max_size, eventData->ndef_detect.cur_size,          eventData->ndef_detect.flags);      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);      nativeNfcTag_doCheckNdefResult(status, eventData->ndef_detect.max_size,                                     eventData->ndef_detect.cur_size,                                     eventData->ndef_detect.flags);      break;     case NFA_DATA_EVT:  // Data message received (for non-NDEF reads)      LOG(DEBUG) << StringPrintf("%s: NFA_DATA_EVT: status = 0x%X, len = %d",                                 __func__, eventData->status,                                 eventData->data.len);      nativeNfcTag_doTransceiveStatus(eventData->status, eventData->data.p_data,                                      eventData->data.len);      break;    case NFA_RW_INTF_ERROR_EVT:      LOG(DEBUG) << StringPrintf("%s: NFC_RW_INTF_ERROR_EVT", __func__);      nativeNfcTag_notifyRfTimeout();      nativeNfcTag_doReadCompleted(NFA_STATUS_TIMEOUT);      break;    case NFA_SELECT_CPLT_EVT:  // Select completed      status = eventData->status;      LOG(DEBUG) << StringPrintf("%s: NFA_SELECT_CPLT_EVT: status = %d",                                 __func__, status);      if (status != NFA_STATUS_OK) {        LOG(ERROR) << StringPrintf("%s: NFA_SELECT_CPLT_EVT error: status = %d",                                   __func__, status);      }      break;     case NFA_READ_CPLT_EVT:  // NDEF-read or tag-specific-read completed      LOG(DEBUG) << StringPrintf("%s: NFA_READ_CPLT_EVT: status = 0x%X",                                 __func__, eventData->status);      nativeNfcTag_doReadCompleted(eventData->status);      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);      break;     case NFA_WRITE_CPLT_EVT:  // Write completed      LOG(DEBUG) << StringPrintf("%s: NFA_WRITE_CPLT_EVT: status = %d",                                 __func__, eventData->status);      nativeNfcTag_doWriteStatus(eventData->status == NFA_STATUS_OK);      break;     case NFA_SET_TAG_RO_EVT:  // Tag set as Read only      LOG(DEBUG) << StringPrintf("%s: NFA_SET_TAG_RO_EVT: status = %d",                                 __func__, eventData->status);      nativeNfcTag_doMakeReadonlyResult(eventData->status);      break;     case NFA_CE_NDEF_WRITE_START_EVT:  // NDEF write started      LOG(DEBUG) << StringPrintf("%s: NFA_CE_NDEF_WRITE_START_EVT: status=%d",                                 __func__, eventData->status);       if (eventData->status != NFA_STATUS_OK)        LOG(ERROR) << StringPrintf(            "%s: NFA_CE_NDEF_WRITE_START_EVT error: status = %d", __func__,            eventData->status);      break;     case NFA_CE_NDEF_WRITE_CPLT_EVT:  // NDEF write completed      LOG(DEBUG) << StringPrintf("%s: FA_CE_NDEF_WRITE_CPLT_EVT: len = %u",                                 __func__, eventData->ndef_write_cplt.len);      break;     case NFA_PRESENCE_CHECK_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_PRESENCE_CHECK_EVT", __func__);      nativeNfcTag_doPresenceCheckResult(eventData->status);      break;    case NFA_FORMAT_CPLT_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_FORMAT_CPLT_EVT: status=0x%X",                                 __func__, eventData->status);      nativeNfcTag_formatStatus(eventData->status == NFA_STATUS_OK);      break;     case NFA_I93_CMD_CPLT_EVT:      LOG(DEBUG) << StringPrintf("%s: NFA_I93_CMD_CPLT_EVT: status=0x%X",                                 __func__, eventData->status);      break;     case NFA_CE_UICC_LISTEN_CONFIGURED_EVT:      LOG(DEBUG) << StringPrintf(          "%s: NFA_CE_UICC_LISTEN_CONFIGURED_EVT : status=0x%X", __func__,          eventData->status);      break;    case NFA_T4TNFCEE_EVT:    case NFA_T4TNFCEE_READ_CPLT_EVT:    case NFA_T4TNFCEE_WRITE_CPLT_EVT:    case NFA_T4TNFCEE_CLEAR_CPLT_EVT:    case NFA_T4TNFCEE_READ_CC_DATA_CPLT_EVT:      NativeT4tNfcee::getInstance().eventHandler(connEvent, eventData);      break;     default:      LOG(DEBUG) << StringPrintf("%s: unknown event (%d) ????", __func__,                                 connEvent);      break;  } } /******************************************************************************* ** ** Function:        nfcManager_initNativeStruc ** ** Description:     Initialize variables. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_initNativeStruc(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  initializeGlobalDebugEnabledFlag();  initializeRecoveryOption();  initializeNfceePowerAndLinkConf();  initializeDisableAlwaysOnNfceePowerAndLinkConf();  LOG(DEBUG) << StringPrintf("%s: enter", __func__);   nfc_jni_native_data* nat =      (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));  if (nat == NULL) {    LOG(ERROR) << StringPrintf("%s: fail allocate native data", __func__);    return JNI_FALSE;  }   memset(nat, 0, sizeof(*nat));  e->GetJavaVM(&(nat->vm));  nat->env_version = e->GetVersion();  nat->manager = e->NewGlobalRef(o);   ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jfieldID f = e->GetFieldID(cls.get(), "mNative", "J");  e->SetLongField(o, f, (jlong)nat);   /* Initialize native cached references */  gCachedNfcManagerNotifyNdefMessageListeners =      e->GetMethodID(cls.get(), "notifyNdefMessageListeners",                     "(Lcom/android/nfc/dhimpl/NativeNfcTag;)V");   gCachedNfcManagerNotifyHostEmuActivated =      e->GetMethodID(cls.get(), "notifyHostEmuActivated", "(I)V");   gCachedNfcManagerNotifyHostEmuData =      e->GetMethodID(cls.get(), "notifyHostEmuData", "(I[B)V");   gCachedNfcManagerNotifyHostEmuDeactivated =      e->GetMethodID(cls.get(), "notifyHostEmuDeactivated", "(I)V");   gCachedNfcManagerNotifyRfFieldActivated =      e->GetMethodID(cls.get(), "notifyRfFieldActivated", "()V");  gCachedNfcManagerNotifyRfFieldDeactivated =      e->GetMethodID(cls.get(), "notifyRfFieldDeactivated", "()V");   gCachedNfcManagerNotifyTransactionListeners = e->GetMethodID(      cls.get(), "notifyTransactionListeners", "([B[BLjava/lang/String;)V");   gCachedNfcManagerNotifyEeUpdated =      e->GetMethodID(cls.get(), "notifyEeUpdated", "()V");   gCachedNfcManagerNotifyHwErrorReported =      e->GetMethodID(cls.get(), "notifyHwErrorReported", "()V");   gCachedNfcManagerNotifyPollingLoopFrame =      e->GetMethodID(cls.get(), "notifyPollingLoopFrame", "(I[B)V");   gCachedNfcManagerNotifyVendorSpecificEvent =      e->GetMethodID(cls.get(), "notifyVendorSpecificEvent", "(II[B)V");   gCachedNfcManagerNotifyWlcStopped =      e->GetMethodID(cls.get(), "notifyWlcStopped", "(I)V");   gCachedNfcManagerNotifyTagDiscovered =      e->GetMethodID(cls.get(), "notifyTagDiscovered", "(Z)V");   gCachedNfcManagerNotifyCommandTimeout =      e->GetMethodID(cls.get(), "notifyCommandTimeout", "()V");   gCachedNfcManagerNotifyObserveModeChanged =      e->GetMethodID(cls.get(), "notifyObserveModeChanged", "(Z)V");   gCachedNfcManagerNotifyRfDiscoveryEvent =      e->GetMethodID(cls.get(), "notifyRFDiscoveryEvent", "(Z)V");   gCachedNfcManagerNotifyEeListenActivated =      e->GetMethodID(cls.get(), "notifyEeListenActivated", "(Z)V");   gCachedNfcManagerNotifyEeAidSelected = e->GetMethodID(      cls.get(), "notifyEeAidSelected", "([BLjava/lang/String;)V");   gCachedNfcManagerNotifyEeProtocolSelected = e->GetMethodID(      cls.get(), "notifyEeProtocolSelected", "(ILjava/lang/String;)V");   gCachedNfcManagerNotifyEeTechSelected = e->GetMethodID(      cls.get(), "notifyEeTechSelected", "(ILjava/lang/String;)V");   gCachedNfcManagerNotifyEndpointRemoved =      e->GetMethodID(cls.get(), "notifyEndpointRemoved", "(I)V");   gCachedNfcManagerOnRestartRfDiscovery =      e->GetMethodID(cls.get(), "onRestartRfDiscovery", "()V");   gCachedNfcManagerOnObserveModeDisabledInFirmware =      e->GetMethodID(cls.get(), "onObserveModeDisabledInFirmware", "(I[B)V");   gCachedNfcManagerOnObserveModeEnabledInFirmware =      e->GetMethodID(cls.get(), "onObserveModeEnabledInFirmware", "()V");   if (nfc_jni_cache_object(e, gNativeNfcTagClassName, &(nat->cached_NfcTag)) ==      -1) {    LOG(ERROR) << StringPrintf("%s: fail cache NativeNfcTag", __func__);    return JNI_FALSE;  }   // Cache the reference to the manager  (void)getNative(e,o);   LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        nfaDeviceManagementCallback ** ** Description:     Receive device management events from stack. **                  dmEvent: Device-management event ID. **                  eventData: Data associated with event ID. ** ** Returns:         None ** *******************************************************************************/ void nfaDeviceManagementCallback(uint8_t dmEvent,                                 tNFA_DM_CBACK_DATA* eventData) {  LOG(DEBUG) << StringPrintf("%s: enter; event=0x%X", __func__, dmEvent);   switch (dmEvent) {    case NFA_DM_ENABLE_EVT: /* Result of NFA_Enable */    {      SyncEventGuard guard(sNfaEnableEvent);      LOG(DEBUG) << StringPrintf("%s: NFA_DM_ENABLE_EVT; status=0x%X", __func__,                                 eventData->status);      sIsNfaEnabled = eventData->status == NFA_STATUS_OK;      sIsDisabling = false;      sNfaEnableEvent.notifyOne();    } break;     case NFA_DM_DISABLE_EVT: /* Result of NFA_Disable */    {      SyncEventGuard guard(sNfaDisableEvent);      LOG(DEBUG) << StringPrintf("%s: NFA_DM_DISABLE_EVT", __func__);      sIsNfaEnabled = false;      sIsDisabling = false;      sNfaDisableEvent.notifyOne();    } break;     case NFA_DM_SET_CONFIG_EVT:  // result of NFA_SetConfig      LOG(DEBUG) << StringPrintf("%s: NFA_DM_SET_CONFIG_EVT", __func__);      {        SyncEventGuard guard(gNfaSetConfigEvent);        gNfaSetConfigEvent.notifyOne();      }      break;     case NFA_DM_GET_CONFIG_EVT: /* Result of NFA_GetConfig */      LOG(DEBUG) << StringPrintf("%s: NFA_DM_GET_CONFIG_EVT", __func__);      {        SyncEventGuard guard(gNfaGetConfigEvent);        if (eventData->status == NFA_STATUS_OK &&            eventData->get_config.tlv_size <= sizeof(gConfig)) {          gCurrentConfigLen = eventData->get_config.tlv_size;          memcpy(gConfig, eventData->get_config.param_tlvs,                 eventData->get_config.tlv_size);        } else {          LOG(ERROR) << StringPrintf("%s: NFA_DM_GET_CONFIG failed", __func__);          gCurrentConfigLen = 0;        }        gNfaGetConfigEvent.notifyOne();      }      break;     case NFA_DM_RF_FIELD_EVT:      LOG(DEBUG) << StringPrintf(          "%s: NFA_DM_RF_FIELD_EVT; status=0x%X; field status=%u", __func__,          eventData->rf_field.status, eventData->rf_field.rf_field_status);      if (eventData->rf_field.status == NFA_STATUS_OK) {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);          return;        }        if (eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON)          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyRfFieldActivated);        else          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyRfFieldDeactivated);      }      break;     case NFA_DM_NFCC_TRANSPORT_ERR_EVT:    case NFA_DM_NFCC_TIMEOUT_EVT: {      if (dmEvent == NFA_DM_NFCC_TIMEOUT_EVT)        LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TIMEOUT_EVT; abort",                                   __func__);      else if (dmEvent == NFA_DM_NFCC_TRANSPORT_ERR_EVT)        LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TRANSPORT_ERR_EVT; abort",                                   __func__);       struct nfc_jni_native_data* nat = getNative(NULL, NULL);      if (recovery_option && nat != NULL) {        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);          return;        }        LOG(ERROR) << StringPrintf("%s: toggle NFC state to recovery nfc",                                   __func__);        sIsRecovering = true;        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyHwErrorReported);        {          LOG(DEBUG) << StringPrintf(              "%s: aborting  sNfaEnableDisablePollingEvent", __func__);          SyncEventGuard guard(sNfaEnableDisablePollingEvent);          sNfaEnableDisablePollingEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaEnableEvent", __func__);          SyncEventGuard guard(sNfaEnableEvent);          sNfaEnableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaDisableEvent",                                     __func__);          SyncEventGuard guard(sNfaDisableEvent);          sNfaDisableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaSetPowerSubState",                                     __func__);          SyncEventGuard guard(sNfaSetPowerSubState);          sNfaSetPowerSubState.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting gNfaSetConfigEvent",                                     __func__);          SyncEventGuard guard(gNfaSetConfigEvent);          gNfaSetConfigEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting gNfaGetConfigEvent",                                     __func__);          SyncEventGuard guard(gNfaGetConfigEvent);          gNfaGetConfigEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf(              "%s: aborting RoutingManager::getInstance().mEeUpdateEvent",              __func__);          SyncEventGuard guard(RoutingManager::getInstance().mEeUpdateEvent);          RoutingManager::getInstance().mEeUpdateEvent.notifyOne();        }      } else {        nativeNfcTag_abortWaits();        NfcTag::getInstance().abort();        sAbortConnlessWait = true;        {          LOG(DEBUG) << StringPrintf(              "%s: aborting  sNfaEnableDisablePollingEvent", __func__);          SyncEventGuard guard(sNfaEnableDisablePollingEvent);          sNfaEnableDisablePollingEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaEnableEvent", __func__);          SyncEventGuard guard(sNfaEnableEvent);          sNfaEnableEvent.notifyOne();        }        {          LOG(DEBUG) << StringPrintf("%s: aborting  sNfaDisableEvent",                                     __func__);          SyncEventGuard guard(sNfaDisableEvent);          sNfaDisableEvent.notifyOne();        }        sDiscoveryEnabled = false;        sPollingEnabled = false;         if (!sIsDisabling && sIsNfaEnabled) {          if (gIsDtaEnabled == true) {            LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                       __func__);            NFA_DisableDtamode();          }           NFA_Disable(FALSE);          sIsDisabling = true;        } else {          sIsNfaEnabled = false;          sIsDisabling = false;        }        LOG(ERROR) << StringPrintf("%s: crash NFC service", __func__);        if (nat != NULL) {          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e != NULL) {            e->CallVoidMethod(nat->manager,                              android::gCachedNfcManagerNotifyCommandTimeout);          }        }        //////////////////////////////////////////////        // crash the NFC service process so it can restart automatically        abort();        //////////////////////////////////////////////      }    } break;     case NFA_DM_SET_POWER_SUB_STATE_EVT: {      LOG(DEBUG) << StringPrintf(          "%s: NFA_DM_SET_POWER_SUB_STATE_EVT; status=0x%X", __FUNCTION__,          eventData->power_sub_state.status);      SyncEventGuard guard(sNfaSetPowerSubState);      sNfaSetPowerSubState.notifyOne();    } break;    default:      LOG(DEBUG) << StringPrintf("%s: unhandled event", __func__);      break;  } } /******************************************************************************* ** ** Function:        nfcManager_sendRawFrame ** ** Description:     Send a raw frame. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_sendRawFrame(JNIEnv* e, jobject, jbyteArray data) {  if (sIsShuttingDown) return false;  ScopedByteArrayRO bytes(e, data);  uint8_t* buf =      const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  size_t bufLen = bytes.size();  tNFA_STATUS status = NFA_SendRawFrame(buf, bufLen, 0);   return (status == NFA_STATUS_OK); } /******************************************************************************* ** ** Function:        nfcManager_routeAid ** ** Description:     Route an AID to an EE **                  e: JVM environment. **                  aid: aid to be added to routing table. **                  route: aid route location. i.e. DH/eSE/UICC **                  aidInfo: prefix or suffix aid. ** ** Returns:         True if aid is accpted by NFA Layer. ** *******************************************************************************/ static jboolean nfcManager_routeAid(JNIEnv* e, jobject, jbyteArray aid,                                    jint route, jint aidInfo, jint power) {  if (sIsShuttingDown) return false;  uint8_t* buf;  size_t bufLen;  if (sIsDisabling || !sIsNfaEnabled) {    return false;  }   if (aid == NULL) {    buf = NULL;    bufLen = 0;    return RoutingManager::getInstance().addAidRouting(buf, bufLen, route,                                                       aidInfo, power);  }  ScopedByteArrayRO bytes(e, aid);  buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  bufLen = bytes.size();  if (NfcConfig::hasKey(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {    if (route == (int)NfcConfig::getUnsigned(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {      NativeT4tNfcee::getInstance().checkAndUpdateT4TAid(buf,                                                         (uint8_t*)&bufLen);    }  }  return RoutingManager::getInstance().addAidRouting(buf, bufLen, route,                                                     aidInfo, power); } /******************************************************************************* ** ** Function:        nfcManager_unrouteAid ** ** Description:     Remove a AID routing **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_unrouteAid(JNIEnv* e, jobject, jbyteArray aid) {  if (sIsShuttingDown) return false;  uint8_t* buf;  size_t bufLen;  if (sIsDisabling || !sIsNfaEnabled) {    return false;  }   if (aid == NULL) {    buf = NULL;    bufLen = 0;    return RoutingManager::getInstance().removeAidRouting(buf, bufLen);  }  ScopedByteArrayRO bytes(e, aid);  buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  bufLen = bytes.size();  return RoutingManager::getInstance().removeAidRouting(buf, bufLen); } /******************************************************************************* ** ** Function:        nfcManager_commitRouting ** ** Description:     Sends the AID routing table to the controller **                  e: JVM environment. **                  o: Java object. ** ** Returns:         NFA_STATUS_OK if successfully initiated **                  NFA_STATUS_SEMANTIC_ERROR is update is currently in progress **                  NFA_STATUS_FAILED otherwise ** *******************************************************************************/ static jint nfcManager_commitRouting(JNIEnv* e, jobject) {  if (sIsShuttingDown) return -1;  if (sRfEnabled) {    /*Update routing table only in Idle state.*/    startRfDiscovery(false);  }  jint commitStatus = RoutingManager::getInstance().commitRouting();  startRfDiscovery(true);  return commitStatus; } void static nfaVSCallback(uint8_t event, uint16_t param_len, uint8_t* p_param) {  switch (event & NCI_OID_MASK) {    case NCI_MSG_PROP_ANDROID: {      uint8_t android_sub_opcode = p_param[3];      switch (android_sub_opcode) {        case NCI_QUERY_ANDROID_PASSIVE_OBSERVE: {          gObserveModeEnabled = p_param[5];          LOG(INFO) << StringPrintf("%s: Query Observe mode state is %s",                                    __func__,                                    gObserveModeEnabled ? "TRUE" : "FALSE");        }          FALLTHROUGH_INTENDED;        case NCI_ANDROID_SET_PASSIVE_OBSERVER_TECH:        case NCI_ANDROID_PASSIVE_OBSERVE:        case NCI_ANDROID_SET_TECH_A_POLLING_LOOP_ANNOTATION:        case NCI_ANDROID_SET_PASSIVE_OBSERVER_EXIT_FRAME: {          gVSCmdStatus = p_param[4];          LOG(INFO) << StringPrintf(              "%s: RSP status: %x to Android proprietary cmd %x", __func__,              gVSCmdStatus, android_sub_opcode);          SyncEventGuard guard(gNfaVsCommand);          gNfaVsCommand.notifyOne();        } break;        case NCI_ANDROID_GET_CAPS: {          gVSCmdStatus = p_param[4];          SyncEventGuard guard(gNfaVsCommand);          if (param_len > 8) {            gCaps.assign(p_param + 8, p_param + param_len);          }          gNfaVsCommand.notifyOne();        } break;        case NCI_ANDROID_POLLING_FRAME_NTF: {          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {            LOG(ERROR) << StringPrintf("%s: cached nat is null", __func__);            return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {            LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);            return;          }          ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(param_len));          if (dataJavaArray.get() == NULL) {            LOG(ERROR) << __func__ << ": fail allocate array";            return;          }          e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, param_len,                                (jbyte*)(p_param));          if (e->ExceptionCheck()) {            e->ExceptionClear();            LOG(ERROR) << __func__ << ": failed to fill array";            return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerNotifyPollingLoopFrame,                            (jint)param_len, dataJavaArray.get());        } break;        case NCI_ANDROID_PASSIVE_OBSERVER_SUSPENDED_NTF: {          LOG(INFO) << "Observe mode suspended NTF received";          gObserveModeEnabled = false;          struct nfc_jni_native_data* nat = getNative(NULL, NULL);          if (!nat) {              LOG(ERROR) << StringPrintf("cached nat is null");              return;          }          JNIEnv* e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {              LOG(ERROR) << StringPrintf("jni env is null");              return;          }          if (param_len <= 2) {              LOG(ERROR) <<                    "Cannot parse exit frame from NCI_ANDROID_PASSIVE_OBSERVER_SUSPENDED_NTF";              return;          }          jint exit_frame_type = (jint) p_param[4];          uint16_t exit_frame_len = p_param[5];          ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(exit_frame_len));          if (dataJavaArray.get() == NULL) {              LOG(ERROR) << "fail allocate array";              return;          }          if (exit_frame_len > 0) {              e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, exit_frame_len,                                    (jbyte*)(p_param + 6));              if (e->ExceptionCheck()) {                  e->ExceptionClear();                  LOG(ERROR) << "failed to fill array";                  return;              }          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerOnObserveModeDisabledInFirmware,                            exit_frame_type, dataJavaArray.get());          return;        } break;        case NCI_ANDROID_PASSIVE_OBSERVER_RESUMED_NTF: {          LOG(INFO) << "Observe mode resumed NTF received";          gObserveModeEnabled = true;          struct nfc_jni_native_data *nat = getNative(NULL, NULL);          if (!nat) {              LOG(ERROR) << StringPrintf("cached nat is null");              return;          }          JNIEnv *e = NULL;          ScopedAttach attach(nat->vm, &e);          if (e == NULL) {              LOG(ERROR) << StringPrintf("jni env is null");              return;          }          e->CallVoidMethod(nat->manager,                            android::gCachedNfcManagerOnObserveModeEnabledInFirmware);          return;        } break;        case NCI_ANDROID_RESTART_RF_DISCOVERY_REQUEST_NTF: {                struct nfc_jni_native_data* nat = getNative(NULL, NULL);                if (!nat) {                  LOG(ERROR)                      << StringPrintf("%s: cached nat is null", __func__);                  return;                }                JNIEnv* e = NULL;                ScopedAttach attach(nat->vm, &e);                if (e == NULL) {                  LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);                  return;                }                e->CallVoidMethod(nat->manager,                                  android::gCachedNfcManagerOnRestartRfDiscovery);        } break;        default:          LOG(DEBUG) << StringPrintf("%s: Unknown Android sub opcode %x",                                     __func__, android_sub_opcode);      }    } break;    default: {      if (sEnableVendorNciNotifications) {        struct nfc_jni_native_data* nat = getNative(NULL, NULL);        if (!nat) {          LOG(ERROR) << StringPrintf("%s: cached nat is null", __FUNCTION__);          return;        }        JNIEnv* e = NULL;        ScopedAttach attach(nat->vm, &e);        if (e == NULL) {          LOG(ERROR) << StringPrintf("%s: jni env is null", __FUNCTION__);          return;        }        ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(param_len));        if (dataJavaArray.get() == NULL) {          LOG(ERROR) << StringPrintf("%s: fail allocate array", __FUNCTION__);          return;        }        e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, param_len,                              (jbyte*)(p_param));        if (e->ExceptionCheck()) {          e->ExceptionClear();          LOG(ERROR) << StringPrintf("%s failed to fill array", __FUNCTION__);          return;        }        e->CallVoidMethod(nat->manager,                          android::gCachedNfcManagerNotifyVendorSpecificEvent,                          (jint)event, (jint)param_len, dataJavaArray.get());      }    } break;  } } static void nfcManager_injectNtf(JNIEnv* e, jobject, jbyteArray data) {  if (sIsShuttingDown) return;  ScopedByteArrayRO bytes(e, data);  size_t bufLen = bytes.size();  tNFC_HAL_EVT_MSG* p_msg;  p_msg = (tNFC_HAL_EVT_MSG*)GKI_getbuf(sizeof(tNFC_HAL_EVT_MSG) + bufLen + 1);  if (p_msg != NULL) {    p_msg->hdr.len = bufLen + 3;    p_msg->hdr.event = BT_EVT_TO_NFC_NCI;    p_msg->hdr.offset = sizeof(tNFC_HAL_EVT_MSG) - 7;    p_msg->hdr.layer_specific = 0;    memcpy(((uint8_t*)p_msg) + sizeof(tNFC_HAL_EVT_MSG) + 1, bytes.get(),           bufLen);    GKI_send_msg(NFC_TASK, NFC_MBOX_ID, p_msg);  } } static jboolean isObserveModeSupported(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported =      e->GetMethodID(cls.get(), "isObserveModeSupported", "()Z");  return e->CallBooleanMethod(o, isSupported); } static jboolean nfcManager_isObserveModeEnabled(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  if (isObserveModeSupported(e, o) == JNI_FALSE) {    return false;  }   uint8_t cmd[] = {NCI_QUERY_ANDROID_PASSIVE_OBSERVE};  SyncEventGuard guard(gNfaVsCommand);  tNFA_STATUS status =      NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, sizeof(cmd), cmd, nfaVSCallback);   if (status == NFA_STATUS_OK) {    if (!gNfaVsCommand.wait(1000)) {      LOG(ERROR) << StringPrintf(          "%s: Timed out waiting for a response to get observe mode ",          __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  } else {    LOG(DEBUG) << StringPrintf("%s: Failed to get observe mode ", __FUNCTION__);  }  LOG(DEBUG) << StringPrintf(      "%s: returning %s", __FUNCTION__,      (gObserveModeEnabled != JNI_FALSE ? "TRUE" : "FALSE"));  return gObserveModeEnabled; } static void nfaSendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                    uint8_t* p_param) {  if (param_len == 5) {    gVSCmdStatus = p_param[4];  } else {    gVSCmdStatus = NFA_STATUS_FAILED;  }  SyncEventGuard guard(gNfaVsCommand);  gNfaVsCommand.notifyOne(); } bool isObserveModeSupportedWithoutRfDeactivation(JNIEnv* e, jobject o) {  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported = e->GetMethodID(      cls.get(), "isObserveModeSupportedWithoutRfDeactivation", "()Z");  return e->CallBooleanMethod(o, isSupported); } static jboolean nfcManager_setObserveMode(JNIEnv* e, jobject o,                                          jboolean enable) {  if (sIsShuttingDown) return false;  if (isObserveModeSupported(e, o) == JNI_FALSE) {    LOG(DEBUG) << "setObserveMode called when it isn't supported, returning false";    return false;  }   if (isObserveModeSupportedWithoutRfDeactivation(e, o) == JNI_FALSE) {    LOG(DEBUG) << "setObserveMode called when it requires RF off/on, returning false";    return false;  }   if ((gObserveModeEnabled == enable) &&      ((enable != JNI_FALSE) ==       (nfcManager_isObserveModeEnabled(e, o) != JNI_FALSE))) {    LOG(DEBUG) << StringPrintf(        "%s: called with %s but it is already %s, returning early",        __FUNCTION__, (enable != JNI_FALSE ? "TRUE" : "FALSE"),        (gObserveModeEnabled != JNI_FALSE ? "TRUE" : "FALSE"));    return true;  }  uint8_t cmd[] = {      static_cast<uint8_t>(NCI_ANDROID_SET_PASSIVE_OBSERVER_TECH),      static_cast<uint8_t>(          enable != JNI_FALSE              ? (NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_A |                           NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_B |                           NCI_ANDROID_PASSIVE_OBSERVE_PARAM_ENABLE_V)              : NCI_ANDROID_PASSIVE_OBSERVE_PARAM_DISABLE)};  {    SyncEventGuard guard(gNfaVsCommand);    tNFA_STATUS status = NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, sizeof(cmd),                                           cmd, nfaVSCallback);     if (status == NFA_STATUS_OK) {      if (!gNfaVsCommand.wait(1000)) {        LOG(ERROR) << StringPrintf(            "%s: Timed out waiting for a response to set observe mode ",            __FUNCTION__);        gVSCmdStatus = NFA_STATUS_FAILED;      }    } else {      LOG(DEBUG) << StringPrintf("%s: Failed to set observe mode ",                                 __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  }   if (gVSCmdStatus == NFA_STATUS_OK) {    gObserveModeEnabled = enable;  } else {    gObserveModeEnabled = nfcManager_isObserveModeEnabled(e, o);  }   LOG(DEBUG) << StringPrintf(      "%s: Set observe mode to %s with result %x, observe mode is now %s.",      __FUNCTION__, (enable != JNI_FALSE ? "TRUE" : "FALSE"), gVSCmdStatus,      (gObserveModeEnabled ? "enabled" : "disabled"));  if (gObserveModeEnabled == enable) {    e->CallVoidMethod(o, android::gCachedNfcManagerNotifyObserveModeChanged,                      enable);    return true;  } else {    return false;  } } /******************************************************************************* ** ** Function:        nfcManager_doRegisterT3tIdentifier ** ** Description:     Registers LF_T3T_IDENTIFIER for NFC-F. **                  e: JVM environment. **                  o: Java object. **                  t3tIdentifier: LF_T3T_IDENTIFIER value (10 or 18 bytes) ** ** Returns:         Handle retrieve from RoutingManager. ** *******************************************************************************/ static jint nfcManager_doRegisterT3tIdentifier(JNIEnv* e, jobject,                                               jbyteArray t3tIdentifier) {  if (sIsShuttingDown) return -1;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);   ScopedByteArrayRO bytes(e, t3tIdentifier);  uint8_t* buf =      const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));  size_t bufLen = bytes.size();  int handle = RoutingManager::getInstance().registerT3tIdentifier(buf, bufLen);   LOG(DEBUG) << StringPrintf("%s: handle=%d", __func__, handle);  if (handle != NFA_HANDLE_INVALID)    RoutingManager::getInstance().commitRouting();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);   return handle; } /******************************************************************************* ** ** Function:        nfcManager_doDeregisterT3tIdentifier ** ** Description:     Deregisters LF_T3T_IDENTIFIER for NFC-F. **                  e: JVM environment. **                  o: Java object. **                  handle: Handle retrieve from libnfc-nci. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doDeregisterT3tIdentifier(JNIEnv*, jobject,                                                 jint handle) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter; handle=%d", __func__, handle);   RoutingManager::getInstance().deregisterT3tIdentifier(handle);  RoutingManager::getInstance().commitRouting();   LOG(DEBUG) << StringPrintf("%s: exit", __func__); } /******************************************************************************* ** ** Function:        nfcManager_getLfT3tMax ** ** Description:     Returns LF_T3T_MAX value. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         LF_T3T_MAX value. ** *******************************************************************************/ static jint nfcManager_getLfT3tMax(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  LOG(DEBUG) << StringPrintf("%s: LF_T3T_MAX=%d", __func__, sLfT3tMax);  return sLfT3tMax; } /******************************************************************************* ** ** Function:        doPartialInit ** ** Description:     Partial Nfc initialization based on mode set **	            ENABLE_MODE_TRANSPARENT : Minimum initialization to allow **                                 NFCC transport **	            ENABLE_MODE_EE : Minimum Initialization to allow card **                                 emulation operation ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean doPartialInit() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  tNFA_STATUS stat = NFA_STATUS_OK;   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Initialize();  // start GKI, NCI task, NFC task   {    SyncEventGuard guard(sNfaEnableEvent);    tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();    NFA_Partial_Init(halFuncEntries, gPartialInitMode);    LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);    NFA_RegVSCback(true, &nfaVSCallback);     LOG(DEBUG) << StringPrintf("%s: calling enable", __func__);    stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);    if (stat == NFA_STATUS_OK) {      sNfaEnableEvent.wait();  // wait for NFA command to finish    }    NFA_SetNfccMode(ENABLE_MODE_DEFAULT);  }   // sIsNfaEnabled indicates whether stack started successfully  if (!sIsNfaEnabled) {    NFA_Disable(false /* ungraceful */);    theInstance.Finalize();    return JNI_FALSE;  }  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        nfcManager_doInitialize ** ** Description:     Turn on NFC. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  initializeGlobalDebugEnabledFlag();  tNFA_STATUS stat = NFA_STATUS_OK;  sIsRecovering = false;   struct nfc_jni_native_data* nat = getNative(e, o);   if (sIsNfaEnabled) {    LOG(DEBUG) << StringPrintf("%s: already enabled", __func__);    goto TheEnd;  }  if (gPartialInitMode != ENABLE_MODE_DEFAULT) {    return doPartialInit();  }   {     NfcAdaptation& theInstance = NfcAdaptation::GetInstance();    theInstance.Initialize();  // start GKI, NCI task, NFC task     {      SyncEventGuard guard(sNfaEnableEvent);      tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();       NFA_Init(halFuncEntries);       LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);      NFA_RegVSCback(true, &nfaVSCallback);       if (gIsDtaEnabled == true) {        // Allows to set appl_dta_mode_flag        LOG(DEBUG) << StringPrintf("%s: DTA; set dta flag in core stack",                                   __func__);        NFA_EnableDtamode((tNFA_eDtaModes)NFA_DTA_APPL_MODE);      }       stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);      if (stat == NFA_STATUS_OK) {        sNfaEnableEvent.wait();  // wait for NFA command to finish      }    }     if (stat == NFA_STATUS_OK) {      // sIsNfaEnabled indicates whether stack started successfully      if (sIsNfaEnabled) {        sRoutingInitialized =            RoutingManager::getInstance().initialize(getNative(e, o));        nativeNfcTag_registerNdefTypeHandler();        NfcTag::getInstance().initialize(getNative(e, o));        HciEventManager::getInstance().initialize(getNative(e, o));        NativeWlcManager::getInstance().initialize(getNative(e, o));        NativeT4tNfcee::getInstance().initialize();         /////////////////////////////////////////////////////////////////////////////////        // Add extra configuration here (work-arounds, etc.)         if (nat) {          nat->tech_mask =              NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);          LOG(DEBUG) << StringPrintf("%s: tag polling tech mask=0x%X", __func__,                                     nat->tech_mask);           // if this value exists, set polling interval.          nat->discovery_duration = NfcConfig::getUnsigned(              NAME_NFA_DM_DISC_DURATION_POLL, DEFAULT_DISCOVERY_DURATION);          NFA_SetRfDiscoveryDuration(nat->discovery_duration);        } else {          LOG(ERROR) << StringPrintf("nat is null");        }         // get LF_T3T_MAX        {          SyncEventGuard guard(gNfaGetConfigEvent);          tNFA_PMID configParam[1] = {NCI_PARAM_ID_LF_T3T_MAX};          stat = NFA_GetConfig(1, configParam);          if (stat == NFA_STATUS_OK) {            gNfaGetConfigEvent.wait();            if (gCurrentConfigLen >= 4 ||                gConfig[1] == NCI_PARAM_ID_LF_T3T_MAX) {              LOG(DEBUG) << StringPrintf("%s: lfT3tMax=%d", __func__,                                         gConfig[3]);              sLfT3tMax = gConfig[3];            }          }        }         prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED;         // Do custom NFCA startup configuration.        doStartupConfig(); #ifdef DTA_ENABLED        NfcDta::getInstance().setNfccConfigParams(); #endif /* DTA_ENABLED */        goto TheEnd;      }    }     if (gIsDtaEnabled == true) {      LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                 __func__);      NFA_DisableDtamode();    }     LOG(ERROR) << StringPrintf("%s: fail nfa enable; error=0x%X", __func__,                               stat);     if (sIsNfaEnabled) {      stat = NFA_Disable(FALSE /* ungraceful */);    }     theInstance.Finalize();  } TheEnd:  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return sIsNfaEnabled ? JNI_TRUE : JNI_FALSE; } static void nfcManager_doSetPartialInitMode(JNIEnv*, jobject, jint mode) {  if (sIsShuttingDown) return;  gPartialInitMode = mode; } static void nfcManager_doEnableDtaMode(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  gIsDtaEnabled = true; } static void nfcManager_doDisableDtaMode(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  gIsDtaEnabled = false; } static void nfcManager_doFactoryReset(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.FactoryReset(); } static void nfcManager_doShutdown(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  NativeT4tNfcee::getInstance().onNfccShutdown();  theInstance.DeviceShutdown();  sIsShuttingDown = true; } static void nfcManager_configNfccConfigControl(bool flag) {    // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.    if (NFC_GetNCIVersion() != NCI_VERSION_1_0) {        uint8_t nfa_set_config[] = { 0x00 };         nfa_set_config[0] = (flag == true ? 1 : 0);         tNFA_STATUS status = NFA_SetConfig(NCI_PARAM_ID_NFCC_CONFIG_CONTROL,                                           sizeof(nfa_set_config),                                           &nfa_set_config[0]);        if (status != NFA_STATUS_OK) {            LOG(ERROR) << __func__            << ": Failed to configure NFCC_CONFIG_CONTROL";        }    } } static bool isReaderModeAnnotationSupported(JNIEnv* e, jobject o) {  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));  jmethodID isSupported =      e->GetMethodID(cls.get(), "isReaderModeAnnotationSupportedCaps", "()Z");  return e->CallBooleanMethod(o, isSupported); } static tNFA_STATUS setTechAPollingLoopAnnotation(JNIEnv* env, jobject o,                                                  const uint8_t* annotation_data,                                                  size_t annotation_size) {    std::vector<uint8_t> command;    command.push_back(NCI_ANDROID_SET_TECH_A_POLLING_LOOP_ANNOTATION);    if (annotation_data == NULL || annotation_size == 0) {      // Annotation is null or size is 0, setting 0 annotations      command.push_back(0x00);    } else {      command.push_back(0x01);                 // Number of frame entries.      command.push_back(0x21);                 // Position and type.      command.push_back(annotation_size + 3);  // Length      command.push_back(0x0a);                 // Waiting time      command.insert(command.end(), annotation_data, annotation_data + annotation_size);      command.push_back(0x00);      command.push_back(0x00);    }    SyncEventGuard guard(gNfaVsCommand);    tNFA_STATUS status =        NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, command.size(), command.data(), nfaVSCallback);    if (status == NFA_STATUS_OK) {      if (!gNfaVsCommand.wait(1000)) {        LOG(ERROR) << StringPrintf(            "%s: Timed out waiting for a response to setting a polling loop annotation ",            __FUNCTION__);        gVSCmdStatus = NFA_STATUS_FAILED;      }    } else {      gVSCmdStatus = status;    }    return gVSCmdStatus; } /******************************************************************************* ** ** Function:        nfcManager_enableDiscovery ** ** Description:     Start polling and listening for devices. **                  e: JVM environment. **                  o: Java object. **                  technologies_mask: the bitmask of technologies for which to *enable discovery **                  enable_lptd: whether to enable low power polling (default: *false) ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_enableDiscovery(JNIEnv* e, jobject o,                                       jint technologies_mask,                                       jboolean enable_lptd,                                       jboolean reader_mode,                                       jboolean enable_host_routing,                                       jbyteArray tech_a_polling_loop_annotation,                                       jboolean restart) {  if (sIsShuttingDown) return;  tNFA_TECHNOLOGY_MASK tech_mask = DEFAULT_TECH_MASK;  struct nfc_jni_native_data* nat = getNative(e, o);   if (technologies_mask == -1 && nat)    tech_mask = (tNFA_TECHNOLOGY_MASK)nat->tech_mask;  else if (technologies_mask != -1)    tech_mask = (tNFA_TECHNOLOGY_MASK)technologies_mask;  LOG(DEBUG) << StringPrintf("%s: enter; tech_mask = %02x", __func__,                             tech_mask);   if (sDiscoveryEnabled && !restart) {    LOG(ERROR) << StringPrintf("%s: already discovering", __func__);    return;  }   if (sRfEnabled) {    // Stop RF discovery to reconfigure    startRfDiscovery(false);  }   // Check polling configuration  if (tech_mask != 0) {    stopPolling_rfDiscoveryDisabled();    if (isReaderModeAnnotationSupported(e, o)) {      if (reader_mode) {        if (tech_a_polling_loop_annotation == NULL) {          setTechAPollingLoopAnnotation(e, o, NULL, 0);        } else {          ScopedByteArrayRO annotationBytes(e, tech_a_polling_loop_annotation);          setTechAPollingLoopAnnotation(e, o,                                        (const uint8_t*)annotationBytes.get(),                                        annotationBytes.size());        }      } else if (reader_mode_ignore_frame()) {        uint8_t ignoreFrame[] = {0x6a, 0x01, 0xcf, 0x00, 0x00};        setTechAPollingLoopAnnotation(e, 0, ignoreFrame, 5);      }    }     startPolling_rfDiscoveryDisabled(tech_mask);     if (sPollingEnabled) {      if (reader_mode && !sReaderModeEnabled) {        sReaderModeEnabled = true;        NFA_DisableListening();         // configure NFCC_CONFIG_CONTROL- NFCC not allowed to manage RF configuration.        nfcManager_configNfccConfigControl(false);         NFA_SetRfDiscoveryDuration(READER_MODE_DISCOVERY_DURATION);      } else if (!reader_mode && sReaderModeEnabled) {        struct nfc_jni_native_data* nat = getNative(e, o);        sReaderModeEnabled = false;        NFA_EnableListening();         // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.        nfcManager_configNfccConfigControl(true);         if (nat) {          NFA_SetRfDiscoveryDuration(nat->discovery_duration);        } else {          LOG(ERROR) << StringPrintf("%s: nat is null", __func__);        }      }    }  } else {    if (!reader_mode && sReaderModeEnabled) {      LOG(DEBUG) << StringPrintf(          "%s: if reader mode disable, enable listen again", __func__);      struct nfc_jni_native_data* nat = getNative(e, o);      sReaderModeEnabled = false;      NFA_EnableListening();       // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.      nfcManager_configNfccConfigControl(true);       if (nat) {        NFA_SetRfDiscoveryDuration(nat->discovery_duration);      } else {        LOG(ERROR) << StringPrintf("%s: nat is null", __func__);      }    }    // No technologies configured, stop polling    stopPolling_rfDiscoveryDisabled();  }   // Checking if RT should be updated  RoutingManager::getInstance().commitRouting();   // Actually start discovery.  startRfDiscovery(true);  sDiscoveryEnabled = true;   LOG(DEBUG) << StringPrintf("%s: exit", __func__); } /******************************************************************************* ** ** Function:        nfcManager_disableDiscovery ** ** Description:     Stop polling and listening for devices. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         None ** *******************************************************************************/ void nfcManager_disableDiscovery(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return;  tNFA_STATUS status = NFA_STATUS_OK;  LOG(DEBUG) << StringPrintf("%s: enter;", __func__);   if (sDiscoveryEnabled == false) {    LOG(DEBUG) << StringPrintf("%s: already disabled", __func__);    goto TheEnd;  }   // Stop RF Discovery.  startRfDiscovery(false);  sDiscoveryEnabled = false;  if (sPollingEnabled) status = stopPolling_rfDiscoveryDisabled(); TheEnd:  LOG(DEBUG) << StringPrintf("%s: exit: Status = 0x%X", __func__, status); } /******************************************************************************* ** ** Function:        doPartialDeinit ** ** Description:     Partial DeInit for mode TRANSPARENT, CE .. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean doPartialDeinit() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  tNFA_STATUS stat = NFA_STATUS_OK;  sIsDisabling = true;  if (sIsNfaEnabled) {    SyncEventGuard guard(sNfaDisableEvent);    stat = NFA_Disable(TRUE /* graceful */);    if (stat == NFA_STATUS_OK) {      LOG(DEBUG) << StringPrintf("%s: wait for completion", __func__);      sNfaDisableEvent.wait();  // wait for NFA command to finish    } else {      LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,                                 stat);    }  }  sIsDisabling = false;   LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);  NFA_RegVSCback(false, &nfaVSCallback);   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  theInstance.Finalize();   return stat == NFA_STATUS_OK ? JNI_TRUE : JNI_FALSE; } /******************************************************************************* ** ** Function:        nfcManager_doDeinitialize ** ** Description:     Turn off NFC. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doDeinitialize(JNIEnv*, jobject) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter, sIsRecovering=%d", __func__,                             sIsRecovering);  if (gPartialInitMode != ENABLE_MODE_DEFAULT) {    return doPartialDeinit();  }  sIsDisabling = true;   NativeT4tNfcee::getInstance().onNfccShutdown();  if (!recovery_option || !sIsRecovering) {    RoutingManager::getInstance().onNfccShutdown();  }  HciEventManager::getInstance().finalize();   if (sIsNfaEnabled) {    SyncEventGuard guard(sNfaDisableEvent);     if (gIsDtaEnabled == true) {      LOG(DEBUG) << StringPrintf("%s: DTA; unset dta flag in core stack",                                 __func__);      NFA_DisableDtamode();    }     tNFA_STATUS stat = NFA_Disable(!sIsRecovering);    if (stat == NFA_STATUS_OK) {      LOG(DEBUG) << StringPrintf("%s: wait for completion", __func__);      if (!sNfaDisableEvent.wait(5000)) {        LOG(ERROR) << StringPrintf(            "%s: NFA_Disable() timeout, keep disabling anyway", __func__);      }    } else {      LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,                                 stat);    }  }  nativeNfcTag_abortWaits();  NfcTag::getInstance().abort();  sAbortConnlessWait = true;  sIsNfaEnabled = false;  sRoutingInitialized = false;  sDiscoveryEnabled = false;  sPollingEnabled = false;  sIsDisabling = false;  sReaderModeEnabled = false;  gActivated = false;  sRfEnabled = false;  sLfT3tMax = 0;   {    // unblock NFA_EnablePolling() and NFA_DisablePolling()    SyncEventGuard guard(sNfaEnableDisablePollingEvent);    sNfaEnableDisablePollingEvent.notifyOne();  }   LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);  NFA_RegVSCback(false, &nfaVSCallback);  // abort any active waits  {    SyncEventGuard guard(sNfaSetPowerSubState);    sNfaSetPowerSubState.notifyOne();  }  {    SyncEventGuard guard(sNfaEnableDisablePollingEvent);    sNfaEnableDisablePollingEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaSetConfigEvent);    gNfaSetConfigEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaGetConfigEvent);    gNfaGetConfigEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaVsCommand);    gNfaVsCommand.notifyOne();  }  {    SyncEventGuard guard(gSendRawVsCmdEvent);    gSendRawVsCmdEvent.notifyOne();  }  {    SyncEventGuard guard(gNfaRemoveEpEvent);    gNfaRemoveEpEvent.notifyOne();  }   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Finalize();   LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return JNI_TRUE; } /******************************************************************************* ** ** Function:        isListenMode ** ** Description:     Indicates whether the activation data indicates it is **                  listen mode. ** ** Returns:         True if this listen mode. ** *******************************************************************************/ static bool isListenMode(tNFA_ACTIVATED& activated) {  return (      (NFC_DISCOVERY_TYPE_LISTEN_A ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_B ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_F ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_ISO15693 ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_DISCOVERY_TYPE_LISTEN_B_PRIME ==       activated.activate_ntf.rf_tech_param.mode) ||      (NFC_INTERFACE_EE_DIRECT_RF == activated.activate_ntf.intf_param.type)); } /******************************************************************************* ** ** Function:        nfcManager_doAbort ** ** Description:     Not used. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doAbort(JNIEnv* e, jobject, jstring msg) {  ScopedUtfChars message = {e, msg};  e->FatalError(message.c_str());  abort();  // <-- Unreachable } /******************************************************************************* ** ** Function:        nfcManager_doDownload ** ** Description:     Download firmware patch files.  Do not turn on NFC. ** ** Returns:         True if ok. ** *******************************************************************************/ static jboolean nfcManager_doDownload(JNIEnv*, jobject) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter", __func__);  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  bool result = JNI_FALSE;  theInstance.Initialize();  // start GKI, NCI task, NFC task  tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();  NFA_Partial_Init(halFuncEntries, ENABLE_MODE_TRANSPARENT);  NFA_RegVSCback(true, &nfaVSCallback);  result = theInstance.DownloadFirmware();  NFA_RegVSCback(false, &nfaVSCallback);  theInstance.Finalize();  LOG(DEBUG) << StringPrintf("%s: exit", __func__);  return result; } /******************************************************************************* ** ** Function:        nfcManager_doResetTimeouts ** ** Description:     Not used. ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doResetTimeouts(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s", __func__);  NfcTag::getInstance().resetAllTransceiveTimeouts(true); } /******************************************************************************* ** ** Function:        nfcManager_doSetTimeout ** ** Description:     Set timeout value. **                  e: JVM environment. **                  o: Java object. **                  tech: technology ID. **                  timeout: Timeout value. ** ** Returns:         True if ok. ** *******************************************************************************/ static bool nfcManager_doSetTimeout(JNIEnv*, jobject, jint tech, jint timeout) {  if (sIsShuttingDown) return false;  if (timeout <= 0) {    LOG(ERROR) << StringPrintf("%s: Timeout must be positive.", __func__);    return false;  }  LOG(DEBUG) << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech,                             timeout);  NfcTag::getInstance().setTransceiveTimeout(tech, timeout);  return true; } /******************************************************************************* ** ** Function:        nfcManager_doGetTimeout ** ** Description:     Get timeout value. **                  e: JVM environment. **                  o: Java object. **                  tech: technology ID. ** ** Returns:         Timeout value. ** *******************************************************************************/ static jint nfcManager_doGetTimeout(JNIEnv*, jobject, jint tech) {  if (sIsShuttingDown) return -1;  int timeout = NfcTag::getInstance().getTransceiveTimeout(tech);  LOG(DEBUG) << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech,                             timeout);  return timeout; } /******************************************************************************* ** ** Function:        nfcManager_doDump ** ** Description:     Get libnfc-nci dump **                  e: JVM environment. **                  obj: Java object. **                  fdobj: File descriptor to be used ** ** Returns:         Void ** *******************************************************************************/ static void nfcManager_doDump(JNIEnv* e, jobject obj, jobject fdobj) {  if (sIsShuttingDown) return;  int fd = jniGetFDFromFileDescriptor(e, fdobj);  if (fd < 0) return;   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();  theInstance.Dump(fd); } static jint nfcManager_doGetNciVersion(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  return NFC_GetNCIVersion(); } static void nfcManager_doSetScreenState(JNIEnv* e, jobject o,                                        jint screen_state_mask,                                        jboolean alwaysPoll) {  if (sIsShuttingDown) return;  tNFA_STATUS status = NFA_STATUS_OK;  uint8_t state = (screen_state_mask & NFA_SCREEN_STATE_MASK);  uint8_t discovry_param =      NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;  sIsAlwaysPolling = alwaysPoll;   LOG(DEBUG) << StringPrintf(      "%s: state = %d prevScreenState= %d, discovry_param = %d", __FUNCTION__,      state, prevScreenState, discovry_param);   if (prevScreenState == state) {    LOG(DEBUG) << StringPrintf(        "%s: New screen state is same as previous state. No action taken",        __func__);    return;  }   if (sIsDisabling || !sIsNfaEnabled ||      (NFC_GetNCIVersion() != NCI_VERSION_2_0)) {    prevScreenState = state;    return;  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||      prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED ||      prevScreenState == NFA_SCREEN_STATE_ON_LOCKED) {    SyncEventGuard guard(sNfaSetPowerSubState);    status = NFA_SetPowerSubStateForScreenState(state);    if (status != NFA_STATUS_OK) {      LOG(ERROR) << StringPrintf("%s: fail enable SetScreenState; error=0x%X",                                 __FUNCTION__, status);      return;    } else {      sNfaSetPowerSubState.wait();    }  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (state == NFA_SCREEN_STATE_OFF_LOCKED ||      state == NFA_SCREEN_STATE_OFF_UNLOCKED) {    // disable poll and enable listen on DH 0x00    discovry_param =        NCI_POLLING_DH_DISABLE_MASK | NCI_LISTEN_DH_NFCEE_ENABLE_MASK;  }   if (state == NFA_SCREEN_STATE_ON_LOCKED) {    // disable poll and enable listen on DH 0x00    discovry_param =        (screen_state_mask & NFA_SCREEN_POLLING_TAG_MASK)            ? (NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK)            : (NCI_POLLING_DH_DISABLE_MASK | NCI_LISTEN_DH_NFCEE_ENABLE_MASK);  }   if (state == NFA_SCREEN_STATE_ON_UNLOCKED) {    // enable both poll and listen on DH 0x01    discovry_param =        NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;  }   if (!sIsAlwaysPolling) {    SyncEventGuard guard(gNfaSetConfigEvent);    status = NFA_SetConfig(NCI_PARAM_ID_CON_DISCOVERY_PARAM,                           NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);    if (status == NFA_STATUS_OK) {      gNfaSetConfigEvent.wait();    } else {      LOG(ERROR) << StringPrintf("%s: Failed to update CON_DISCOVER_PARAM",                                 __FUNCTION__);      return;    }  }  // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if (prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED) {    SyncEventGuard guard(sNfaSetPowerSubState);    status = NFA_SetPowerSubStateForScreenState(state);    if (status != NFA_STATUS_OK) {      LOG(ERROR) << StringPrintf("%s: fail enable SetScreenState; error=0x%X",                                 __FUNCTION__, status);    } else {      sNfaSetPowerSubState.wait();    }  }   // skip remaining SetScreenState tasks when trying to silent recover NFCC  if (recovery_option && sIsRecovering) {    prevScreenState = state;    return;  }   if ((state == NFA_SCREEN_STATE_OFF_LOCKED ||       state == NFA_SCREEN_STATE_OFF_UNLOCKED) &&      (prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED ||       prevScreenState == NFA_SCREEN_STATE_ON_LOCKED) &&      (!sSeRfActive)) {    // screen turns off, disconnect tag if connected    nativeNfcTag_doDisconnect(NULL, NULL);  }   prevScreenState = state; } /******************************************************************************* ** ** Function:        nfcManager_getIsoDepMaxTransceiveLength ** ** Description:     Get maximum ISO DEP Transceive Length supported by the NFC **                  chip. Returns default 261 bytes if the property is not set. ** ** Returns:         max value. ** *******************************************************************************/ static jint nfcManager_getIsoDepMaxTransceiveLength(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  /* Check if extended APDU is supported by the chip.   * If not, default value is returned.   * The maximum length of a default IsoDep frame consists of:   * CLA, INS, P1, P2, LC, LE + 255 payload bytes = 261 bytes   */  return NfcConfig::getUnsigned(NAME_ISO_DEP_MAX_TRANSCEIVE, 261); } /******************************************************************************* ** ** Function:        nfcManager_getAidTableSize ** Description:     Get the maximum supported size for AID routing table. ** **                  e: JVM environment. **                  o: Java object. ** *******************************************************************************/ static jint nfcManager_getAidTableSize(JNIEnv*, jobject) {  if (sIsShuttingDown) return -1;  return NFA_GetAidTableSize(); } /******************************************************************************* ** ** Function:        nfcManager_IsMultiTag ** ** Description:     Check if it a multi tag case. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         None. ** *******************************************************************************/ static bool nfcManager_isMultiTag() {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter mNumRfDiscId = %d", __func__,                             NfcTag::getInstance().mNumRfDiscId);  bool status = false;  if (NfcTag::getInstance().mNumRfDiscId > 1) status = true;  LOG(DEBUG) << StringPrintf("isMultiTag = %d", status);  return status; } /******************************************************************************* ** ** Function:        nfcManager_doStartStopPolling ** ** Description:     Start or stop NFC RF polling **                  e: JVM environment. **                  o: Java object. **                  start: start or stop RF polling ** ** Returns:         None ** *******************************************************************************/ static void nfcManager_doStartStopPolling(JNIEnv* e, jobject o,                                          jboolean start) {  if (sIsShuttingDown) return;  startStopPolling(start); } /******************************************************************************* ** ** Function:        nfcManager_doSetNfcSecure ** ** Description:     Set NfcSecure enable/disable. **                  e: JVM environment. **                  o: Java object. **                  enable: Sets true/false to enable/disable NfcSecure **                  It only updates the routing table cache without commit to **                  NFCC. ** ** Returns:         True always ** *******************************************************************************/ static jboolean nfcManager_doSetNfcSecure(JNIEnv* e, jobject o,                                          jboolean enable) {  if (sIsShuttingDown) return false;  RoutingManager& routingManager = RoutingManager::getInstance();  routingManager.setNfcSecure(enable);  if (sRoutingInitialized) {    routingManager.setEeTechRouteUpdateRequired();  }  return true; } static void nfcManager_doSetNfceePowerAndLinkCtrl(JNIEnv* e, jobject o,                                                  jboolean enable) {  if (sIsShuttingDown) return;  RoutingManager& routingManager = RoutingManager::getInstance();  if (enable) {    routingManager.eeSetPwrAndLinkCtrl(        (uint8_t)always_on_nfcee_power_and_link_conf);  } else {    routingManager.eeSetPwrAndLinkCtrl(        (uint8_t)disable_always_on_nfcee_power_and_link_conf);  } } /******************************************************************************* ** ** Function:        nfcManager_doGetMaxRoutingTableSize ** ** Description:     Retrieve the max routing table size from cache **                  e: JVM environment. **                  o: Java object. ** ** Returns:         Max Routing Table size ** *******************************************************************************/ static jint nfcManager_doGetMaxRoutingTableSize(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return -1;  return lmrt_get_max_size(); } /******************************************************************************* ** ** Function:        nfcManager_doGetRoutingTable ** ** Description:     Retrieve the committed listen mode routing configuration **                  e: JVM environment. **                  o: Java object. ** ** Returns:         Committed listen mode routing configuration ** *******************************************************************************/ static jbyteArray nfcManager_doGetRoutingTable(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return nullptr;  std::vector<uint8_t>* routingTable = lmrt_get_tlvs();   CHECK(e);  jbyteArray rtJavaArray = e->NewByteArray((*routingTable).size());  CHECK(rtJavaArray);  e->SetByteArrayRegion(rtJavaArray, 0, (*routingTable).size(),                        (jbyte*)&(*routingTable)[0]);   return rtJavaArray; } static void nfcManager_clearRoutingEntry(JNIEnv* e, jobject o,                                         jint clearFlags) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: clearFlags=0x%X", __func__, clearFlags);  RoutingManager::getInstance().clearRoutingEntry(clearFlags); } /******************************************************************************* ** ** Function:        nfcManager_doDetectEpRemoval ** ** Description:     Start detection of WLC Listener removal **                  e: JVM environment. **                  waiting_time_int: ** ** Returns:         True if WLCL remove started properly ** *******************************************************************************/ static jboolean nfcManager_doDetectEpRemoval(JNIEnv* e, jobject o,                                             jint waiting_time_int) {  if (sIsShuttingDown) return false;  tNFA_STATUS stat = NFA_STATUS_FAILED;   LOG(DEBUG) << StringPrintf("%s: enter waiting_time = %04X", __func__,                             waiting_time_int);   nativeNfcTag_acquireRfInterfaceMutexLock();  stat = NFA_StartRemovalDetection((uint8_t)(waiting_time_int & 0xFF));  if (stat == NFA_STATUS_OK) {    LOG(DEBUG) << StringPrintf(        "%s: start detect EP Listener removal, wait for success confirmation",        __func__);    SyncEventGuard g(gNfaRemoveEpEvent);    gNfaRemoveEpEvent.wait();    stat = sIsEpDetectStarted ? JNI_TRUE : JNI_FALSE;  } else {    LOG(ERROR) << StringPrintf("%s: fail detect EP removal; error=0x%X",                               __func__, stat);    stat = false;  }  nativeNfcTag_releaseRfInterfaceMutexLock();  return stat; } /******************************************************************************* ** ** Function:        nfcManager_isRemovalDetectionSupported ** ** Description:     Check if the Removal Detection in Poll mode is supported. **                  e: JVM environment. **                  o: Java object. ** ** Returns:         True if supports 'Removal Detection Mode' ** *******************************************************************************/ static jboolean nfcManager_isRemovalDetectionSupported(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return false;  return NFA_IsRfRemovalDetectionSupported(); } static void nfcManager_updateIsoDepProtocolRoute(JNIEnv* e, jobject o,                                                 jint route) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateIsoDepProtocolRoute(route); } static void nfcManager_updateTechnologyABFRoute(JNIEnv* e, jobject o,                                                jint route, jint felicaRoute) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateTechnologyABFRoute(route, felicaRoute); } static void nfcManager_updateSystemCodeRoute(JNIEnv* e, jobject o,                                                jint route) {  if (sIsShuttingDown) return;  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);  RoutingManager::getInstance().updateSystemCodeRoute(route); } /******************************************************************************* ** ** Function:        nfcManager_setDiscoveryTech ** ** Description:     Temporarily changes the RF parameter **                  pollTech: RF tech parameters for poll mode **                  listenTech: RF tech parameters for listen mode ** ** Returns:         None. ** *******************************************************************************/ static void nfcManager_setDiscoveryTech(JNIEnv* e, jobject o, jint pollTech,                                        jint listenTech) {  if (sIsShuttingDown) return;  tNFA_STATUS nfaStat;  bool isRevertPoll = false;  bool isRevertListen = false;  bool changeDefaultTech = false;  LOG(DEBUG) << StringPrintf("%s  pollTech = 0x%x, listenTech = 0x%x", __func__,                             pollTech, listenTech);   if (pollTech < 0) isRevertPoll = true;  if (listenTech < 0) isRevertListen = true;  if (pollTech & FLAG_SET_DEFAULT_TECH || listenTech & FLAG_SET_DEFAULT_TECH)    changeDefaultTech = true;   // Need listen tech routing update in routing table  // for addition of blocking bit  RoutingManager::getInstance().setEeTechRouteUpdateRequired();   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);   nfaStat = NFA_ChangeDiscoveryTech(pollTech, listenTech, isRevertPoll,                                    isRevertListen, changeDefaultTech);   if (nfaStat == NFA_STATUS_OK) {    // wait for NFA_LISTEN_DISABLED_EVT    sNfaEnableDisablePollingEvent.wait();  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               nfaStat);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } /******************************************************************************* ** ** Function:        nfcManager_resetDiscoveryTech ** ** Description:     Restores the RF tech to the state before **                  nfcManager_setDiscoveryTech was called ** ** Returns:         None. ** *******************************************************************************/ static void nfcManager_resetDiscoveryTech(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return;  tNFA_STATUS nfaStat;  LOG(DEBUG) << StringPrintf("%s : enter", __func__);   // Need listen tech routing update in routing table  // for addition of blocking bit  RoutingManager::getInstance().setEeTechRouteUpdateRequired();   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);   nfaStat = NFA_ChangeDiscoveryTech(0xFF, 0xFF, true, true, false);   if (nfaStat == NFA_STATUS_OK) {    // wait for NFA_LISTEN_DISABLED_EVT    sNfaEnableDisablePollingEvent.wait();  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               nfaStat);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } static void ncfManager_nativeEnableVendorNciNotifications(JNIEnv* env,                                                          jobject o,                                                          jboolean enable) {  if (sIsShuttingDown) return;  sEnableVendorNciNotifications = (enable == JNI_TRUE); } static jobject nfcManager_dofetchActiveNfceeList(JNIEnv* e, jobject o) {  (void)o;  if (sIsShuttingDown) return nullptr;  return NfceeManager::getInstance().getActiveNfceeList(e); } static jobject nfcManager_nativeSendRawVendorCmd(JNIEnv* env, jobject o,                                                 jint mt, jint gid, jint oid,                                                 jbyteArray payload) {  if (sIsShuttingDown) return nullptr;  LOG(DEBUG) << StringPrintf("%s : enter", __func__);  ScopedByteArrayRO payloaBytes(env, payload);  ScopedLocalRef<jclass> cls(env,                             env->FindClass(gNfcVendorNciResponseClassName));  jmethodID responseConstructor =      env->GetMethodID(cls.get(), "<init>", "(BII[B)V");   jbyte mStatus = NFA_STATUS_FAILED;  jint resGid = 0;  jint resOid = 0;  jbyteArray resPayload = nullptr;   sRawVendorCmdResponse.clear();   std::vector<uint8_t> command;  command.push_back((uint8_t)((mt << NCI_MT_SHIFT) | gid));  command.push_back((uint8_t)oid);  command.push_back((uint8_t)payloaBytes.size());  if (payloaBytes.size() > 0) {    command.insert(command.end(), &payloaBytes[0],                   &payloaBytes[payloaBytes.size()]);  }   SyncEventGuard guard(gSendRawVsCmdEvent);  mStatus = NFA_SendRawVsCommand(command.size(), command.data(),                                 sendRawVsCmdCallback);  if (mStatus == NFA_STATUS_OK) {    if (gSendRawVsCmdEvent.wait(2000) == false) {      mStatus = NFA_STATUS_FAILED;      LOG(ERROR) << StringPrintf("%s: timeout ", __func__);    }     if (mStatus == NFA_STATUS_OK && sRawVendorCmdResponse.size() > 2) {      resGid = sRawVendorCmdResponse[0] & NCI_GID_MASK;      resOid = sRawVendorCmdResponse[1];      const jsize len = static_cast<jsize>(sRawVendorCmdResponse[2]);      if (sRawVendorCmdResponse.size() >= (sRawVendorCmdResponse[2] + 3)) {        resPayload = env->NewByteArray(len);        std::vector<uint8_t> payloadVec(sRawVendorCmdResponse.begin() + 3,                                        sRawVendorCmdResponse.end());        env->SetByteArrayRegion(            resPayload, 0, len,            reinterpret_cast<const jbyte*>(payloadVec.data()));      } else {        mStatus = NFA_STATUS_FAILED;        LOG(ERROR) << StringPrintf("%s: invalid payload data", __func__);      }    } else {      mStatus = NFA_STATUS_FAILED;    }  }   LOG(DEBUG) << StringPrintf("%s : exit", __func__);  return env->NewObject(cls.get(), responseConstructor, mStatus, resGid, resOid,                        resPayload); } static void sendRawVsCmdCallback(uint8_t event, uint16_t param_len,                                 uint8_t* p_param) {  sRawVendorCmdResponse = std::vector<uint8_t>(p_param, p_param + param_len);   SyncEventGuard guard(gSendRawVsCmdEvent);  gSendRawVsCmdEvent.notifyOne(); } /* namespace android */ /***************************************************************************** ** ** JNI functions for android-4.0.1_r1 ** *****************************************************************************/ static JNINativeMethod gMethods[] = {    {"doDownload", "()Z", (void*)nfcManager_doDownload},     {"initializeNativeStructure", "()Z", (void*)nfcManager_initNativeStruc},     {"doInitialize", "()Z", (void*)nfcManager_doInitialize},     {"doSetPartialInitMode", "(I)V", (void*)nfcManager_doSetPartialInitMode},     {"doDeinitialize", "()Z", (void*)nfcManager_doDeinitialize},     {"sendRawFrame", "([B)Z", (void*)nfcManager_sendRawFrame},     {"routeAid", "([BIII)Z", (void*)nfcManager_routeAid},     {"unrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},     {"commitRouting", "()I", (void*)nfcManager_commitRouting},     {"doRegisterT3tIdentifier", "([B)I",     (void*)nfcManager_doRegisterT3tIdentifier},     {"doDeregisterT3tIdentifier", "(I)V",     (void*)nfcManager_doDeregisterT3tIdentifier},     {"getLfT3tMax", "()I", (void*)nfcManager_getLfT3tMax},     {"doEnableDiscovery", "(IZZZ[BZ)V", (void*)nfcManager_enableDiscovery},     {"doStartStopPolling", "(Z)V", (void*)nfcManager_doStartStopPolling},     {"disableDiscovery", "()V", (void*)nfcManager_disableDiscovery},     {"doSetTimeout", "(II)Z", (void*)nfcManager_doSetTimeout},     {"doGetTimeout", "(I)I", (void*)nfcManager_doGetTimeout},     {"doResetTimeouts", "()V", (void*)nfcManager_doResetTimeouts},     {"doAbort", "(Ljava/lang/String;)V", (void*)nfcManager_doAbort},     {"doSetScreenState", "(IZ)V", (void*)nfcManager_doSetScreenState},     {"doDump", "(Ljava/io/FileDescriptor;)V", (void*)nfcManager_doDump},     {"getNciVersion", "()I", (void*)nfcManager_doGetNciVersion},    {"doEnableDtaMode", "()V", (void*)nfcManager_doEnableDtaMode},    {"doDisableDtaMode", "()V", (void*)nfcManager_doDisableDtaMode},    {"doFactoryReset", "()V", (void*)nfcManager_doFactoryReset},    {"doShutdown", "()V", (void*)nfcManager_doShutdown},     {"getIsoDepMaxTransceiveLength", "()I",     (void*)nfcManager_getIsoDepMaxTransceiveLength},     {"getAidTableSize", "()I", (void*)nfcManager_getAidTableSize},     {"doSetNfcSecure", "(Z)Z", (void*)nfcManager_doSetNfcSecure},     {"doSetNfceePowerAndLinkCtrl", "(Z)V",     (void*)nfcManager_doSetNfceePowerAndLinkCtrl},     {"doSetPowerSavingMode", "(Z)Z", (void*)nfcManager_doSetPowerSavingMode},     {"getRoutingTable", "()[B", (void*)nfcManager_doGetRoutingTable},     {"getMaxRoutingTableSize", "()I",     (void*)nfcManager_doGetMaxRoutingTableSize},     {"setObserveMode", "(Z)Z", (void*)nfcManager_setObserveMode},     {"isObserveModeEnabled", "()Z", (void*)nfcManager_isObserveModeEnabled},     {"isMultiTag", "()Z", (void*)nfcManager_isMultiTag},     {"clearRoutingEntry", "(I)V", (void*)nfcManager_clearRoutingEntry},     {"setIsoDepProtocolRoute", "(I)V",     (void*)nfcManager_updateIsoDepProtocolRoute},     {"setTechnologyABFRoute", "(II)V",     (void*)nfcManager_updateTechnologyABFRoute},     {"setSystemCodeRoute", "(I)V", (void*)nfcManager_updateSystemCodeRoute},     {"setDiscoveryTech", "(II)V", (void*)nfcManager_setDiscoveryTech},     {"resetDiscoveryTech", "()V", (void*)nfcManager_resetDiscoveryTech},    {"nativeSendRawVendorCmd", "(III[B)Lcom/android/nfc/NfcVendorNciResponse;",     (void*)nfcManager_nativeSendRawVendorCmd},     {"dofetchActiveNfceeList", "()Ljava/util/Map;",     (void*)nfcManager_dofetchActiveNfceeList},     {"getProprietaryCaps", "()[B", (void*)nfcManager_getProprietaryCaps},    {"enableVendorNciNotifications", "(Z)V",     (void*)ncfManager_nativeEnableVendorNciNotifications},    {"injectNtf", "([B)V", (void*)nfcManager_injectNtf},    {"doDetectEpRemoval", "(I)Z", (void*)nfcManager_doDetectEpRemoval},    {"isRemovalDetectionInPollModeSupported", "()Z",     (void*)nfcManager_isRemovalDetectionSupported},    {"setFirmwareExitFrameTable", "([Lcom/android/nfc/ExitFrame;[B)Z",     (void*)nfcManager_setFirmwareExitFrameTable},    {"doRestartRfDiscovery", "()V", (void*)nfcManager_restartRfDiscovery}, }; /******************************************************************************* ** ** Function:        register_com_android_nfc_NativeNfcManager ** ** Description:     Regisgter JNI functions with Java Virtual Machine. **                  e: Environment of JVM. ** ** Returns:         Status of registration. ** *******************************************************************************/ int register_com_android_nfc_NativeNfcManager(JNIEnv* e) {  return jniRegisterNativeMethods(e, gNativeNfcManagerClassName, gMethods,                                  NELEM(gMethods)); } /******************************************************************************* ** ** Function:        startRfDiscovery ** ** Description:     Ask stack to start polling and listening for devices. **                  isStart: Whether to start. ** ** Returns:         None ** *******************************************************************************/ void startRfDiscovery(bool isStart) {  tNFA_STATUS status = NFA_STATUS_FAILED;   LOG(DEBUG) << StringPrintf("%s: is start=%d", __func__, isStart);  nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  status = isStart ? NFA_StartRfDiscovery() : NFA_StopRfDiscovery();  if (status == NFA_STATUS_OK) {    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_RF_DISCOVERY_xxxx_EVT    sRfEnabled = isStart;  } else {    LOG(ERROR) << StringPrintf(        "%s: Failed to start/stop RF discovery; error=0x%X", __func__, status);  }  nativeNfcTag_releaseRfInterfaceMutexLock(); } /******************************************************************************* ** ** Function:        isDiscoveryStarted ** ** Description:     Indicates whether the discovery is started. ** ** Returns:         True if discovery is started ** *******************************************************************************/ bool isDiscoveryStarted() { return sRfEnabled; } /******************************************************************************* ** ** Function:        doStartupConfig ** ** Description:     Configure the NFC controller. ** ** Returns:         None ** *******************************************************************************/ void doStartupConfig() {  // configure RF polling frequency for each technology  static tNFA_DM_DISC_FREQ_CFG nfa_dm_disc_freq_cfg;  // values in the polling_frequency[] map to members of nfa_dm_disc_freq_cfg  std::vector<uint8_t> polling_frequency;  if (NfcConfig::hasKey(NAME_POLL_FREQUENCY))    polling_frequency = NfcConfig::getBytes(NAME_POLL_FREQUENCY);  if (polling_frequency.size() == 8) {    LOG(DEBUG) << StringPrintf("%s: polling frequency", __func__);    memset(&nfa_dm_disc_freq_cfg, 0, sizeof(nfa_dm_disc_freq_cfg));    nfa_dm_disc_freq_cfg.pa = polling_frequency[0];    nfa_dm_disc_freq_cfg.pb = polling_frequency[1];    nfa_dm_disc_freq_cfg.pf = polling_frequency[2];    nfa_dm_disc_freq_cfg.pi93 = polling_frequency[3];    nfa_dm_disc_freq_cfg.pbp = polling_frequency[4];    nfa_dm_disc_freq_cfg.pk = polling_frequency[5];    nfa_dm_disc_freq_cfg.paa = polling_frequency[6];    nfa_dm_disc_freq_cfg.pfa = polling_frequency[7];    p_nfa_dm_rf_disc_freq_cfg = &nfa_dm_disc_freq_cfg;  }   // configure NFCC_CONFIG_CONTROL- NFCC allowed to manage RF configuration.  nfcManager_configNfccConfigControl(true); } /******************************************************************************* ** ** Function:        nfcManager_isNfcActive ** ** Description:     Used externaly to determine if NFC is active or not. ** ** Returns:         'true' if the NFC stack is running, else 'false'. ** *******************************************************************************/ bool nfcManager_isNfcActive() { return sIsNfaEnabled; } /******************************************************************************* ** ** Function:        startStopPolling ** ** Description:     Start or stop polling. **                  isStartPolling: true to start polling; false to stop *polling. ** ** Returns:         None. ** *******************************************************************************/ void startStopPolling(bool isStartPolling) {  tNFA_STATUS status = NFA_STATUS_FAILED;  uint8_t discovry_param = 0;  LOG(DEBUG) << StringPrintf("%s: enter; isStart=%u", __func__, isStartPolling);   if (NFC_GetNCIVersion() >= NCI_VERSION_2_0) {    SyncEventGuard guard(gNfaSetConfigEvent);    if (isStartPolling) {      discovry_param =          NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;    } else {      discovry_param =          NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_DISABLE_MASK;    }    status = NFA_SetConfig(NCI_PARAM_ID_CON_DISCOVERY_PARAM,                           NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);    if (status == NFA_STATUS_OK) {      gNfaSetConfigEvent.wait();    } else {      LOG(ERROR) << StringPrintf("%s: Failed to update CON_DISCOVER_PARAM",                                 __FUNCTION__);    }  } else {    startRfDiscovery(false);    if (isStartPolling)      startPolling_rfDiscoveryDisabled(0);    else      stopPolling_rfDiscoveryDisabled();    startRfDiscovery(true);  }  LOG(DEBUG) << StringPrintf("%s: exit", __func__); } static tNFA_STATUS startPolling_rfDiscoveryDisabled(    tNFA_TECHNOLOGY_MASK tech_mask) {  tNFA_STATUS stat = NFA_STATUS_FAILED;   if (tech_mask == 0)    tech_mask =        NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  LOG(DEBUG) << StringPrintf("%s: enable polling", __func__);  stat = NFA_EnablePolling(tech_mask);  if (stat == NFA_STATUS_OK) {    LOG(DEBUG) << StringPrintf("%s: wait for enable event", __func__);    sPollingEnabled = true;    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_ENABLED_EVT  } else {    LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X", __func__,                               stat);  }  nativeNfcTag_releaseRfInterfaceMutexLock();   return stat; } static tNFA_STATUS stopPolling_rfDiscoveryDisabled() {  tNFA_STATUS stat = NFA_STATUS_FAILED;   nativeNfcTag_acquireRfInterfaceMutexLock();  SyncEventGuard guard(sNfaEnableDisablePollingEvent);  LOG(DEBUG) << StringPrintf("%s: disable polling", __func__);  stat = NFA_DisablePolling();  if (stat == NFA_STATUS_OK) {    sPollingEnabled = false;    sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_DISABLED_EVT  } else {    LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X", __func__,                               stat);  }  nativeNfcTag_releaseRfInterfaceMutexLock();   return stat; } static jboolean nfcManager_doSetPowerSavingMode(JNIEnv* e, jobject o,                                                bool flag) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << StringPrintf("%s: enter; ", __func__);  uint8_t cmd[] = {(NCI_MT_CMD << NCI_MT_SHIFT) | NCI_GID_PROP,                   NCI_MSG_PROP_ANDROID, NCI_ANDROID_POWER_SAVING_PARAM_SIZE,                   NCI_ANDROID_POWER_SAVING,                   NCI_ANDROID_POWER_SAVING_PARAM_DISABLE};  cmd[4] = flag ? NCI_ANDROID_POWER_SAVING_PARAM_ENABLE                : NCI_ANDROID_POWER_SAVING_PARAM_DISABLE;   SyncEventGuard guard(gNfaVsCommand);  tNFA_STATUS status =      NFA_SendRawVsCommand(sizeof(cmd), cmd, nfaSendRawVsCmdCallback);  if (status == NFA_STATUS_OK) {    gNfaVsCommand.wait();  } else {    LOG(ERROR) << StringPrintf("%s: Failed to set power-saving mode", __func__);    gVSCmdStatus = NFA_STATUS_FAILED;  }  return gVSCmdStatus == NFA_STATUS_OK; } static jbyteArray nfcManager_getProprietaryCaps(JNIEnv* e, jobject o) {  if (sIsShuttingDown) return nullptr;  LOG(DEBUG) << StringPrintf("%s: enter; ", __func__);  uint8_t cmd[] = {(NCI_MT_CMD << NCI_MT_SHIFT) | NCI_GID_PROP,                   NCI_MSG_PROP_ANDROID, NCI_ANDROID_GET_CAPS_PARAM_SIZE,                   NCI_ANDROID_GET_CAPS};  SyncEventGuard guard(gNfaVsCommand);   tNFA_STATUS status = NFA_SendRawVsCommand(sizeof(cmd), cmd, nfaVSCallback);  if (status == NFA_STATUS_OK) {    if (!gNfaVsCommand.wait(1000)) {      LOG(ERROR) << StringPrintf(          "%s: Timed out waiting for a response to get caps ",          __FUNCTION__);      gVSCmdStatus = NFA_STATUS_FAILED;    }  } else {    LOG(ERROR) << StringPrintf("%s: Failed to get caps", __func__);    gVSCmdStatus = NFA_STATUS_FAILED;  }  CHECK(e);  jbyteArray rtJavaArray = e->NewByteArray(gCaps.size());  CHECK(rtJavaArray);  e->SetByteArrayRegion(rtJavaArray, 0, gCaps.size(), (jbyte*)gCaps.data());  return rtJavaArray; } static jboolean nfcManager_setFirmwareExitFrameTable(JNIEnv* env, jobject o,                                                     jobjectArray exit_frames,                                                     jbyteArray timeout) {  if (sIsShuttingDown) return false;  LOG(DEBUG) << __func__ << ": Setting firmware exit frame table";  std::vector<uint8_t> command;  command.push_back(NCI_ANDROID_SET_PASSIVE_OBSERVER_EXIT_FRAME);   // TODO(b/380455428)  // Support more than 5 exit frames if firmware allows it. If we do so, might need to send second  // NCI command if one is too large.  uint8_t more = 0x00;  command.push_back(more);   uint8_t timeout_len = env->GetArrayLength(timeout);  auto* timeout_arr = (uint8_t*)env->GetByteArrayElements(timeout, nullptr);   for (int i = 0; i < timeout_len; ++i) {    command.push_back(timeout_arr[i]);  }  env->ReleaseByteArrayElements(timeout, (jbyte*)timeout_arr, JNI_ABORT);   uint8_t num_exit_frames = env->GetArrayLength(exit_frames);  if (num_exit_frames > 5) {      LOG(INFO)        << "Truncating exit frame table to 5 frames so it fits in a single NCI command. "        << "Original size was " << num_exit_frames;      num_exit_frames = 5;  }  command.push_back(num_exit_frames);   if (num_exit_frames > 0) {    jobject exit_frame = env->GetObjectArrayElement(exit_frames, 0);    jclass clazz = env->GetObjectClass(exit_frame);    jmethodID is_prefix_allowed =        env->GetMethodID(clazz, "isPrefixMatchingAllowed", "()Z");    jmethodID get_data = env->GetMethodID(clazz, "getData", "()[B");    jmethodID get_data_mask = env->GetMethodID(clazz, "getDataMask", "()[B");    jmethodID get_tech = env->GetMethodID(clazz, "getNfcTech", "()I");    jmethodID get_power_state = env->GetMethodID(clazz, "getPowerState", "()I");     for (int i = 0; i < num_exit_frames; ++i) {      jobject frame = env->GetObjectArrayElement(exit_frames, i);       uint8_t qualifier_type = 0x00;      if (env->CallBooleanMethod(frame, is_prefix_allowed)) {        qualifier_type |= 0b00010000;      }      qualifier_type |= env->CallIntMethod(frame, get_tech);      command.push_back(qualifier_type);       uint8_t power_state = env->CallIntMethod(frame, get_power_state);       jbyteArray data = (jbyteArray)env->CallObjectMethod(frame, get_data);      uint8_t data_len = env->GetArrayLength(data);      auto* data_arr = (uint8_t*)env->GetByteArrayElements(data, nullptr);       jbyteArray data_mask =          (jbyteArray)env->CallObjectMethod(frame, get_data_mask);      uint8_t data_mask_len = env->GetArrayLength(data_mask);      auto* data_mask_arr =          (uint8_t*)env->GetByteArrayElements(data_mask, nullptr);       uint8_t value_len = 1 + data_len + data_mask_len;       command.push_back(value_len);      command.push_back(power_state);       for (int j = 0; j < data_len; ++j) {        command.push_back(data_arr[j]);      }      for (int j = 0; j < data_mask_len; ++j) {        command.push_back(data_mask_arr[j]);      }      env->ReleaseByteArrayElements(data, (jbyte*)data_arr, JNI_ABORT);      env->ReleaseByteArrayElements(data_mask, (jbyte*)data_mask_arr,                                    JNI_ABORT);    }  }     bool reenableDiscovery = false;    if (sRfEnabled) {      startRfDiscovery(false);      reenableDiscovery = true;    }     // TODO make helper to send single command and wait on response    {        SyncEventGuard guard(gNfaVsCommand);        tNFA_STATUS status = NFA_SendVsCommand(NCI_MSG_PROP_ANDROID, command.size(),                                               command.data(), nfaVSCallback);         if (status == NFA_STATUS_OK) {            if (!gNfaVsCommand.wait(1000)) {                LOG(ERROR) << StringPrintf(                        "%s: Timed out waiting for a response to set exit frame table ",                        __FUNCTION__);                gVSCmdStatus = NFA_STATUS_FAILED;            }        } else {            LOG(DEBUG) << StringPrintf("%s: Failed to set exit frame table",                                       __FUNCTION__);            gVSCmdStatus = NFA_STATUS_FAILED;        }    }     if (reenableDiscovery) {        startRfDiscovery(true);    }     return gVSCmdStatus == NFA_STATUS_OK; } /******************************************************************************* ** ** Function:        nfcManager_restartRfDiscovery ** Description:     Restarts RF discovery ** **                  e: JVM environment. **                  o: Java object. ** *******************************************************************************/ static void nfcManager_restartRfDiscovery(JNIEnv*, jobject) {  if (sIsShuttingDown) return;  if (sRfEnabled) {    android::startRfDiscovery(false);  }  android::startRfDiscovery(true); } } /* namespace android */ 分析native_nfc_manager的主要作用，他是怎么调用hal层的









已深度思考（用时 47 秒）



我们分析的是 `com_android_nfc_NativeNfcManager.cpp` 文件，它属于 Android NFC 栈的 JNI 层，负责 Java 层与本地 C++ 代码之间的交互。这个文件实现了 `NativeNfcManager` 类，提供了 NFC 功能的初始化和控制接口。

 主要作用：

1. 提供 NFC 栈的初始化和去初始化功能。
2. 控制 NFC 发现过程（启动/停止轮询和监听）。
3. 管理 NFC 路由配置（AID 路由、协议路由等）。
4. 处理 NFC 事件回调（设备发现、激活、数据交换等）。
5. 提供其他 NFC 控制功能，如设置屏幕状态、设置省电模式等。

 如何调用 HAL 层：

 在 Android 的 NFC 架构中，HAL 层（硬件抽象层）由 `libnfc-nci` 实现，它封装了与 NFC 控制器的通信。JNI 层通过调用 `libnfc-nci` 提供的 API 来操作 NFC 控制器。

 具体分析：

1. **初始化过程**：

​    \- `nfcManager_doInitialize` 函数负责初始化 NFC 栈。它首先调用 `NfcAdaptation::GetInstance().Initialize()` 来初始化适配层（Adaptation），该层是 HAL 的封装。

​    \- 然后，它调用 `NFA_Init` 或 `NFA_Partial_Init`（根据模式）来初始化 NFA（NFC 协议栈适配层）。

​    \- 接着，注册回调函数（`nfaDeviceManagementCallback` 和 `nfaConnectionCallback`），这些回调用于接收来自底层的事件。

​    \- 最后，调用 `NFA_Enable` 来启用 NFC 栈。这个函数会通过 HAL 层与 NFC 控制器通信。

2. **去初始化过程**：

​    \- `nfcManager_doDeinitialize` 函数负责去初始化。它调用 `NFA_Disable` 和 `NFA_DisableDtamode`（如果启用 DTA 模式）来停止 NFC 功能，然后调用 `NfcAdaptation::GetInstance().Finalize()` 清理资源。

3. **发现过程控制**：

​    \- `nfcManager_enableDiscovery` 和 `nfcManager_disableDiscovery` 分别用于启动和停止发现过程（轮询和监听）。

​    \- 这些函数调用 `NFA_EnablePolling`、`NFA_DisablePolling`、`NFA_StartRfDiscovery` 和 `NFA_StopRfDiscovery` 等函数，这些函数最终通过 HAL 层发送命令给 NFC 控制器。

4. **路由配置**：

​    \- 路由配置（如 AID 路由、协议路由）通过 `RoutingManager` 类管理。例如，`nfcManager_routeAid` 函数调用 `RoutingManager::getInstance().addAidRouting`，后者会调用 `NFA_EeAddAidRouting` 或 `NFA_CeRegisterAidOnDH` 等函数，这些函数通过 HAL 配置 NFC 控制器的路由表。

5. **事件处理**：

​    \- 当底层（HAL）有事件发生时（如发现标签、激活事件等），这些事件会通过回调函数（如 `nfaDeviceManagementCallback` 和 `nfaConnectionCallback`）传递到 JNI 层，然后 JNI 层再通过 JNI 调用传递到 Java 层。

6. **与 HAL 交互的其他例子**：

​    \- 设置屏幕状态：`nfcManager_doSetScreenState` 调用 `NFA_SetPowerSubStateForScreenState` 和 `NFA_SetConfig` 来配置 NFC 控制器在不同屏幕状态下的行为。

​    \- 发送原始帧：`nfcManager_sendRawFrame` 调用 `NFA_SendRawFrame`，该函数通过 HAL 将原始数据发送到 NFC 控制器。

 总结：

 `com_android_nfc_NativeNfcManager.cpp` 作为 JNI 层，它通过调用 `libnfc-nci` 提供的 NFA_* 系列函数（这些函数在 `nfa_api.h` 等头文件中声明）来操作 NFC 控制器。而 `libnfc-nci` 库则实现了与具体硬件平台相关的 HAL 层，通过 I2C、SPI 或 UART 等与 NFC 控制器芯片通信。

 因此，JNI 层并不直接与硬件交互，而是通过 `libnfc-nci` 库（即 HAL 实现）来间接控制硬件。

`native_nfc_manager.cpp` 是 Android NFC 栈的核心 JNI 层实现，主要负责协调 Java 框架层与本地 NFC 协议栈（如 Broadcom NCI 栈）的交互。其核心作用及 HAL 调用机制如下：

------

### **一、核心功能与作用**

1. **NFC 栈生命周期管理**：
   - `doInitialize()`：初始化 NFC 适配层（GKI/NCI 任务），注册 HAL 入口函数，启用 NFA 协议栈。
   - `doDeinitialize()`：关闭 RF 发现，注销回调，释放 NFC 协议栈资源。
2. **RF 发现控制**：
   - `enableDiscovery()`：配置轮询技术（A/B/F/V 等），启动 RF 发现流程。
   - `disableDiscovery()`：停止 RF 发现和轮询。
3. **路由管理**：
   - `routeAid()`/`unrouteAid()`：管理 AID 到 SE（eSE/UICC）的路由规则。
   - `commitRouting()`：提交路由表到 NFCC 控制器。
4. **数据交换**：
   - `sendRawFrame()`：透传原始数据帧（ISO-DEP/Tag 通信）。
   - 处理标签激活/数据交换事件（`NFA_ACTIVATED_EVT`, `NFA_DATA_EVT`）。
5. **电源与屏幕状态管理**：
   - `doSetScreenState()`：根据屏幕状态（ON/OFF/LOCKED）动态调整 RF 策略。
   - `doSetPowerSavingMode()`：配置 NFCC 低功耗模式。
6. **诊断与调试**：
   - `doDump()`：输出 NFCC 内部状态。
   - `getProprietaryCaps()`：获取厂商私有能力。

------

### **二、HAL 层调用机制**

JNI 层通过 **NfcAdaptation 适配层** 访问 HAL，具体流程如下：

#### **1. 初始化阶段调用 HAL**

cpp



复制



下载

```
// 初始化 HAL 适配层
NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
theInstance.Initialize(); // 启动 GKI/NCI 任务

// 获取 HAL 入口函数表并初始化协议栈
tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();
NFA_Init(halFuncEntries); // 将 HAL 函数表传入协议栈
```

- **关键结构体**：`tHAL_NFC_ENTRY` 包含 HAL 函数指针（`open()`, `write()`, `ioctl()` 等）。
- **HAL 实现**：厂商在 `libnfc-nci` 中实现 `hal_nfc_*.so`，提供硬件操作接口（如 I2C 读写）。

#### **2. RF 控制命令下发示例**

cpp



复制



下载

```
// 启用轮询（调用协议栈 API）
NFA_EnablePolling(tech_mask);

// 协议栈通过 HAL 下发命令
tNFA_STATUS status = NFA_SendRawVsCommand(cmd_len, cmd, callback);
```

- **路径**：`NFA_EnablePolling()` → `NCI_BuildHeader()` → `halFuncEntries->write()` 发送 NCI 命令到驱动。

#### **3. 事件上传路径**

cpp



复制



下载

```
// HAL 接收中断数据
static void nfc_stack_callback(uint8_t event, uint16_t len, uint8_t* data) {
    nfaDeviceManagementCallback(event, (tNFA_DM_CBACK_DATA*)data); // JNI 回调
}

// 注册回调到 HAL
halFuncEntries->set_callback(nfc_stack_callback);
```

- **驱动层**：通过中断上报数据 → HAL 的 `read()` 线程解析 → 调用 `nfc_stack_callback()` 通知协议栈。

------

### **三、关键交互流程**

#### **标签发现与激活流程**

图表

代码







下载

NFCC DriverNFC HALNFA Stacknative_nfc_managerNFC ServiceNFCC DriverNFC HALNFA Stacknative_nfc_managerNFC ServiceenableDiscovery(TECH_MASK)NFA_EnablePolling(TECH_MASK)hal.write(NCI_CMD_RF_DISCOVER)I2C_write(cmd)IRQ (发现标签)nfc_stack_callback(NFA_DISC_RESULT_EVT)nfaConnectionCallback(NFA_ACTIVATED_EVT)notifyTagDiscovered()

#### **路由配置流程**

cpp



复制



下载

```
// Java 层设置 AID 路由
NfcService.routeAidToSecureElement(aid, SE_ID);

// JNI 层提交到 NFCC
RoutingManager::getInstance().addAidRouting(aid_buf, aid_len, route);
RoutingManager::commitRouting(); // 触发 NFA_EeUpdateNow()
```

------

### **四、厂商定制扩展**

1. **私有命令支持**：
   - `nativeSendRawVendorCmd()`：透传厂商专用 NCI 命令（如 `NCI_MSG_PROP_ANDROID`）。
2. **诊断接口**：
   - `injectNtf()`：注入测试用 NFCC 通知。
3. **Observe Mode**：
   - `setObserveMode()`：配置无卡模拟监听模式（专有技术）。

------

### **五、关键设计特点**

1. **同步事件机制**：
   使用 `SyncEvent` 等待异步操作完成（如 `sNfaEnableEvent` 等待 NFA 启用）。
2. **多协议标签处理**：
   通过 `NfcTag::selectFirstTag()` 处理多标签碰撞。
3. **电源管理联动**：
   屏幕关闭时自动停用轮询（`NFA_SCREEN_STATE_OFF_LOCKED`）。

> **总结**：`native_nfc_manager` 是 Android NFC 的“中枢神经”，通过 **NfcAdaptation 抽象层** 桥接 Java 框架与厂商 HAL，管理协议栈生命周期、RF 控制、路由策略及事件分发，同时为厂商提供私有扩展入口。









/****************************************************************************** * *  Copyright 2018 NXP * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *  http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * ******************************************************************************/ #define LOG_TAG "SpiAddaptation" #include "NfcAdaptation.h" #include <android/hardware/nfc/1.0/types.h> #include <hwbinder/ProcessState.h> #include <log/log.h> #include <pthread.h> using android::sp; using android::hardware::hidl_vec; using android::hardware::Return; using android::hardware::Void; using vendor::nxp::nxpnfc::V1_0::INxpNfc; sp<INxpNfc> NfcAdaptation::mHalNxpNfc = nullptr; ThreadMutex NfcAdaptation::sIoctlLock; NfcAdaptation* NfcAdaptation::mpInstance = NULL; ThreadMutex NfcAdaptation::sLock; int omapi_status; extern bool ese_debug_enabled; void NfcAdaptation::Initialize() {  const char* func = "NfcAdaptation::Initialize";  ALOGD_IF(ese_debug_enabled, "%s", func);  if (mHalNxpNfc != nullptr) return;  mHalNxpNfc = INxpNfc::tryGetService();  LOG_FATAL_IF(mHalNxpNfc == nullptr, "Failed to retrieve the NXP NFC HAL!");  if (mHalNxpNfc != nullptr) {    ALOGD_IF(ese_debug_enabled, "%s: INxpNfc::getService() returned %p (%s)",             func, mHalNxpNfc.get(),             (mHalNxpNfc->isRemote() ? "remote" : "local"));  }  ALOGD_IF(ese_debug_enabled, "%s: exit", func); } /******************************************************************************* ** ** Function:    NfcAdaptation::GetInstance() ** ** Description: access class singleton ** ** Returns:     pointer to the singleton object ** *******************************************************************************/ NfcAdaptation& NfcAdaptation::GetInstance() {  AutoThreadMutex a(sLock);   if (!mpInstance) mpInstance = new NfcAdaptation;  return *mpInstance; } /******************************************************************************* ** ** Function:    ThreadMutex::ThreadMutex() ** ** Description: class constructor ** ** Returns:     none ** *******************************************************************************/ ThreadMutex::ThreadMutex() {  pthread_mutexattr_t mutexAttr;   pthread_mutexattr_init(&mutexAttr);  pthread_mutex_init(&mMutex, &mutexAttr);  pthread_mutexattr_destroy(&mutexAttr); } /******************************************************************************* ** ** Function:    ThreadMutex::~ThreadMutex() ** ** Description: class destructor ** ** Returns:     none ** *******************************************************************************/ ThreadMutex::~ThreadMutex() { pthread_mutex_destroy(&mMutex); } /******************************************************************************* ** ** Function:    AutoThreadMutex::AutoThreadMutex() ** ** Description: class constructor, automatically lock the mutex ** ** Returns:     none ** *******************************************************************************/ AutoThreadMutex::AutoThreadMutex(ThreadMutex& m) : mm(m) { mm.lock(); } /******************************************************************************* ** ** Function:    AutoThreadMutex::~AutoThreadMutex() ** ** Description: class destructor, automatically unlock the mutex ** ** Returns:     none ** *******************************************************************************/ AutoThreadMutex::~AutoThreadMutex() { mm.unlock(); } /******************************************************************************* ** ** Function:    ThreadMutex::lock() ** ** Description: lock kthe mutex ** ** Returns:     none ** *******************************************************************************/ void ThreadMutex::lock() { pthread_mutex_lock(&mMutex); } /******************************************************************************* ** ** Function:    ThreadMutex::unblock() ** ** Description: unlock the mutex ** ** Returns:     none ** *******************************************************************************/ void ThreadMutex::unlock() { pthread_mutex_unlock(&mMutex); } /******************************************************************************* ** ** Function:    NfcAdaptation::NfcAdaptation() ** ** Description: class constructor ** ** Returns:     none ** *******************************************************************************/ NfcAdaptation::NfcAdaptation() { mCurrentIoctlData = NULL; } /******************************************************************************* ** ** Function:    NfcAdaptation::~NfcAdaptation() ** ** Description: class destructor ** ** Returns:     none ** *******************************************************************************/ NfcAdaptation::~NfcAdaptation() { mpInstance = NULL; } /******************************************************************************* ** ** Function:    IoctlCallback ** ** Description: Callback from HAL stub for IOCTL api invoked. **              Output data for IOCTL is sent as argument ** ** Returns:     None. ** *******************************************************************************/ void IoctlCallback(::android::hardware::nfc::V1_0::NfcData outputData) {  const char* func = "IoctlCallback";  ese_nxp_ExtnOutputData_t* pOutData =      (ese_nxp_ExtnOutputData_t*)&outputData[0];  ALOGD_IF(ese_debug_enabled, "%s Ioctl Type=%lu", func,           (unsigned long)pOutData->ioctlType);  NfcAdaptation* pAdaptation = (NfcAdaptation*)pOutData->context;  /*Output Data from stub->Proxy is copied back to output data   * This data will be sent back to libnfc*/  memcpy(&pAdaptation->mCurrentIoctlData->out, &outputData[0],         sizeof(ese_nxp_ExtnOutputData_t));  ALOGD_IF(ese_debug_enabled, "%s Ioctl Type value[0]:0x%x and value[3] 0x%x",           func, pOutData->data.nxpRsp.p_rsp[0],           pOutData->data.nxpRsp.p_rsp[3]);  omapi_status = pOutData->data.nxpRsp.p_rsp[3]; } /******************************************************************************* ** ** Function:    NfcAdaptation::HalIoctl ** ** Description: Calls ioctl to the Nfc driver. **              If called with a arg value of 0x01 than wired access requested, **              status of the requst would be updated to p_data. **              If called with a arg value of 0x00 than wired access will be **              released, status of the requst would be updated to p_data. **              If called with a arg value of 0x02 than current p61 state would *be **              updated to p_data. ** ** Returns:     -1 or 0. ** *******************************************************************************/ ESESTATUS NfcAdaptation::HalIoctl(long arg, void* p_data) {  const char* func = "NfcAdaptation::HalIoctl";  ::android::hardware::nfc::V1_0::NfcData data;  ESESTATUS result = ESESTATUS_FAILED;  AutoThreadMutex a(sIoctlLock);  ese_nxp_IoctlInOutData_t* pInpOutData = (ese_nxp_IoctlInOutData_t*)p_data;  ALOGD_IF(ese_debug_enabled, "%s arg=%ld", func, arg);  pInpOutData->inp.context = &NfcAdaptation::GetInstance();  NfcAdaptation::GetInstance().mCurrentIoctlData = pInpOutData;  data.setToExternal((uint8_t*)pInpOutData, sizeof(ese_nxp_IoctlInOutData_t));  if (mHalNxpNfc != nullptr) {    mHalNxpNfc->ioctl(arg, data, IoctlCallback);  }  ALOGD_IF(ese_debug_enabled, "%s Ioctl Completed for Type=%lu", func,           (unsigned long)pInpOutData->out.ioctlType);  result = (ESESTATUS)(pInpOutData->out.result);  return result; } /******************************************************************************* ** ** Function:    ThreadCondVar::ThreadCondVar() ** ** Description: class constructor ** ** Returns:     none ** *******************************************************************************/ ThreadCondVar::ThreadCondVar() {  pthread_condattr_t CondAttr;   pthread_condattr_init(&CondAttr);  pthread_cond_init(&mCondVar, &CondAttr);   pthread_condattr_destroy(&CondAttr); } /******************************************************************************* ** ** Function:    ThreadCondVar::~ThreadCondVar() ** ** Description: class destructor ** ** Returns:     none ** *******************************************************************************/ ThreadCondVar::~ThreadCondVar() { pthread_cond_destroy(&mCondVar);  根据nfcadaption，主要介绍其功能和定位









已深度思考（用时 44 秒）



NfcAdaptation是NFC协议栈与硬件抽象层（HAL）之间的适配层，它负责桥接高层NFC协议栈（如NFA）和底层硬件驱动。该文件主要针对NXP的NFC芯片实现，通过HIDL（HAL Interface Definition Language）与NXP的NFC HAL服务进行通信。

\### 主要功能

1. **初始化HAL服务**：

   \- 在`Initialize()`函数中，尝试获取NXP的NFC HAL服务（`INxpNfc`接口）。如果成功获取，则保存该服务的引用。

   \- 使用`tryGetService()`来获取HAL服务实例。

2. **单例模式**：

   \- 通过`GetInstance()`提供全局唯一的`NfcAdaptation`实例（单例模式），确保整个系统中只有一个适配器实例。

3. **线程同步**：

   \- 使用`ThreadMutex`和`AutoThreadMutex`实现互斥锁，确保多线程环境下的安全访问。

   \- `ThreadMutex`封装了POSIX互斥锁，提供`lock()`和`unlock()`方法。

   \- `AutoThreadMutex`利用RAII（资源获取即初始化）机制，在构造时加锁，析构时解锁，避免忘记解锁。

4. **IOCTL通信**：

   \- `HalIoctl`函数是核心，用于向底层HAL发送控制命令（ioctl）。

   \- 它接收一个命令参数（`arg`）和一个数据指针（`p_data`），该数据指针指向输入/输出结构（`ese_nxp_IoctlInOutData_t`）。

   \- 将输入数据封装成HIDL的`NfcData`类型（字节数组），然后调用HAL的`ioctl`方法。

   \- 通过回调函数`IoctlCallback`接收HAL返回的结果，并将结果复制回输出数据结构。

5. **回调处理**：

   \- `IoctlCallback`函数在HAL完成ioctl操作后被调用，将输出数据从HAL传递回适配层，并更新到原始的数据结构中。

\### 定位

\- **承上启下**：作为NFC协议栈（如libnfc-nci）与NXP NFC HAL之间的桥梁，将高层的NFC操作转化为具体的硬件控制命令。

\- **硬件抽象**：封装了与具体硬件（NXP NFC芯片）的交互细节，向上提供统一的接口（如`HalIoctl`），使上层无需关心底层硬件差异。

\- **异步通信处理**：通过回调机制处理HAL的异步响应，确保ioctl调用可以非阻塞地等待结果。

\### 关键代码解析

1. **初始化HAL**：

   \```cpp

   void NfcAdaptation::Initialize() {

​     if (mHalNxpNfc != nullptr) return;

​     mHalNxpNfc = INxpNfc::tryGetService(); // 获取HAL服务

​     LOG_FATAL_IF(mHalNxpNfc == nullptr, "Failed to retrieve the NXP NFC HAL!");

   }

   \```

2. **IOCTL调用**：

   \```cpp

   ESESTATUS NfcAdaptation::HalIoctl(long arg, void* p_data) {

​     // ... 准备数据

​     data.setToExternal((uint8_t*)pInpOutData, sizeof(ese_nxp_IoctlInOutData_t));

​     if (mHalNxpNfc != nullptr) {

​       mHalNxpNfc->ioctl(arg, data, IoctlCallback); // 调用HAL的ioctl

​     }

​     // 等待回调处理结果

​     return result;

   }

   \```

3. **回调函数**：

   \```cpp

   void IoctlCallback(::android::hardware::nfc::V1_0::NfcData outputData) {

​     // 从outputData中提取结果，复制回适配层的数据结构

​     memcpy(&pAdaptation->mCurrentIoctlData->out, &outputData[0], ...);

   }

   \```

\### 总结

`NfcAdaptation`是NXP NFC解决方案中负责与HAL交互的核心适配层，它通过HIDL接口`INxpNfc`与底层驱动通信，主要提供硬件控制命令（ioctl）的转发和结果回调处理。其设计确保了协议栈与硬件的解耦，同时通过线程同步机制保证多线程安全。

NfcAdaptation 是 Android NFC 栈中的硬件抽象层（HAL）适配器，主要功能是桥接 NFC 协议栈（如 libnfc-nci）与具体的 NFC 硬件驱动。以下是其核心功能和定位的详细分析：

------

### **一、核心功能**

#### 1. **HAL 服务连接管理**

- **HAL 服务绑定**：
  - 通过 `INxpNfc::tryGetService()` 获取 NXP 专属的 NFC HAL 服务
  - 单例模式确保全局唯一访问点 (`GetInstance()`)
- **服务状态检查**：
  - 检测 HAL 服务是否可用（`mHalNxpNfc != nullptr`）
  - 区分本地/远程服务（`isRemote()` 判断）

#### 2. **硬件控制命令透传**

- **IOCTL 命令转发**：
  - `HalIoctl()` 将上层 IOCTL 请求转发给 HAL
  - 支持参数传递：
    - `arg`：控制命令类型（如电源管理、安全状态）
    - `p_data`：输入/输出数据结构指针
- **异步回调机制**：
  - `IoctlCallback()` 处理 HAL 返回的硬件响应
  - 数据回传：将 HAL 输出数据拷贝回协议栈缓冲区

#### 3. **线程安全管理**

- **互斥锁机制**：
  - `ThreadMutex` 封装 pthread 互斥锁
  - `AutoThreadMutex` 实现 RAII 模式（构造加锁/析构解锁）
- **临界区保护**：
  - `sIoctlLock` 确保多线程下 IOCTL 操作原子性
  - 防止并发访问导致的状态不一致

#### 4. **硬件适配抽象**

- **厂商定制扩展**：
  - 为 NXP 专属功能（如 eSE 安全操作）提供通路
  - 封装硬件差异（如 I2C 通信细节）

------

### **二、在 NFC 栈中的定位**

#### **架构层级关系**

图表

代码







下载

<svg role="graphics-document document" viewBox="-9.450000000000001 -9.450000000000001 207.89999999999998 496.9" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-39" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(265.881px, 0px) scale(0.292869);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-39_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-39_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-39_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-39_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-39_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-39_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-39_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M94.5,86L94.5,92.167C94.5,98.333,94.5,110.667,94.5,122.333C94.5,134,94.5,145,94.5,150.5L94.5,156"></path><path marker-end="url(#mermaid-svg-39_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M94.5,214L94.5,220.167C94.5,226.333,94.5,238.667,94.5,250.333C94.5,262,94.5,273,94.5,278.5L94.5,284"></path><path marker-end="url(#mermaid-svg-39_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M94.5,342L94.5,348.167C94.5,354.333,94.5,366.667,94.5,378.333C94.5,390,94.5,401,94.5,406.5L94.5,412"></path></g><g class="edgeLabels"><g transform="translate(94.5, 123)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">调用</p></span></div></foreignObject></g></g><g transform="translate(94.5, 251)" class="edgeLabel"><g transform="translate(-34.53472137451172, -12)" class="label"><foreignObject height="24" width="69.06944274902344"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">HIDL 通信</p></span></div></foreignObject></g></g><g transform="translate(94.5, 379)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">驱动交互</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(94.5, 47)" id="flowchart-A-0" class="node default"><rect height="78" width="141" y="-39" x="-70.5" style="" class="basic label-container"></rect><g transform="translate(-40.5, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="81"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NFC 协议栈<br>libnfc-nci</p></span></div></foreignObject></g></g><g transform="translate(94.5, 187)" id="flowchart-B-1" class="node default"><rect height="54" width="162.70833587646484" y="-27" x="-81.35416793823242" style="" class="basic label-container"></rect><g transform="translate(-51.35416793823242, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="102.70833587646484"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NfcAdaptation</p></span></div></foreignObject></g></g><g transform="translate(94.5, 315)" id="flowchart-C-3" class="node default"><rect height="54" width="153.58333587646484" y="-27" x="-76.79166793823242" style="" class="basic label-container"></rect><g transform="translate(-46.79166793823242, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="93.58333587646484"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NXP NFC HAL</p></span></div></foreignObject></g></g><g transform="translate(94.5, 443)" id="flowchart-D-5" class="node default"><rect height="54" width="173" y="-27" x="-86.5" style="" class="basic label-container"></rect><g transform="translate(-56.5, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="113"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NFC 控制器硬件</p></span></div></foreignObject></g></g></g></g></g></svg>

#### **核心角色**

1. **协议栈与硬件的桥梁**：
   - 将通用 NFC 操作（如 RF 控制）翻译为厂商专属命令
   - 屏蔽不同芯片平台（NXP/Broadcom）的差异
2. **异步通信枢纽**：
   - 管理 HAL 的异步响应回调
   - 同步转异步：阻塞式 IOCTL 调用 → 非阻塞 HAL 响应
3. **资源访问仲裁者**：
   - 通过锁机制序列化硬件访问
   - 防止多线程并发操作导致硬件状态混乱

------

### **三、关键流程解析**

#### **IOCTL 命令执行流程**

图表

代码







下载

NfcDriverNxpHalNfcAdaptationProtocolStackNfcDriverNxpHalNfcAdaptationProtocolStackHalIoctl(arg, p_data)ioctl(arg, data)硬件命令下发硬件响应IoctlCallback(outputData)结果写入 p_data->out

#### **设计特点**

1. **上下文保持**：
   - `pInpOutData->inp.context` 保存适配器实例指针
   - 确保回调中能定位原始请求
2. **零拷贝优化**：
   - `setToExternal()` 直接引用协议栈内存
   - 避免数据传输开销
3. **错误隔离**：
   - 返回 `ESESTATUS` 明确操作结果
   - 日志标记硬件错误点 (`ALOGD_IF`)

------

### **四、典型应用场景**

1. **eSE 安全操作**：
   - 传输 APDU 命令到安全芯片
   - 管理 eSE 电源状态
2. **RF 配置**：
   - 调整天线参数
   - 切换低功耗模式
3. **诊断调试**：
   - 读取硬件寄存器
   - 注入测试指令

------

### **五、总结**

**NfcAdaptation 的本质是 Android NFC 栈的硬件抽象层代理**，其核心价值在于：

- 🛡️ **提供统一的硬件访问接口**：封装厂商（NXP）专属实现细节
- ⚡ **实现高效异步通信**：通过回调机制解耦阻塞操作
- 🔒 **确保线程安全**：通过锁机制保护硬件状态一致性
- 🔌 **支持扩展性**：为芯片定制功能提供开放通路

作为协议栈与物理硬件的“中间人”，它使 Android NFC 框架能无缝兼容不同厂商的 NFC 控制器芯片，是实现平台可移植性的关键组件。