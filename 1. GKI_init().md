/****************************************************************************** * *  Copyright (C) 1999-2012 Broadcom Corporation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at: * *  http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. * ******************************************************************************/ #include <android-base/logging.h> #include <android-base/stringprintf.h> #include <errno.h> #include <malloc.h> #include <pthread.h> /* must be 1st header defined  */ #include "gki_int.h" using android::base::StringPrintf; /* Temp android logging...move to android tgt config file */ #ifndef LINUX_NATIVE #else #define LOGV(format, ...) fprintf(stdout, LOG_TAG format, ##__VA_ARGS__) #define LOGE(format, ...) fprintf(stderr, LOG_TAG format, ##__VA_ARGS__) #define LOGI(format, ...) fprintf(stdout, LOG_TAG format, ##__VA_ARGS__) #define SCHED_NORMAL 0 #define SCHED_FIFO 1 #define SCHED_RR 2 #define SCHED_BATCH 3 #endif /* Define the structure that holds the GKI variables */ tGKI_CB gki_cb; #define NANOSEC_PER_MILLISEC (1000000) #define NSEC_PER_SEC (1000 * NANOSEC_PER_MILLISEC) /* works only for 1ms to 1000ms heart beat ranges */ #define LINUX_SEC (1000 / TICKS_PER_SEC) // #define GKI_TICK_TIMER_DEBUG /* this kind of mutex go into tGKI_OS control block!!!! */ /* static pthread_mutex_t GKI_sched_mutex; */ /*static pthread_mutex_t thread_delay_mutex; static pthread_cond_t thread_delay_cond; static pthread_mutex_t gki_timer_update_mutex; static pthread_cond_t   gki_timer_update_cond; */ #ifdef NO_GKI_RUN_RETURN static pthread_t timer_thread_id = 0; #endif typedef struct {  uint8_t task_id;         /* GKI task id */  TASKPTR task_entry;      /* Task entry function*/  uintptr_t params;        /* Extra params to pass to task entry function */  pthread_cond_t* pCond;   /* for android*/  pthread_mutex_t* pMutex; /* for android*/ } gki_pthread_info_t; gki_pthread_info_t gki_pthread_info[GKI_MAX_TASKS]; static pthread_mutex_t gki_init_mutex; static std::once_flag s_gki_init_mutex_once; void gki_init_mutex_init() { pthread_mutex_init(&gki_init_mutex, nullptr); } /******************************************************************************* ** ** Function         gki_task_entry ** ** Description      entry point of GKI created tasks ** ** Returns          void ** *******************************************************************************/ void* gki_task_entry(void* params) {  pthread_t thread_id = pthread_self();  gki_pthread_info_t* p_pthread_info = (gki_pthread_info_t*)params;  LOG(DEBUG) << StringPrintf(      "%s: task_id=%i, thread_id=%lx/%lx, pCond/pMutex=%p/%p", __func__,      p_pthread_info->task_id, gki_cb.os.thread_id[p_pthread_info->task_id],      pthread_self(), p_pthread_info->pCond, p_pthread_info->pMutex);   gki_cb.os.thread_id[p_pthread_info->task_id] = thread_id;  /* Call the actual thread entry point */  (p_pthread_info->task_entry)(p_pthread_info->params);   LOG(WARNING) << StringPrintf("%s: task_id=%i terminating", __func__,                               p_pthread_info->task_id); #if (FALSE == GKI_PTHREAD_JOINABLE)  gki_cb.os.thread_id[p_pthread_info->task_id] = 0; #endif   return nullptr; } /* end android */ /******************************************************************************* ** ** Function         GKI_init ** ** Description      This function is called once at startup to initialize **                  all the timer structures. ** ** Returns          void ** *******************************************************************************/ void GKI_init(void) {  pthread_mutexattr_t attr;  tGKI_OS* p_os;   std::call_once(s_gki_init_mutex_once, gki_init_mutex_init);  gki_buffer_init();  gki_timers_init();   /* Start ticks from 0 */  gki_cb.com.OSTicks = 0;   pthread_mutexattr_init(&attr); #ifndef __CYGWIN__  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE); #endif  p_os = &gki_cb.os;  pthread_mutex_init(&p_os->GKI_mutex, &attr);  pthread_mutexattr_destroy(&attr);  /* pthread_mutex_init(&GKI_sched_mutex, NULL); */  /* pthread_mutex_init(&thread_delay_mutex, NULL); */ /* used in GKI_delay */  /* pthread_cond_init (&thread_delay_cond, NULL); */   /* Initialiase GKI_timer_update suspend variables & mutexes to be in running   * state.   * this works too even if GKI_NO_TICK_STOP is defined in btld.txt */  pthread_mutex_lock(&gki_init_mutex);  p_os->no_timer_suspend = GKI_TIMER_TICK_RUN_COND;  pthread_mutex_unlock(&gki_init_mutex);  pthread_mutex_init(&p_os->gki_timer_mutex, nullptr);  pthread_cond_init(&p_os->gki_timer_cond, nullptr);  pthread_mutex_init(&p_os->gki_end_mutex, nullptr);  pthread_cond_init(&p_os->gki_end_cond, nullptr);  p_os->end_flag = 0; } /******************************************************************************* ** ** Function         GKI_get_os_tick_count ** ** Description      This function is called to retrieve the native OS system **                  tick. ** ** Returns          Tick count of native OS. ** *******************************************************************************/ uint32_t GKI_get_os_tick_count(void) {  /* TODO - add any OS specific code here */  return (gki_cb.com.OSTicks); } /******************************************************************************* ** ** Function         GKI_create_task ** ** Description      This function is called to create a new OSS task. ** ** Parameters:      task_entry  - (input) pointer to the entry function of the **                                        task **                  task_id     - (input) Task id is mapped to priority **                  taskname    - (input) name given to the task **                  stack       - (input) pointer to the top of the stack **                                        (highest memory location) **                  stacksize   - (input) size of the stack allocated for the **                                        task ** ** Returns          GKI_SUCCESS if all OK, GKI_FAILURE if any problem ** ** NOTE             This function take some parameters that may not be needed **                  by your particular OS. They are here for compatability **                  of the function prototype. ** *******************************************************************************/ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,                        uint16_t* stack, uint16_t stacksize, void* pCondVar,                        void* pMutex) {  struct sched_param param;  int policy, ret = 0;  pthread_condattr_t attr;  pthread_attr_t attr1;   pthread_condattr_init(&attr);  pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);  LOG(DEBUG) << StringPrintf(      "%s: func=0x%p  id=%d  name=%s  stack=0x%p  stackSize=%d", __func__,      task_entry, task_id, taskname, stack, stacksize);   if (task_id >= GKI_MAX_TASKS) {    LOG(ERROR) << StringPrintf("%s: Error! task ID > max task allowed",                               __func__);    pthread_condattr_destroy(&attr);    return (GKI_FAILURE);  }   gki_cb.com.OSRdyTbl[task_id] = TASK_READY;  gki_cb.com.OSTName[task_id] = taskname;  gki_cb.com.OSWaitTmr[task_id] = 0;  gki_cb.com.OSWaitEvt[task_id] = 0;   /* Initialize mutex and condition variable objects for events and timeouts */  pthread_mutex_init(&gki_cb.os.thread_evt_mutex[task_id], nullptr);  pthread_cond_init(&gki_cb.os.thread_evt_cond[task_id], &attr);  pthread_mutex_init(&gki_cb.os.thread_timeout_mutex[task_id], nullptr);  pthread_cond_init(&gki_cb.os.thread_timeout_cond[task_id], &attr);   pthread_attr_init(&attr1); /* by default, pthread creates a joinable thread */ #if (FALSE == GKI_PTHREAD_JOINABLE)  pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_DETACHED);   LOG(DEBUG) << StringPrintf("%s:  GKI creating task %i, pCond/pMutex=%p/%p",                             __func__, task_id, pCondVar, pMutex); #else  LOG(VERBOSE) << StringPrintf("%s: GKI creating JOINABLE task %i", __func__,                               task_id); #endif   /* On Android, the new tasks starts running before   * 'gki_cb.os.thread_id[task_id]' is initialized */  /* Pass task_id to new task so it can initialize gki_cb.os.thread_id[task_id]   * for it calls GKI_wait */  gki_pthread_info[task_id].task_id = task_id;  gki_pthread_info[task_id].task_entry = task_entry;  gki_pthread_info[task_id].params = 0;  gki_pthread_info[task_id].pCond = (pthread_cond_t*)pCondVar;  gki_pthread_info[task_id].pMutex = (pthread_mutex_t*)pMutex;   ret = pthread_create(&gki_cb.os.thread_id[task_id], &attr1, gki_task_entry,                       &gki_pthread_info[task_id]);   pthread_condattr_destroy(&attr);  pthread_attr_destroy(&attr1);   if (ret != 0) {    LOG(VERBOSE) << StringPrintf("%s: pthread_create failed(%d), %s!", __func__,                                 ret, taskname);    return GKI_FAILURE;  }   if (pthread_getschedparam(gki_cb.os.thread_id[task_id], &policy, &param) ==      0) { #if (PBS_SQL_TASK == TRUE)    if (task_id == PBS_SQL_TASK) {      LOG(VERBOSE) << StringPrintf("%s: PBS SQL lowest priority task",                                   __func__);      policy = SCHED_NORMAL;    } else #endif    {      policy = SCHED_RR;      param.sched_priority = 30 - task_id - 2;    }    pthread_setschedparam(gki_cb.os.thread_id[task_id], policy, &param);  }   LOG(VERBOSE) << StringPrintf(      "%s: Leaving GKI_create_task %p %d %lx %s %p %d", __func__, task_entry,      task_id, gki_cb.os.thread_id[task_id], taskname, stack, stacksize);   return (GKI_SUCCESS); } /******************************************************************************* ** ** Function         GKI_shutdown ** ** Description      shutdowns the GKI tasks/threads in from max task id to 0 and **                  frees pthread resources! **                  IMPORTANT: in case of join method, GKI_shutdown must be **                  called outside a GKI thread context! ** ** Returns          void ** *******************************************************************************/ void GKI_shutdown(void) {  uint8_t task_id;  volatile int* p_run_cond = &gki_cb.os.no_timer_suspend;  int oldCOnd = 0; #if (FALSE == GKI_PTHREAD_JOINABLE)  int i = 0; #else  int result; #endif   /* release threads and set as TASK_DEAD. going from low to high priority fixes   * GKI_exception problem due to btu->hci sleep request events  */  for (task_id = GKI_MAX_TASKS; task_id > 0; task_id--) {    if (gki_cb.com.OSRdyTbl[task_id - 1] != TASK_DEAD) {      /* paranoi settings, make sure that we do not execute any mailbox events       */      gki_cb.com.OSWaitEvt[task_id - 1] &=          ~(TASK_MBOX_0_EVT_MASK | TASK_MBOX_1_EVT_MASK | TASK_MBOX_2_EVT_MASK |            TASK_MBOX_3_EVT_MASK);      GKI_send_event(task_id - 1, EVENT_MASK(GKI_SHUTDOWN_EVT));       if (((task_id - 1) == BTU_TASK)) {        gki_cb.com.system_tick_running = false;        *p_run_cond = GKI_TIMER_TICK_EXIT_COND; /* stop system tick */      } #if (FALSE == GKI_PTHREAD_JOINABLE)      i = 0;       while ((gki_cb.com.OSWaitEvt[task_id - 1] != 0) && (++i < 10))        usleep(100 * 1000); #else      /* Skip BTU_TASK due to BTU_TASK is used for GKI_run() and it terminates       * after GKI_shutdown().       */      if ((task_id - 1) != BTU_TASK) {        /* wait for proper Arnold Schwarzenegger task state */        result = pthread_join(gki_cb.os.thread_id[task_id - 1], NULL);        if (result < 0) {          LOG(VERBOSE) << StringPrintf("%s: FAILED: result=%d", __func__,                                       result);        }      } #endif      LOG(DEBUG) << StringPrintf("%s:  task %s dead", __func__,                                 gki_cb.com.OSTName[task_id - 1]);      GKI_exit_task(task_id - 1);    }  } #if (FALSE == GKI_PTHREAD_JOINABLE)  i = 0; #endif #ifdef NO_GKI_RUN_RETURN  shutdown_timer = 1; #endif  oldCOnd = *p_run_cond;  *p_run_cond = GKI_TIMER_TICK_EXIT_COND;  if (oldCOnd == GKI_TIMER_TICK_STOP_COND ||      oldCOnd == GKI_TIMER_TICK_EXIT_COND)    pthread_cond_signal(&gki_cb.os.gki_timer_cond);   pthread_mutex_lock(&gki_cb.os.gki_end_mutex);  while (gki_cb.os.end_flag != 1) {    pthread_cond_wait(&gki_cb.os.gki_end_cond, &gki_cb.os.gki_end_mutex);  }  pthread_mutex_unlock(&gki_cb.os.gki_end_mutex); #if (TRUE == GKI_PTHREAD_JOINABLE)  result = pthread_join(gki_cb.os.thread_id[BTU_TASK], NULL);  if (result < 0) {    LOG(DEBUG) << StringPrintf("%s: FAILED: result=%d", __func__, result);  } #endif   pthread_mutex_destroy(&gki_cb.os.GKI_mutex);  pthread_mutex_destroy(&gki_cb.os.gki_end_mutex);  pthread_cond_destroy(&gki_cb.os.gki_end_cond); } /******************************************************************************* ** ** Function        gki_system_tick_start_stop_cback ** ** Description     This function starts or stops timer ** ** Parameters:     start: TRUE start system tick (again), FALSE stop ** ** Returns         void ** ******************************************************************************/ void gki_system_tick_start_stop_cback(bool start) {  tGKI_OS* p_os = &gki_cb.os;  volatile int* p_run_cond = &p_os->no_timer_suspend;  if (start == false) {    /* this can lead to a race condition. however as we only read this variable     * in the timer loop     * we should be fine with this approach. otherwise uncomment below mutexes.     */    /* GKI_disable(); */    *p_run_cond = GKI_TIMER_TICK_STOP_COND;    /* GKI_enable(); */  } else {    /* restart GKI_timer_update() loop */    *p_run_cond = GKI_TIMER_TICK_RUN_COND;    pthread_mutex_lock(&p_os->gki_timer_mutex);    pthread_cond_signal(&p_os->gki_timer_cond);    pthread_mutex_unlock(&p_os->gki_timer_mutex);  } } /******************************************************************************* ** ** Function         timer_thread ** ** Description      Timer thread ** ** Parameters:      id  - (input) timer ID ** ** Returns          void ** *******************************************************************************/ #ifdef NO_GKI_RUN_RETURN void timer_thread(signed long id) {  LOG(VERBOSE) << StringPrintf("%s: enter", __func__);  struct timespec delay;  int timeout = 1000; /* 10  ms per system tick  */  int err;   while (!shutdown_timer) {    delay.tv_sec = timeout / 1000;    delay.tv_nsec = 1000 * 1000 * (timeout % 1000);     /* [u]sleep can't be used because it uses SIGALRM */     do {      err = nanosleep(&delay, &delay);    } while (err < 0 && errno == EINTR);     GKI_timer_update(1);  }  LOG(ERROR) << StringPrintf("%s: exit", __func__);  return; } #endif /******************************************************************************* ** ** Function         GKI_run ** ** Description      This function runs a task ** ** Parameters:      p_task_id  - (input) pointer to task id ** ** Returns          void ** ** NOTE             This function is only needed for operating systems where **                  starting a task is a 2-step process. Most OS's do it in **                  one step, If your OS does it in one step, this function **                  should be empty. *******************************************************************************/ void GKI_run(__attribute__((unused)) void* p_task_id) {  LOG(DEBUG) << StringPrintf("%s:  enter", __func__);  struct timespec delay;  int err = 0;  pthread_mutex_lock(&gki_init_mutex);  volatile int* p_run_cond = &gki_cb.os.no_timer_suspend; #ifndef GKI_NO_TICK_STOP  /* register start stop function which disable timer loop in GKI_run() when no   * timers are   * in any GKI/BTA/BTU this should save power when BTLD is idle! */  GKI_timer_queue_register_callback(gki_system_tick_start_stop_cback);  LOG(DEBUG) << StringPrintf("%s:  Start/Stop GKI_timer_update_registered!",                             __func__); #endif #ifdef NO_GKI_RUN_RETURN  LOG(VERBOSE) << StringPrintf("%s: == NO_GKI_RUN_RETURN", __func__);  pthread_attr_t timer_attr;   shutdown_timer = 0;   pthread_attr_init(&timer_attr);  pthread_attr_setdetachstate(&timer_attr, PTHREAD_CREATE_DETACHED);  if (pthread_create(&timer_thread_id, &timer_attr, timer_thread, NULL) != 0) {    LOG(VERBOSE) << StringPrintf(        "%s: pthread_create failed to create timer_thread!", __func__);    pthread_mutex_unlock(&gki_init_mutex);    return GKI_FAILURE;  } #else  LOG(DEBUG) << StringPrintf("%s:  run_cond(%p)=%d ", __func__, p_run_cond,                             *p_run_cond);  for (; GKI_TIMER_TICK_EXIT_COND != *p_run_cond;) {    do {      /* adjust hear bit tick in btld by changning TICKS_PER_SEC!!!!! this       * formula works only for       * 1-1000ms heart beat units! */      delay.tv_sec = LINUX_SEC / 1000;      delay.tv_nsec = 1000 * 1000 * (LINUX_SEC % 1000);       /* [u]sleep can't be used because it uses SIGALRM */      do {        err = nanosleep(&delay, &delay);      } while (err < 0 && errno == EINTR);       if (GKI_TIMER_TICK_RUN_COND != *p_run_cond) break;  // GKI has shutdown       /* the unit should be alsways 1 (1 tick). only if you vary for some reason       * heart beat tick       * e.g. power saving you may want to provide more ticks       */      GKI_timer_update(1);    } while (GKI_TIMER_TICK_RUN_COND == *p_run_cond); /* currently on reason to exit above loop is no_timer_suspend == * GKI_TIMER_TICK_STOP_COND * block timer main thread till re-armed by  */ #ifdef GKI_TICK_TIMER_DEBUG    LOG(VERBOSE) << StringPrintf("%s: >>> SUSPENDED", __func__); #endif    if (GKI_TIMER_TICK_EXIT_COND != *p_run_cond) {      pthread_mutex_lock(&gki_cb.os.gki_timer_mutex);      pthread_cond_wait(&gki_cb.os.gki_timer_cond, &gki_cb.os.gki_timer_mutex);      pthread_mutex_unlock(&gki_cb.os.gki_timer_mutex);    }    /* potentially we need to adjust os gki_cb.com.OSTicks */ #ifdef GKI_TICK_TIMER_DEBUG    LOG(VERBOSE) << StringPrintf("%s: >>> RESTARTED run_cond=%d", __func__,                                 *p_run_cond); #endif  } /* for */  pthread_mutex_unlock(&gki_init_mutex); #endif   pthread_mutex_lock(&gki_cb.os.gki_end_mutex);  gki_cb.os.end_flag = 1;  pthread_cond_signal(&gki_cb.os.gki_end_cond);  pthread_mutex_unlock(&gki_cb.os.gki_end_mutex);   gki_cb.com.OSWaitEvt[BTU_TASK] = 0;  LOG(VERBOSE) << StringPrintf("%s: exit", __func__); } /******************************************************************************* ** ** Function         GKI_stop ** ** Description      This function is called to stop **                  the tasks and timers when the system is being stopped ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to use it in your own implementation, **                  put specific code here. ** *******************************************************************************/ void GKI_stop(void) {  uint8_t task_id;   /*  gki_queue_timer_cback(FALSE); */  /* TODO - add code here if needed*/   for (task_id = 0; task_id < GKI_MAX_TASKS; task_id++) {    if (gki_cb.com.OSRdyTbl[task_id] != TASK_DEAD) {      GKI_exit_task(task_id);    }  } } /******************************************************************************* ** ** Function         GKI_wait ** ** Description      This function is called by tasks to wait for a specific **                  event or set of events. The task may specify the duration **                  that it wants to wait for, or 0 if infinite. ** ** Parameters:      flag -    (input) the event or set of events to wait for **                  timeout - (input) the duration that the task wants to wait **                                    for the specific events (in system ticks) ** ** ** Returns          the event mask of received events or zero if timeout ** *******************************************************************************/ uint16_t GKI_wait(uint16_t flag, uint32_t timeout) {  uint16_t evt;  uint8_t rtask;  struct timespec abstime = {0, 0};  int sec;  int nano_sec;   rtask = GKI_get_taskid();  if (rtask >= GKI_MAX_TASKS) {    LOG(ERROR) << StringPrintf("%s: Exiting thread; rtask %d >= %d", __func__,                               rtask, GKI_MAX_TASKS);    return EVENT_MASK(GKI_SHUTDOWN_EVT);  }   gki_pthread_info_t* p_pthread_info = &gki_pthread_info[rtask];  if (p_pthread_info->pCond != nullptr && p_pthread_info->pMutex != nullptr) {    LOG(DEBUG) << StringPrintf("%s:  task=%i, pCond/pMutex = %p/%p", __func__,                               rtask, p_pthread_info->pCond,                               p_pthread_info->pMutex);    if (pthread_mutex_lock(p_pthread_info->pMutex) != 0) {      LOG(ERROR) << StringPrintf("%s:  Could not lock mutex", __func__);      return EVENT_MASK(GKI_SHUTDOWN_EVT);    }    if (pthread_cond_signal(p_pthread_info->pCond) != 0) {      LOG(ERROR) << StringPrintf("%s:  Error calling pthread_cond_signal()",                                 __func__);      (void)pthread_mutex_unlock(p_pthread_info->pMutex);      return EVENT_MASK(GKI_SHUTDOWN_EVT);    }    if (pthread_mutex_unlock(p_pthread_info->pMutex) != 0) {      LOG(ERROR) << StringPrintf("%s:  Error unlocking mutex", __func__);      return EVENT_MASK(GKI_SHUTDOWN_EVT);    }    p_pthread_info->pMutex = nullptr;    p_pthread_info->pCond = nullptr;  }  gki_cb.com.OSWaitForEvt[rtask] = flag;   /* protect OSWaitEvt[rtask] from modification from an other thread */  pthread_mutex_lock(&gki_cb.os.thread_evt_mutex[rtask]); #if 0 /* for clean scheduling we probably should always call \         pthread_cond_wait() */    /* Check if anything in any of the mailboxes. There is a potential race condition where OSTaskQFirst[rtask]     has been modified. however this should only result in addtional call to  pthread_cond_wait() but as     the cond is met, it will exit immediately (depending on schedulling) */    if (gki_cb.com.OSTaskQFirst[rtask][0])    gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_0_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][1])    gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_1_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][2])    gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_2_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][3])    gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_3_EVT_MASK; #endif   if (!(gki_cb.com.OSWaitEvt[rtask] & flag)) {    if (timeout) {      //            timeout = GKI_MS_TO_TICKS(timeout);     /* convert from      //            milliseconds to ticks */       /* get current system time */      //            clock_gettime(CLOCK_MONOTONIC, &currSysTime);      //            abstime.tv_sec = currSysTime.time;      //            abstime.tv_nsec = NANOSEC_PER_MILLISEC *      //            currSysTime.millitm;      clock_gettime(CLOCK_MONOTONIC, &abstime);       /* add timeout */      sec = timeout / 1000;      nano_sec = (timeout % 1000) * NANOSEC_PER_MILLISEC;      abstime.tv_nsec += nano_sec;      if (abstime.tv_nsec > NSEC_PER_SEC) {        abstime.tv_sec += (abstime.tv_nsec / NSEC_PER_SEC);        abstime.tv_nsec = abstime.tv_nsec % NSEC_PER_SEC;      }      abstime.tv_sec += sec;       pthread_cond_timedwait(&gki_cb.os.thread_evt_cond[rtask],                             &gki_cb.os.thread_evt_mutex[rtask], &abstime);     } else if (gki_cb.com.OSRdyTbl[rtask] != TASK_DEAD) {      pthread_cond_wait(&gki_cb.os.thread_evt_cond[rtask],                        &gki_cb.os.thread_evt_mutex[rtask]);    }     /* TODO: check, this is probably neither not needed depending on     phtread_cond_wait() implmentation,     e.g. it looks like it is implemented as a counter in which case multiple     cond_signal     should NOT be lost! */    // we are waking up after waiting for some events, so refresh variables    // no need to call GKI_disable() here as we know that we will have some    // events as we've been waking up after condition pending or timeout    if (gki_cb.com.OSTaskQFirst[rtask][0])      gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_0_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][1])      gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_1_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][2])      gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_2_EVT_MASK;    if (gki_cb.com.OSTaskQFirst[rtask][3])      gki_cb.com.OSWaitEvt[rtask] |= TASK_MBOX_3_EVT_MASK;     if (gki_cb.com.OSWaitEvt[rtask] == EVENT_MASK(GKI_SHUTDOWN_EVT)) {      gki_cb.com.OSWaitEvt[rtask] = 0;      /* unlock thread_evt_mutex as pthread_cond_wait() does auto lock when cond       * is met */      pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[rtask]);      LOG(WARNING) << StringPrintf(          "%s: GKI TASK_DEAD received. exit thread %d...", __func__, rtask); #if (FALSE == GKI_PTHREAD_JOINABLE)      gki_cb.os.thread_id[rtask] = 0; #endif      return (EVENT_MASK(GKI_SHUTDOWN_EVT));    }  }   /* Clear the wait for event mask */  gki_cb.com.OSWaitForEvt[rtask] = 0;   /* Return only those bits which user wants... */  evt = gki_cb.com.OSWaitEvt[rtask] & flag;   /* Clear only those bits which user wants... */  gki_cb.com.OSWaitEvt[rtask] &= ~flag;   /* unlock thread_evt_mutex as pthread_cond_wait() does auto lock mutex when   * cond is met */  pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[rtask]);  return (evt); } /******************************************************************************* ** ** Function         GKI_delay ** ** Description      This function is called by tasks to sleep unconditionally **                  for a specified amount of time. The duration is in **                  milliseconds ** ** Parameters:      timeout -    (input) the duration in milliseconds ** ** Returns          void ** *******************************************************************************/ void GKI_delay(uint32_t timeout) {  uint8_t rtask = GKI_get_taskid();  struct timespec delay;  int err;   LOG(VERBOSE) << StringPrintf("%s: rtask=%d timeout=%d", __func__, rtask,                               timeout);   delay.tv_sec = timeout / 1000;  delay.tv_nsec = 1000 * 1000 * (timeout % 1000);   /* [u]sleep can't be used because it uses SIGALRM */   do {    err = nanosleep(&delay, &delay);  } while (err < 0 && errno == EINTR);   /* Check if task was killed while sleeping */  /* NOTE  **      if you do not implement task killing, you do not  **      need this check.  */  if (rtask && gki_cb.com.OSRdyTbl[rtask] == TASK_DEAD) {  }   LOG(VERBOSE) << StringPrintf("%s: rtask=%d timeout=%d done", __func__, rtask,                               timeout);  return; } /******************************************************************************* ** ** Function         GKI_send_event ** ** Description      This function is called by tasks to send events to other **                  tasks. Tasks can also send events to themselves. ** ** Parameters:      task_id -  (input) The id of the task to which the event has **                                     to be sent **                  event   -  (input) The event that has to be sent ** ** ** Returns          GKI_SUCCESS if all OK, else GKI_FAILURE ** *******************************************************************************/ uint8_t GKI_send_event(uint8_t task_id, uint16_t event) {  /* use efficient coding to avoid pipeline stalls */  if (task_id < GKI_MAX_TASKS) {    /* protect OSWaitEvt[task_id] from manipulation in GKI_wait() */    pthread_mutex_lock(&gki_cb.os.thread_evt_mutex[task_id]);     /* Set the event bit */    gki_cb.com.OSWaitEvt[task_id] |= event;     pthread_cond_signal(&gki_cb.os.thread_evt_cond[task_id]);     pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[task_id]);     return (GKI_SUCCESS);  }  return (GKI_FAILURE); } /******************************************************************************* ** ** Function         GKI_isend_event ** ** Description      This function is called from ISRs to send events to other **                  tasks. The only difference between this function and **                  GKI_send_event is that this function assumes interrupts are **                  already disabled. ** ** Parameters:      task_id -  (input) The destination task Id for the event. **                  event   -  (input) The event flag ** ** Returns          GKI_SUCCESS if all OK, else GKI_FAILURE ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to use it in your own implementation, **                  put your code here, otherwise you can delete the entire **                  body of the function. ** *******************************************************************************/ uint8_t GKI_isend_event(uint8_t task_id, uint16_t event) {  LOG(VERBOSE) << StringPrintf("%s: task_id=%d event%x", __func__, task_id,                               event);  return GKI_send_event(task_id, event); } /******************************************************************************* ** ** Function         GKI_get_taskid ** ** Description      This function gets the currently running task ID. ** ** Returns          task ID ** ** NOTE             The Widcomm upper stack and profiles may run as a single **                  task. If you only have one GKI task, then you can hard-code **                  this function to return a '1'. Otherwise, you should have **                  some OS-specific method to determine the current task. ** *******************************************************************************/ uint8_t GKI_get_taskid(void) {  int i;  pthread_t thread_id = pthread_self();  for (i = 0; i < GKI_MAX_TASKS; i++) {    if (gki_cb.os.thread_id[i] == thread_id) {      return (i);    }  }  return (-1); } /******************************************************************************* ** ** Function         GKI_map_taskname ** ** Description      This function gets the task name of the taskid passed as **                  arg. If GKI_MAX_TASKS is passed as arg the currently running **                  task name is returned ** ** Parameters:      task_id -  (input) The id of the task whose name is being **                  sought. GKI_MAX_TASKS is passed to get the name of the **                  currently running task. ** ** Returns          pointer to task name ** ** NOTE             this function needs no customization ** *******************************************************************************/ int8_t* GKI_map_taskname(uint8_t task_id) {  if (task_id < GKI_MAX_TASKS) {    LOG(VERBOSE) << StringPrintf("%s: task_id=%d %s done", __func__, task_id,                                 gki_cb.com.OSTName[task_id]);    return (gki_cb.com.OSTName[task_id]);  } else if (task_id == GKI_MAX_TASKS) {    return (gki_cb.com.OSTName[GKI_get_taskid()]);  } else {    return (int8_t*)"BAD";  } } /******************************************************************************* ** ** Function         GKI_enable ** ** Description      This function enables interrupts. ** ** Returns          void ** *******************************************************************************/ void GKI_enable(void) {  pthread_mutex_unlock(&gki_cb.os.GKI_mutex);  /* 	pthread_mutex_xx is nesting save, no need for this: already_disabled =   * 0; */  return; } /******************************************************************************* ** ** Function         GKI_disable ** ** Description      This function disables interrupts. ** ** Returns          void ** *******************************************************************************/ void GKI_disable(void) {  // LOG(VERBOSE) <<  // StringPrintf("GKI_disable");   /*	pthread_mutex_xx is nesting save, no need for this: if     (!already_disabled) {      already_disabled = 1; */  pthread_mutex_lock(&gki_cb.os.GKI_mutex);  /*  } */  // LOG(VERBOSE) <<  // StringPrintf("Leaving GKI_disable");  return; } /******************************************************************************* ** ** Function         GKI_exception ** ** Description      This function throws an exception. **                  This is normally only called for a nonrecoverable error. ** ** Parameters:      code    -  (input) The code for the error **                  msg     -  (input) The message that has to be logged ** ** Returns          void ** *******************************************************************************/ void GKI_exception(uint16_t code, std::string msg) {  uint8_t task_id;   LOG(ERROR) << StringPrintf("%s: Task State Table", __func__);   for (task_id = 0; task_id < GKI_MAX_TASKS; task_id++) {    LOG(ERROR) << StringPrintf("%s: TASK ID [%d] task name [%s] state [%d]",                               __func__, task_id, gki_cb.com.OSTName[task_id],                               gki_cb.com.OSRdyTbl[task_id]);  }   LOG(ERROR) << StringPrintf("%s: code=%d %s", __func__, code, msg.c_str());  LOG(ERROR) << StringPrintf(      "********************************************************************");  LOG(ERROR) << StringPrintf("%s: * code=%d %s", __func__, code, msg.c_str());  LOG(ERROR) << StringPrintf(      "********************************************************************");   LOG(ERROR) << StringPrintf("%s: code%d %s done", __func__, code, msg.c_str());   return; } /******************************************************************************* ** ** Function         GKI_get_time_stamp ** ** Description      This function formats the time into a user area ** ** Parameters:      tbuf -  (output) the address to the memory containing the **                  formatted time ** ** Returns          the address of the user area containing the formatted time **                  The format of the time is ???? ** ** NOTE             This function is only called by OBEX. ** *******************************************************************************/ int8_t* GKI_get_time_stamp(int8_t* tbuf) {  uint32_t ms_time;  uint32_t s_time;  uint32_t m_time;  uint32_t h_time;  int8_t* p_out = tbuf;   ms_time = GKI_TICKS_TO_MS(times(nullptr));  s_time = ms_time / 100; /* 100 Ticks per second */  m_time = s_time / 60;  h_time = m_time / 60;   ms_time -= s_time * 100;  s_time -= m_time * 60;  m_time -= h_time * 60;   *p_out++ = (int8_t)((h_time / 10) + '0');  *p_out++ = (int8_t)((h_time % 10) + '0');  *p_out++ = ':';  *p_out++ = (int8_t)((m_time / 10) + '0');  *p_out++ = (int8_t)((m_time % 10) + '0');  *p_out++ = ':';  *p_out++ = (int8_t)((s_time / 10) + '0');  *p_out++ = (int8_t)((s_time % 10) + '0');  *p_out++ = ':';  *p_out++ = (int8_t)((ms_time / 10) + '0');  *p_out++ = (int8_t)((ms_time % 10) + '0');  *p_out++ = ':';  *p_out = 0;   return (tbuf); } /******************************************************************************* ** ** Function         GKI_register_mempool ** ** Description      This function registers a specific memory pool. ** ** Parameters:      p_mem -  (input) pointer to the memory pool ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If your OS has different memory pools, you **                  can tell GKI the pool to use by calling this function. ** *******************************************************************************/ void GKI_register_mempool(void* p_mem) {  gki_cb.com.p_user_mempool = p_mem;   return; } /******************************************************************************* ** ** Function         GKI_os_malloc ** ** Description      This function allocates memory ** ** Parameters:      size -  (input) The size of the memory that has to be **                  allocated ** ** Returns          the address of the memory allocated, or NULL if failed ** ** NOTE             This function is called by the Widcomm stack when **                  dynamic memory allocation is used. ** *******************************************************************************/ void* GKI_os_malloc(uint32_t size) { return (malloc(size)); } /******************************************************************************* ** ** Function         GKI_os_free ** ** Description      This function frees memory ** ** Parameters:      size -  (input) The address of the memory that has to be **                  freed ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. It is only called from within GKI if dynamic ** *******************************************************************************/ void GKI_os_free(void* p_mem) {  if (p_mem != nullptr) free(p_mem);  return; } /******************************************************************************* ** ** Function         GKI_suspend_task() ** ** Description      This function suspends the task specified in the argument. ** ** Parameters:      task_id  - (input) the id of the task that has to suspended ** ** Returns          GKI_SUCCESS if all OK, else GKI_FAILURE ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to implement task suspension **                  capability, put specific code here. ** *******************************************************************************/ uint8_t GKI_suspend_task(uint8_t task_id) {  LOG(VERBOSE) << StringPrintf("%s: task_id=%d - NOT implemented", __func__,                               task_id);   return (GKI_SUCCESS); } /******************************************************************************* ** ** Function         GKI_resume_task() ** ** Description      This function resumes the task specified in the argument. ** ** Parameters:      task_id  - (input) the id of the task that has to resumed ** ** Returns          GKI_SUCCESS if all OK ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to implement task suspension **                  capability, put specific code here. ** *******************************************************************************/ uint8_t GKI_resume_task(uint8_t task_id) {  LOG(VERBOSE) << StringPrintf("%s: task_id=%d - NOT implemented", __func__,                               task_id);   return (GKI_SUCCESS); } /******************************************************************************* ** ** Function         GKI_exit_task ** ** Description      This function is called to stop a GKI task. ** ** Parameters:      task_id  - (input) the id of the task that has to be stopped ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to use it in your own implementation, **                  put specific code here to kill a task. ** *******************************************************************************/ void GKI_exit_task(uint8_t task_id) {  if (task_id >= GKI_MAX_TASKS) {    return;  }  GKI_disable();  if (gki_cb.com.OSRdyTbl[task_id] == TASK_DEAD) {    GKI_enable();    LOG(WARNING) << StringPrintf("%s: task_id %d was already stopped.",                                 __func__, task_id);    return;  }  gki_cb.com.OSRdyTbl[task_id] = TASK_DEAD;   /* Destroy mutex and condition variable objects */  pthread_mutex_destroy(&gki_cb.os.thread_evt_mutex[task_id]);  pthread_cond_destroy(&gki_cb.os.thread_evt_cond[task_id]);  pthread_mutex_destroy(&gki_cb.os.thread_timeout_mutex[task_id]);  pthread_cond_destroy(&gki_cb.os.thread_timeout_cond[task_id]);   GKI_enable();   // GKI_send_event(task_id, EVENT_MASK(GKI_SHUTDOWN_EVT));   LOG(DEBUG) << StringPrintf("%s:  %d done", __func__, task_id);  return; } /******************************************************************************* ** ** Function         GKI_sched_lock ** ** Description      This function is called by tasks to disable scheduler **                  task context switching. ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to use it in your own implementation, **                  put code here to tell the OS to disable context switching. ** *******************************************************************************/ void GKI_sched_lock(void) {  LOG(VERBOSE) << StringPrintf("%s", __func__);  GKI_disable();  return; } /******************************************************************************* ** ** Function         GKI_sched_unlock ** ** Description      This function is called by tasks to enable scheduler **                  switching. ** ** Returns          void ** ** NOTE             This function is NOT called by the Widcomm stack and **                  profiles. If you want to use it in your own implementation, **                  put code here to tell the OS to re-enable context switching. ** *******************************************************************************/ void GKI_sched_unlock(void) {  LOG(VERBOSE) << StringPrintf("%s", __func__);  GKI_enable(); } /******************************************************************************* ** ** Function         GKI_shiftdown ** ** Description      shift memory down (to make space to insert a record) ** *******************************************************************************/ void GKI_shiftdown(uint8_t* p_mem, uint32_t len, uint32_t shift_amount) {  uint8_t* ps = p_mem + len - 1;  uint8_t* pd = ps + shift_amount;  uint32_t xx;   for (xx = 0; xx < len; xx++) *pd-- = *ps--; } /******************************************************************************* ** ** Function         GKI_shiftup ** ** Description      shift memory up (to delete a record) ** *******************************************************************************/ void GKI_shiftup(uint8_t* p_dest, uint8_t* p_src, uint32_t len) {  uint8_t* ps = p_src;  uint8_t* pd = p_dest;  uint32_t xx;   for (xx = 0; xx < len; xx++) *pd++ = *ps++; }  GKI_init();  GKI_enable();  GKI_create_task((TASKPTR)NFCA_TASK, BTU_TASK, (int8_t*)"NFCA_TASK", nullptr, 0,                  (pthread_cond_t*)nullptr, nullptr); 的作用









已深度思考（用时 38 秒）



根据提供的代码片段，我们需要分析`GKI_init()`、`GKI_enable()`和`GKI_create_task()`这三个函数的作用，并结合给定的调用参数来理解整个代码段的功能。

\### 1. `GKI_init()`

   \- 这个函数用于初始化GKI（通用内核接口）的内部结构。

   \- 它调用了`gki_buffer_init()`来初始化缓冲区管理。

   \- 调用了`gki_timers_init()`来初始化定时器。

   \- 初始化了`gki_cb.com.OSTicks`为0（系统时钟滴答计数）。

   \- 初始化了互斥锁（mutex）和条件变量（cond）用于任务调度和同步。

   \- 设置了定时器运行条件（`no_timer_suspend`）为运行状态（`GKI_TIMER_TICK_RUN_COND`）。

\### 2. `GKI_enable()`

   \- 这个函数用于使能中断（实际上是解锁一个互斥锁）。在代码中，它解锁了`gki_cb.os.GKI_mutex`，这个互斥锁在`GKI_disable()`中被锁定（用于模拟禁用中断）。

\### 3. `GKI_create_task()`

   \- 这个函数用于创建一个新的任务（线程）。

   \- 参数解析：

​     \- `(TASKPTR)NFCA_TASK`: 任务入口函数，这里是将`NFCA_TASK`函数作为任务入口。

​     \- `BTU_TASK`: 任务ID，这里使用`BTU_TASK`作为任务ID（通常是一个预定义的常量，例如`#define BTU_TASK 0`或其他值）。

​     \- `(int8_t*)"NFCA_TASK"`: 任务名称字符串。

​     \- `nullptr`: 栈指针，这里为`nullptr`表示由系统自动分配栈。

​     \- `0`: 栈大小，这里为0，可能使用默认大小或由系统决定。

​     \- `(pthread_cond_t*)nullptr`: 条件变量指针，这里为`nullptr`表示不传递条件变量。

​     \- `nullptr`: 互斥锁指针，同样为`nullptr`。

\### 代码段的作用

   \- `GKI_init();`：初始化GKI内核，包括缓冲区、定时器和同步机制。

   \- `GKI_enable();`：解锁互斥锁，使得任务调度可以开始（因为初始化后可能默认是锁定状态，需要解锁）。

   \- `GKI_create_task((TASKPTR)NFCA_TASK, BTU_TASK, (int8_t*)"NFCA_TASK", nullptr, 0, (pthread_cond_t*)nullptr, nullptr);`：

​     创建一个名为"NFCA_TASK"的任务，任务入口函数为`NFCA_TASK`，任务ID为`BTU_TASK`，使用系统默认的栈设置，并且不传递额外的条件变量和互斥锁。

\### 注意

   \- 在`GKI_create_task`函数内部，会设置任务的相关信息（如就绪表、任务名称等），并创建线程（使用`pthread_create`）。

   \- 任务创建后，会设置线程的调度策略和优先级（在代码中，对于非PBS_SQL_TASK的任务，使用`SCHED_RR`策略，优先级通过计算得到）。

   \- 这个任务将会执行`NFCA_TASK`函数，该函数应该是处理NFC相关任务的函数。

\### 总结

这段代码的作用是初始化GKI内核，然后创建一个名为"NFCA_TASK"的任务（线程），该任务将运行`NFCA_TASK`函数，用于处理NFC相关的事务。创建任务后，该任务就会处于就绪状态，等待调度执行。

这段代码的作用是初始化GKI（通用内核接口）系统，并创建一个名为"NFCA_TASK"的任务。以下是详细解释：

### 1. `GKI_init()`

- **作用**：初始化GKI内核的核心数据结构
- **关键操作**：
  - 初始化缓冲区管理系统（`gki_buffer_init`）
  - 初始化定时器系统（`gki_timers_init`）
  - 初始化任务调度所需的互斥锁和条件变量
  - 设置系统时钟滴答计数器为0
  - 创建线程同步所需的pthread对象（互斥锁和条件变量）

### 2. `GKI_enable()`

- **作用**：解锁全局GKI互斥锁
- **关键操作**：
  - 调用`pthread_mutex_unlock(&gki_cb.os.GKI_mutex)`
  - 使能任务调度和中断处理能力（在模拟环境中）

### 3. `GKI_create_task(...)`

- **作用**：创建名为"NFCA_TASK"的新任务
- **参数解析**：
  - `(TASKPTR)NFCA_TASK`：任务入口函数（NFCA_TASK）
  - `BTU_TASK`：任务ID（通常0表示主任务）
  - `(int8_t*)"NFCA_TASK"`：任务名称
  - `nullptr`：栈指针（系统自动分配）
  - `0`：栈大小（使用默认值）
  - `(pthread_cond_t*)nullptr`：不传递条件变量
  - `nullptr`：不传递互斥锁

### 整体流程：

1. **系统初始化**：准备内存管理、定时器、任务调度等基础设施
2. **启用调度**：解锁全局锁，允许任务调度
3. **创建NFCA任务**：
   - 在任务表中注册"NFCA_TASK"
   - 创建pthread线程执行`NFCA_TASK`函数
   - 设置任务为就绪状态（`OSRdyTbl[BTU_TASK] = TASK_READY`）

### 关键点：

- 该代码属于NFC/BT协议栈初始化流程
- `NFCA_TASK`是NFC控制器任务入口点
- 使用pthread实现跨平台任务抽象
- 任务创建后立即进入就绪状态，等待调度执行

最终效果：初始化了NFC/BT协议栈运行环境，并创建了核心的NFC处理任务，为后续NFC通信做好准备。









在nfc启动的作用









已深度思考（用时 32 秒）



在NFC（Near Field Communication，近场通信）启动过程中，这段代码扮演着初始化底层任务和调度环境的关键角色。具体作用如下：

1. **GKI系统初始化**：

   \- `GKI_init()`初始化了通用内核接口（GKI），为NFC协议栈提供基础服务：

​     \- 内存池管理（`gki_buffer_init`）

​     \- 定时器管理（`gki_timers_init`）

​     \- 任务调度所需的同步原语（互斥锁、条件变量）

   \- 建立全局控制块`gki_cb`，记录任务状态、定时器计数等核心信息

2. **启用任务调度**：

   \- `GKI_enable()`解锁全局调度锁，允许系统开始任务切换

3. **创建NFC核心任务**：

   \- 通过`GKI_create_task`创建"NFCA_TASK"（NFC Controller Agent Task）：

​     \- **任务ID**：`BTU_TASK`（通常定义为0，表示主任务）

​     \- **入口函数**：`NFCA_TASK`（NFC控制器主循环）

​     \- **任务特性**：

​       \- 无自定义栈（使用系统默认栈）

​       \- 无附加条件变量/互斥锁（由GKI内部管理）

   \- 该任务将成为NFC协议栈的核心调度单元，负责：

​     \- 处理硬件事件（如射频信号检测）

​     \- 执行协议状态机（如ISO 14443/Type A/B、FeliCa等）

​     \- 管理数据交换流程

4. **启动调度循环**：

   \- 虽然代码片段未显示，但后续通常会调用`GKI_run()`启动调度器：

​     \- 开启系统心跳（通常10ms周期）

​     \- 循环执行就绪任务（包括刚创建的NFCA_TASK）

\### NFC启动流程中的关键作用：

\- **基础设施就绪**：提供内存管理、定时器、任务调度等OS抽象层服务

\- **核心任务激活**：启动NFCA_TASK作为NFC协议栈的执行引擎

\- **事件驱动架构**：通过GKI的事件邮箱机制（`GKI_send_event`/`GKI_wait`）实现异步事件处理

\### 典型NFC任务工作流程：

\```c

void NFCA_TASK(void* arg) {

  while (true) {

​    uint16_t event = GKI_wait(EVENT_MASK(ALL_EVENTS), TIMEOUT_NEVER);

​    if (event & EVENT_MASK(HCI_READ_EVT)) {

​      // 处理来自NFC控制器的数据

​    }

​    if (event & EVENT_MASK(TIMER_EXPIRED_EVT)) {

​      // 处理定时事件

​    }

  }

}

\```

\### 总结：

这段代码是NFC协议栈启动的**基石初始化步骤**，它：

1. 构建了跨平台的内核抽象层（GKI）
2. 创建了NFC核心处理任务
3. 为后续的NFC硬件初始化、协议处理、数据传输建立了执行环境

在NFC（Near Field Communication）系统的启动过程中，这段代码扮演着**核心初始化角色**，具体作用如下：

### 1. 协议栈基础设施初始化

- **GKI_init()**：
  - 初始化内存池（为NFC数据包分配缓冲区）
  - 设置定时器系统（处理NFC通信超时和调度）
  - 创建线程同步原语（互斥锁和条件变量）
  - 清零系统时钟计数器

### 2. NFC任务环境准备

- **GKI_enable()**：
  - 解锁全局调度锁，使能任务切换能力
  - 允许后续创建的任务立即进入可调度状态

### 3. 核心NFC任务创建

- **GKI_create_task()**：
  - 创建名为"NFCA_TASK"的核心任务（NFC Controller Agent Task）
  - 指定任务入口函数为 `NFCA_TASK()`（NFC主处理逻辑）
  - 分配任务ID为 `BTU_TASK`（通常0表示主任务）
  - 自动分配任务栈空间（参数为nullptr和0）

### 4. NFC启动流程中的关键作用

| 阶段         | 功能描述                                                     |
| :----------- | :----------------------------------------------------------- |
| **基础准备** | 建立内存管理/定时器/线程同步等底层设施，为NFC协议栈提供运行环境 |
| **任务创建** | 实例化NFC主处理任务，该任务将负责：                          |
|              | - 初始化NFC控制器硬件                                        |
|              | - 处理射频信号检测                                           |
|              | - 解析NFC协议（ISO 14443, FeliCa, NFC-DEP等）                |
|              | - 管理数据交换流程                                           |
| **调度就绪** | 任务创建后立即进入就绪队列，等待GKI调度器在`GKI_run()`中开始执行 |

### 5. 整体启动流程关联

图表

代码







下载

<svg role="graphics-document document" viewBox="-13.8 -13.8 303.6 873.5999999999999" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-25" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(284.532px, 0px) scale(0.243265);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-25_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-25_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-25_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-25_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-25_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-25_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M138,62L138,66.167C138,70.333,138,78.667,138,86.333C138,94,138,101,138,104.5L138,108"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M138,166L138,170.167C138,174.333,138,182.667,138,190.333C138,198,138,205,138,208.5L138,212"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M138,270L138,274.167C138,278.333,138,286.667,138,294.333C138,302,138,309,138,312.5L138,316"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_0" d="M138,398L138,402.167C138,406.333,138,414.667,138,422.333C138,430,138,437,138,440.5L138,444"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_0" d="M138,502L138,506.167C138,510.333,138,518.667,138,526.333C138,534,138,541,138,544.5L138,548"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_0" d="M138,606L138,610.167C138,614.333,138,622.667,138,630.333C138,638,138,645,138,648.5L138,652"></path><path marker-end="url(#mermaid-svg-25_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_G_H_0" d="M138,710L138,714.167C138,718.333,138,726.667,138,734.333C138,742,138,749,138,752.5L138,756"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(138, 35)" id="flowchart-A-0" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">系统启动</p></span></div></foreignObject></g></g><g transform="translate(138, 139)" id="flowchart-B-1" class="node default"><rect height="54" width="117.09722137451172" y="-27" x="-58.54861068725586" style="" class="basic label-container"></rect><g transform="translate(-28.54861068725586, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="57.09722137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">GKI_init</p></span></div></foreignObject></g></g><g transform="translate(138, 243)" id="flowchart-C-3" class="node default"><rect height="54" width="140" y="-27" x="-70" style="" class="basic label-container"></rect><g transform="translate(-40, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="80"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">硬件初始化</p></span></div></foreignObject></g></g><g transform="translate(138, 359)" id="flowchart-D-5" class="node default"><rect height="78" width="260" y="-39" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">GKI_create_task NFCA_TASK</p></span></div></foreignObject></g></g><g transform="translate(138, 475)" id="flowchart-E-7" class="node default"><rect height="54" width="116.58333206176758" y="-27" x="-58.29166603088379" style="" class="basic label-container"></rect><g transform="translate(-28.29166603088379, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="56.58333206176758"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">GKI_run</p></span></div></foreignObject></g></g><g transform="translate(138, 579)" id="flowchart-F-9" class="node default"><rect height="54" width="172.09722137451172" y="-27" x="-86.04861068725586" style="" class="basic label-container"></rect><g transform="translate(-56.04861068725586, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="112.09722137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NFCA_TASK执行</p></span></div></foreignObject></g></g><g transform="translate(138, 683)" id="flowchart-G-11" class="node default"><rect height="54" width="184.18055725097656" y="-27" x="-92.09027862548828" style="" class="basic label-container"></rect><g transform="translate(-62.09027862548828, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="124.18055725097656"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">初始化NFC控制器</p></span></div></foreignObject></g></g><g transform="translate(138, 799)" id="flowchart-H-13" class="node default"><rect height="78" width="141.72222137451172" y="-39" x="-70.86111068725586" style="" class="basic label-container"></rect><g transform="translate(-40.86111068725586, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="81.72222137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">进入主循环<br>等待RF事件</p></span></div></foreignObject></g></g></g></g></g></svg>

### 6. 技术细节

1. **任务优先级**：
   - `BTU_TASK`通常具有最高优先级（基于 `30 - task_id - 2` 计算）
   - 确保NFC通信的实时性要求
2. **内存管理**：
   - 通过GKI缓冲区系统为NFC数据包提供预分配内存池
   - 避免动态内存分配导致的延迟碎片
3. **事件驱动**：
   - 创建的NFCA_TASK将通过`GKI_wait()`进入事件等待状态
   - 由射频中断或上层应用触发事件唤醒

### 7. 在NFC架构中的位置

plaintext



复制



下载

```
+-----------------------+
|     NFC应用层         |
+-----------------------+
|     NFC协议栈         |  <-- NFCA_TASK在此层运行
+-----------------------+
|     GKI抽象层         |  <-- 当前代码初始化的部分
+-----------------------+
|     HAL硬件抽象层      |
+-----------------------+
|     物理硬件层         |
+-----------------------+
```

这段代码本质上是**启动NFC协议栈的核心引擎**，它建立了NFC通信所需的任务执行环境，使NFCA_TASK能够响应射频事件、处理数据交换协议，最终实现近场通信功能。没有这个初始化过程，NFC系统将无法正常运行。









详细介绍一下GKI_create_task









已深度思考（用时 59 秒）



GKI_create_task函数是GKI（通用内核接口）系统中的一个关键函数，用于创建一个新的任务（线程）。在嵌入式或多任务环境中，它负责设置并启动一个新的执行线程。以下是对该函数的详细分析：

\### 函数原型

\```c

uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,

​                        uint16_t* stack, uint16_t stacksize, void* pCondVar,

​                        void* pMutex);

\```

\### 参数说明

1. **task_entry** (类型: `TASKPTR`)

   \- 新创建任务的入口函数指针。任务启动后将从这个函数开始执行。

2. **task_id** (类型: `uint8_t`)

   \- 分配给新任务的任务ID。该ID用于后续任务管理（如发送事件、设置状态等）。通常定义为0到`GKI_MAX_TASKS-1`之间的值。

3. **taskname** (类型: `int8_t*`)

   \- 任务名称字符串（用于调试和日志输出）。

4. **stack** (类型: `uint16_t*`)

   \- 指向任务栈内存的指针。如果为`NULL`，系统会自动分配栈空间（在Linux/pthread实现中通常如此）。

5. **stacksize** (类型: `uint16_t`)

   \- 任务栈的大小（以字节为单位）。在自动分配栈的实现中，此参数可能被忽略。

6. **pCondVar** (类型: `void*`)

   \- 条件变量指针（在特定平台实现中用于任务同步）。在Android等系统中，可能用于唤醒新创建的任务。

7. **pMutex** (类型: `void*`)

   \- 互斥锁指针（与条件变量配合使用）。

\### 返回值

\- `GKI_SUCCESS` (0): 任务创建成功。

\- `GKI_FAILURE` (非0): 任务创建失败（如任务ID超出范围或线程创建失败）。

\### 函数执行流程

1. **参数校验**：

   \- 检查`task_id`是否在有效范围内（小于`GKI_MAX_TASKS`），否则返回`GKI_FAILURE`。

2. **任务控制块初始化**：

   \- 设置任务状态为`TASK_READY`（准备就绪）。

   \- 存储任务名称指针到`gki_cb.com.OSTName[task_id]`。

   \- 初始化任务相关的等待时间(`OSWaitTmr`)和事件标志(`OSWaitEvt`)。

3. **同步对象初始化**：

   \- 初始化任务专用的事件互斥锁(`thread_evt_mutex`)和条件变量(`thread_evt_cond`)。

   \- 初始化任务专用的超时互斥锁(`thread_timeout_mutex`)和条件变量(`thread_timeout_cond`)。

4. **线程属性设置**：

   \- 使用`pthread_attr_init`初始化线程属性。

   \- 设置线程为分离状态（`PTHREAD_CREATE_DETACHED`）或可连接状态（根据`GKI_PTHREAD_JOINABLE`配置）。

5. **任务启动信息准备**：

   \- 填充`gki_pthread_info[task_id]`结构，包括：

​     \- `task_id`: 任务ID

​     \- `task_entry`: 任务入口函数

​     \- `params`: 额外参数（当前未使用）

​     \- `pCond`和`pMutex`: 传入的条件变量和互斥锁

6. **创建线程**：

   \- 调用`pthread_create`创建新线程：

​     \- 线程ID存储到`gki_cb.os.thread_id[task_id]`。

​     \- 线程入口函数为`gki_task_entry`（包装函数）。

​     \- 传递`&gki_pthread_info[task_id]`作为参数。

7. **线程调度参数设置**：

   \- 获取并调整新线程的调度策略和优先级：

​     \- 默认策略为`SCHED_RR`（循环调度）。

​     \- 优先级计算：`30 - task_id - 2`（任务ID越小优先级越高）。

\### 关键内部函数：`gki_task_entry`

\```c

void* gki_task_entry(void* params) {

  gki_pthread_info_t* p_info = (gki_pthread_info_t*)params;

  // 存储当前线程ID到全局控制块

  gki_cb.os.thread_id[p_info->task_id] = pthread_self();

  // 如果平台提供了条件变量和互斥锁，则通知创建者线程已就绪

  if (p_info->pCond && p_info->pMutex) {

​    pthread_mutex_lock(p_info->pMutex);

​    pthread_cond_signal(p_info->pCond);

​    pthread_mutex_unlock(p_info->pMutex);

  }

  // 调用实际的任务入口函数

  (p_info->task_entry)(p_info->params);

  // 任务结束处理

  gki_cb.os.thread_id[p_info->task_id] = 0; // 清除线程ID

  return NULL;

}

\```

\### 平台特定处理

\- **Android唤醒机制**：

  \- 当`pCondVar`和`pMutex`非空时，新线程在开始运行后会通过条件变量通知创建线程，确保任务完全启动后再继续执行。

\- **栈管理**：

  \- 在Linux/pthread实现中，`stack`和`stacksize`参数通常被忽略，因为pthread库自动管理线程栈。

\### 错误处理

\- 如果`pthread_create`失败：

  \- 打印错误日志（包含任务名称）。

  \- 返回`GKI_FAILURE`。

\### 总结

`GKI_create_task`是GKI系统多任务能力的核心，它：

1. 封装了底层线程创建细节（使用pthread API）。
2. 管理任务状态和同步对象。
3. 实现优先级调度控制。
4. 提供跨平台的任务创建接口。

该函数使得上层NFC协议栈（如NFCA_TASK）能够以标准化的方式在目标OS上运行，是NFC功能启动的关键步骤。

# GKI_create_task 函数详解

GKI_create_task 是通用内核接口(GKI)中的核心函数，用于在嵌入式系统中创建新的任务（线程）。它在NFC/BT协议栈中扮演着关键角色，负责初始化并启动处理特定功能的独立执行单元。

## 函数原型

c



复制



下载

```
uint8_t GKI_create_task(
    TASKPTR task_entry,    // 任务入口函数指针
    uint8_t task_id,       // 任务ID
    int8_t* taskname,      // 任务名称
    uint16_t* stack,       // 栈空间指针
    uint16_t stacksize,    // 栈大小
    void* pCondVar,        // 条件变量指针
    void* pMutex           // 互斥锁指针
);
```

## 参数详解

### 1. task_entry

- **类型**: `TASKPTR` (函数指针)
- **作用**: 任务的主函数入口
- **示例**: `(TASKPTR)NFCA_TASK`
- **说明**: 当任务被调度执行时，系统将从该函数开始运行

### 2. task_id

- **类型**: `uint8_t`
- **作用**: 唯一标识任务
- **范围**: 0 到 `GKI_MAX_TASKS-1`
- **特殊值**:
  - `BTU_TASK` (0): 通常用于主任务
  - `GKI_MAX_TASKS`: 保留值，不可用

### 3. taskname

- **类型**: `int8_t*`
- **作用**: 任务的可读名称
- **示例**: `(int8_t*)"NFCA_TASK"`
- **用途**: 调试、日志和系统监控

### 4. stack & stacksize

- **类型**: `uint16_t*` 和 `uint16_t`
- **作用**: 指定任务的栈空间
- **实际使用**:
  - 在Linux实现中通常为 `nullptr` 和 `0`
  - 系统自动管理栈分配
- **保留目的**: 兼容需要显式栈管理的嵌入式系统

### 5. pCondVar & pMutex

- **类型**: `void*`
- **作用**: 任务同步对象
- **Android特有**:
  - 用于任务启动时的同步
  - 新任务通过条件变量通知创建者已就绪
- **其他平台**: 通常为 `nullptr`

## 内部执行流程

图表

代码







下载

<svg role="graphics-document document" viewBox="-27.454505920410156 -27.454513549804688 603.9992980957031 1376.6451110839844" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-34" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(260.524px, 0px) scale(0.307117);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-34_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-34_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-34_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-34_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-34_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-34_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M219.99,62L219.99,66.167C219.99,70.333,219.99,78.667,219.99,86.333C219.99,94,219.99,101,219.99,104.5L219.99,108"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M219.99,166L219.99,170.167C219.99,174.333,219.99,182.667,220.06,190.417C220.13,198.167,220.271,205.334,220.341,208.917L220.411,212.501"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M182.279,326.151L168.787,338.603C155.295,351.054,128.311,375.958,114.819,393.909C101.326,411.861,101.326,422.861,101.326,428.361L101.326,433.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_E_0" d="M258.7,326.151L272.025,338.603C285.351,351.054,312.002,375.958,325.327,393.909C338.653,411.861,338.653,422.861,338.653,428.361L338.653,433.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_0" d="M338.653,491.861L338.653,496.028C338.653,500.194,338.653,508.528,338.653,516.194C338.653,523.861,338.653,530.861,338.653,534.361L338.653,537.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_0" d="M338.653,595.861L338.653,600.028C338.653,604.194,338.653,612.528,338.653,620.194C338.653,627.861,338.653,634.861,338.653,638.361L338.653,641.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_G_H_0" d="M338.653,699.861L338.653,704.028C338.653,708.194,338.653,716.528,338.653,724.194C338.653,731.861,338.653,738.861,338.653,742.361L338.653,745.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_I_0" d="M338.653,803.861L338.653,808.028C338.653,812.194,338.653,820.528,338.653,828.194C338.653,835.861,338.653,842.861,338.653,846.361L338.653,849.861"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_I_J_0" d="M338.653,907.861L338.653,912.028C338.653,916.194,338.653,924.528,338.723,932.278C338.793,940.028,338.934,947.195,339.004,950.778L339.074,954.362"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_K_0" d="M306.972,1050.055L294.418,1061.502C281.865,1072.949,256.759,1095.842,244.206,1112.789C231.653,1129.736,231.653,1140.736,231.653,1146.236L231.653,1151.736"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_L_0" d="M371.334,1050.055L383.72,1061.502C396.107,1072.949,420.88,1095.842,433.266,1112.789C445.653,1129.736,445.653,1140.736,445.653,1146.236L445.653,1151.736"></path><path marker-end="url(#mermaid-svg-34_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_L_M_0" d="M445.653,1209.736L445.653,1213.903C445.653,1218.069,445.653,1226.403,445.653,1234.069C445.653,1241.736,445.653,1248.736,445.653,1252.236L445.653,1255.736"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(101.32638549804688, 400.8611145019531)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">无效</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 400.8611145019531)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">有效</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(231.65277099609375, 1118.7361145019531)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">失败</p></span></div></foreignObject></g></g><g transform="translate(445.65277099609375, 1118.7361145019531)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">成功</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(219.9895782470703, 35)" id="flowchart-A-0" class="node default"><rect height="54" width="92" y="-27" x="-46" style="" class="basic label-container"></rect><g transform="translate(-16, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="32"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">开始</p></span></div></foreignObject></g></g><g transform="translate(219.9895782470703, 139)" id="flowchart-B-1" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">参数校验</p></span></div></foreignObject></g></g><g transform="translate(219.9895782470703, 289.93055725097656)" id="flowchart-C-3" class="node default"><polygon transform="translate(-73.93055725097656,73.93055725097656)" class="label-container" points="73.93055725097656,0 147.86111450195312,-73.93055725097656 73.93055725097656,-147.86111450195312 0,-73.93055725097656"></polygon><g transform="translate(-46.93055725097656, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="93.86111450195312"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">task_id 有效?</p></span></div></foreignObject></g></g><g transform="translate(101.32638549804688, 464.8611145019531)" id="flowchart-D-5" class="node default"><rect height="54" width="186.65277862548828" y="-27" x="-93.32638931274414" style="" class="basic label-container"></rect><g transform="translate(-63.32638931274414, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="126.65277862548828"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">返回 GKI_FAILURE</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 464.8611145019531)" id="flowchart-E-7" class="node default"><rect height="54" width="188" y="-27" x="-94" style="" class="basic label-container"></rect><g transform="translate(-64, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="128"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">初始化任务控制块</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 568.8611145019531)" id="flowchart-F-9" class="node default"><rect height="54" width="188" y="-27" x="-94" style="" class="basic label-container"></rect><g transform="translate(-64, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="128"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">创建任务同步对象</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 672.8611145019531)" id="flowchart-G-11" class="node default"><rect height="54" width="156" y="-27" x="-78" style="" class="basic label-container"></rect><g transform="translate(-48, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">设置线程属性</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 776.8611145019531)" id="flowchart-H-13" class="node default"><rect height="54" width="188" y="-27" x="-94" style="" class="basic label-container"></rect><g transform="translate(-64, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="128"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">准备任务启动信息</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 880.8611145019531)" id="flowchart-I-15" class="node default"><rect height="54" width="180.27777862548828" y="-27" x="-90.13888931274414" style="" class="basic label-container"></rect><g transform="translate(-60.13888931274414, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.27777862548828"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">创建pthread线程</p></span></div></foreignObject></g></g><g transform="translate(338.65277099609375, 1019.7986145019531)" id="flowchart-J-17" class="node default"><polygon transform="translate(-61.9375,61.9375)" class="label-container" points="61.9375,0 123.875,-61.9375 61.9375,-123.875 0,-61.9375"></polygon><g transform="translate(-34.9375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="69.875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">创建成功?</p></span></div></foreignObject></g></g><g transform="translate(231.65277099609375, 1182.7361145019531)" id="flowchart-K-19" class="node default"><rect height="54" width="172" y="-27" x="-86" style="" class="basic label-container"></rect><g transform="translate(-56, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="112"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">记录错误并返回</p></span></div></foreignObject></g></g><g transform="translate(445.65277099609375, 1182.7361145019531)" id="flowchart-L-21" class="node default"><rect height="54" width="156" y="-27" x="-78" style="" class="basic label-container"></rect><g transform="translate(-48, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">设置调度策略</p></span></div></foreignObject></g></g><g transform="translate(445.65277099609375, 1286.7361145019531)" id="flowchart-M-23" class="node default"><rect height="54" width="190.875" y="-27" x="-95.4375" style="" class="basic label-container"></rect><g transform="translate(-65.4375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="130.875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">返回 GKI_SUCCESS</p></span></div></foreignObject></g></g></g></g></g></svg>

### 详细步骤解析

1. **参数校验**

   - 检查 `task_id < GKI_MAX_TASKS`
   - 无效时返回 `GKI_FAILURE`

2. **任务控制块初始化**

   c

   

   复制

   

   下载

   ```
   gki_cb.com.OSRdyTbl[task_id] = TASK_READY;  // 设置任务为就绪状态
   gki_cb.com.OSTName[task_id] = taskname;     // 存储任务名称
   gki_cb.com.OSWaitTmr[task_id] = 0;          // 初始化等待计时器
   gki_cb.com.OSWaitEvt[task_id] = 0;          // 初始化事件标志
   ```

3. **同步对象创建**

   c

   

   复制

   

   下载

   ```
   // 事件同步对象
   pthread_mutex_init(&gki_cb.os.thread_evt_mutex[task_id], NULL);
   pthread_cond_init(&gki_cb.os.thread_evt_cond[task_id], &attr);
   
   // 超时同步对象
   pthread_mutex_init(&gki_cb.os.thread_timeout_mutex[task_id], NULL);
   pthread_cond_init(&gki_cb.os.thread_timeout_cond[task_id], &attr);
   ```

4. **线程属性配置**

   c

   

   复制

   

   下载

   ```
   pthread_attr_init(&attr1);
   #if (FALSE == GKI_PTHREAD_JOINABLE)
   pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_DETACHED);
   #endif
   ```

5. **任务启动信息准备**

   c

   

   复制

   

   下载

   ```
   gki_pthread_info[task_id].task_id = task_id;
   gki_pthread_info[task_id].task_entry = task_entry;
   gki_pthread_info[task_id].params = 0;
   gki_pthread_info[task_id].pCond = (pthread_cond_t*)pCondVar;
   gki_pthread_info[task_id].pMutex = (pthread_mutex_t*)pMutex;
   ```

6. **线程创建**

   c

   

   复制

   

   下载

   ```
   ret = pthread_create(&gki_cb.os.thread_id[task_id], 
                       &attr1, 
                       gki_task_entry, 
                       &gki_pthread_info[task_id]);
   ```

7. **调度策略设置**

   c

   

   复制

   

   下载

   ```
   // 获取当前调度策略
   pthread_getschedparam(gki_cb.os.thread_id[task_id], &policy, &param);
   
   // 设置优先级
   policy = SCHED_RR;  // 实时轮转调度
   param.sched_priority = 30 - task_id - 2; // 任务ID越小优先级越高
   
   // 应用新策略
   pthread_setschedparam(gki_cb.os.thread_id[task_id], policy, &param);
   ```

## 任务入口包装器：gki_task_entry

c



复制



下载

```
void* gki_task_entry(void* params) {
  gki_pthread_info_t* p_info = (gki_pthread_info_t*)params;
  
  // 1. 存储线程ID
  gki_cb.os.thread_id[p_info->task_id] = pthread_self();
  
  // 2. Android同步通知
  if (p_info->pCond && p_info->pMutex) {
    pthread_mutex_lock(p_info->pMutex);
    pthread_cond_signal(p_info->pCond);
    pthread_mutex_unlock(p_info->pMutex);
  }
  
  // 3. 调用实际任务函数
  (p_info->task_entry)(p_info->params);
  
  // 4. 任务结束处理
  #if (FALSE == GKI_PTHREAD_JOINABLE)
  gki_cb.os.thread_id[p_info->task_id] = 0;
  #endif
  
  return NULL;
}
```

## 在NFC启动中的关键作用

1. **NFCA任务创建**

   c

   

   复制

   

   下载

   ```
   GKI_create_task((TASKPTR)NFCA_TASK, BTU_TASK, 
                  (int8_t*)"NFCA_TASK", nullptr, 0, 
                  nullptr, nullptr);
   ```

   - 创建NFC核心任务（NFCA_TASK）
   - 分配最高优先级（BTU_TASK=0）
   - 确保NFC通信的实时性

2. **优先级体系**

   | 任务ID | 计算优先级 | 典型任务     |
   | :----- | :--------- | :----------- |
   | 0      | 28         | NFCA_TASK    |
   | 1      | 27         | BTU_TASK     |
   | 2      | 26         | 其他后台任务 |

3. **同步机制**

   - 为每个任务创建专用的事件和超时条件变量
   - 实现`GKI_wait()`和`GKI_send_event()`的基础

4. **资源管理**

   - 自动管理任务控制块
   - 封装底层线程创建细节

## 设计特点与优势

1. **跨平台抽象**
   - 封装pthread API
   - 提供统一任务接口
   - 屏蔽OS差异
2. **实时性保障**
   - 使用SCHED_RR调度策略
   - 精确控制任务优先级
   - 确保NFC通信时效性
3. **安全启动**
   - Android同步机制防止竞态条件
   - 参数校验避免无效任务创建
4. **资源优化**
   - 可选DETACHED模式减少资源占用
   - 共享条件变量属性减少开销

## 典型使用场景

c



复制



下载

```
// NFC协议栈初始化
void nfc_init() {
    GKI_init();
    GKI_enable();
    
    // 创建NFC主任务
    GKI_create_task(NFCA_TASK_ENTRY, NFC_TASK_ID, 
                   "NFCA_TASK", NULL, 0, NULL, NULL);
    
    // 创建其他支持任务
    GKI_create_task(RF_MANAGER_ENTRY, RF_TASK_ID, 
                   "RF_MGR", NULL, 0, NULL, NULL);
    
    // 启动调度器
    GKI_run();
}
```

## 总结

GKI_create_task 是NFC/BT协议栈任务系统的核心构建块，它：

1. 提供跨平台的任务创建抽象
2. 实现精细的优先级控制系统
3. 封装线程同步原语
4. 确保关键任务（如NFCA_TASK）实时执行
5. 为协议栈提供稳定可靠的多任务环境

通过该函数创建的NFCA_TASK将成为NFC系统的核心引擎，负责处理射频通信、协议解析和数据交换等关键功能，是整个NFC功能正常运行的基石。









那是怎样启动hal层的，hal层的调度是怎么样子的









已深度思考（用时 52 秒）



我们讨论的上下文是NFC协议栈的启动，其中GKI_create_task创建了NFCA_TASK任务。现在问题转向HAL层（硬件抽象层）的启动和调度机制。在NFC系统中，HAL层负责与硬件（NFC控制器）通信，而协议栈的任务（如NFCA_TASK）会通过HAL层的接口与硬件交互。

 首先，需要明确：HAL层通常不是通过GKI_create_task创建的任务，而是由协议栈任务（如NFCA_TASK）在运行过程中初始化和调用的。

 整个NFC系统的层次结构通常如下：

1. 应用层
2. 协议栈层（如NCI、LLCP等）
3. HAL层（硬件抽象层）
4. 驱动层（如I2C、SPI等）

 在启动过程中：

 \- GKI_init()初始化内核环境。

 \- GKI_create_task()创建协议栈任务（如NFCA_TASK）。

 \- 然后，当NFCA_TASK任务运行时，它会初始化协议栈，并调用HAL层的初始化函数。

 因此，HAL层的启动是由协议栈任务（NFCA_TASK）触发的，而不是由GKI直接创建任务。

 关于HAL层的调度：

 \- HAL层通常不包含独立的任务（线程），而是以函数库的形式存在。

 \- 协议栈任务（如NFCA_TASK）在需要与硬件交互时，调用HAL层的函数，这些函数会通过驱动接口访问硬件。

 \- 由于硬件操作可能是阻塞的（如I2C读写），因此HAL层的函数可能会引起任务阻塞，直到操作完成（通过中断或轮询完成）。

 但是，在某些设计中，HAL层也可能有自己的执行线程（比如用于处理硬件中断产生的事件）。这种情况下，HAL层的线程可能是由协议栈任务在初始化HAL时创建的（但通常不是通过GKI_create_task，而是直接使用操作系统线程创建函数）。

 在Android NFC HAL中，通常采用以下方式：

1. 协议栈任务（NFCA_TASK）在运行过程中会调用HAL层的初始化函数，比如`hal_open`。
2. 在`hal_open`中，可能会创建一个线程来监听来自硬件的异步事件（比如中断）。这个线程会循环等待事件，当事件发生时，它通过回调函数通知协议栈任务。
3. 协议栈任务与HAL层的交互是同步的（调用函数发送命令）和异步的（HAL层的事件线程通过回调通知协议栈）的结合。

 具体到代码实现，HAL层的调度机制可能如下：

1. 发送命令（协议栈->HAL）：

​    \- 协议栈任务调用HAL层的发送函数（如`hal_write`）。

​    \- 该函数通过I2C等驱动将命令发送给硬件，并等待响应（可能阻塞，也可能非阻塞）。

2. 接收事件（HAL->协议栈）：

​    \- HAL层有一个事件监听线程（可能在HAL初始化时创建）。

​    \- 该线程阻塞在读取硬件的操作上（如I2C读），或者阻塞在等待硬件中断的事件上。

​    \- 当硬件有事件（如数据到达）时，该线程被唤醒，读取数据，然后通过回调函数（callback）将事件传递给协议栈任务。

​    \- 这个回调通常是通过向协议栈任务发送事件（使用GKI_send_event）来完成的，这样协议栈任务就会在它的主循环中处理这个事件。

 因此，HAL层的事件线程与协议栈任务之间的通信是通过GKI的事件机制来实现的。

 总结：

1. HAL层本身不是一个独立的任务（由GKI_create_task创建），但是HAL层可能会在初始化时创建自己的线程（使用pthread_create等）。
2. 协议栈任务（NFCA_TASK）通过调用HAL函数与硬件交互。
3. HAL层的事件线程负责监听硬件事件，并通过GKI_send_event通知协议栈任务。

 注意：在Android的NFC实现中，HAL层是符合Android HAL标准的，它定义了一个接口（如`nfc_nci.h`），由厂商实现。在接口中，通常包括：

   \- open/close

   \- core_initialized

   \- write

   \- ...

 协议栈任务（NFCA_TASK）通过调用这些接口函数与硬件交互。

 示例流程：

1. NFCA_TASK启动后，首先调用`hal_open`，该函数会打开设备，创建事件监听线程。
2. 事件监听线程开始运行，阻塞在读取设备的事件上。
3. NFCA_TASK继续初始化协议栈，发送初始化命令（通过`hal_write`），然后等待响应。
4. 事件监听线程读取到硬件响应后，通过回调函数（该回调函数由协议栈在初始化时注册）将数据传递给协议栈。协议栈通过GKI_send_event向自身发送一个事件（如HAL_RX_EVT）。
5. NFCA_TASK在它的主循环中等待事件（GKI_wait），当收到HAL_RX_EVT事件时，它调用处理函数来处理硬件响应。

 因此，HAL层的调度实际上是由协议栈任务和HAL事件线程共同协作完成的，而协议栈任务与HAL事件线程之间的通信是通过事件（GKI事件）来完成的。

# NFC HAL层的启动与调度机制详解

## HAL层启动流程

### 1. 整体启动序列

图表

代码







下载

设备驱动HAL层NFCA_TASK应用层设备驱动HAL层NFCA_TASK应用层触发NFC使能调用hal_open()初始化硬件寄存器返回状态返回初始化结果发送NCI初始化命令写入命令寄存器产生中断响应通过回调通知结果

### 2. HAL层初始化关键步骤

#### (1) 硬件抽象层初始化

c



复制



下载

```
// nfc_hal_impl.cpp
int hal_open(hal_event_callback_t event_cb) {
    // 1. 打开底层设备驱动
    fd = open("/dev/pn54x", O_RDWR);
    
    // 2. 创建HAL事件处理线程
    pthread_create(&hal_thread, NULL, hal_event_thread, NULL);
    
    // 3. 配置硬件参数
    ioctl(fd, NFC_SET_POWER, POWER_ON);
    
    // 4. 注册事件回调
    g_event_cb = event_cb;
    
    // 5. 加载固件
    nfc_load_firmware(fd);
    
    return NFC_STATUS_OK;
}
```

#### (2) HAL事件线程创建

c



复制



下载

```
void* hal_event_thread(void* arg) {
    struct pollfd fds[1];
    fds[0].fd = g_hal_fd;
    fds[0].events = POLLIN;
    
    while (g_hal_running) {
        // 阻塞等待硬件事件
        int ret = poll(fds, 1, 100);
        
        if (ret > 0) {
            if (fds[0].revents & POLLIN) {
                // 读取硬件数据
                uint8_t buffer[256];
                read(g_hal_fd, buffer, sizeof(buffer));
                
                // 转换为NCI事件
                tNFC_HAL_EVT event = parse_hal_event(buffer);
                
                // 回调通知协议栈
                g_event_cb(event);
            }
        }
    }
    return NULL;
}
```

## HAL层调度机制

### 1. 双通道调度架构

图表

代码







下载

<svg role="graphics-document document" viewBox="-9.05 -9.05 392.21111450195315 199.10000000000002" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-32" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(0px, 2.9445px) scale(1);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-32_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-32_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-32_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-32_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-32_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-32_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-32_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M148.097,29.87L157.597,28.225C167.097,26.58,186.097,23.29,204.496,25.89C222.894,28.49,240.69,36.979,249.589,41.224L258.487,45.469"></path><path marker-end="url(#mermaid-svg-32_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_B_0" d="M140.049,146L150.89,146C161.731,146,183.414,146,205.243,138.541C227.072,131.082,249.047,116.164,260.034,108.706L271.022,101.247"></path><path marker-end="url(#mermaid-svg-32_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_A_0" d="M262.097,72L252.597,72C243.097,72,224.097,72,205.746,69.91C187.395,67.82,169.693,63.64,160.841,61.55L151.99,59.46"></path></g><g class="edgeLabels"><g transform="translate(205.09722900390625, 20)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">命令通道</p></span></div></foreignObject></g></g><g transform="translate(205.09722900390625, 146)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">事件通道</p></span></div></foreignObject></g></g><g transform="translate(205.09722900390625, 72)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">回调通知</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(78.04861450195312, 42)" id="flowchart-A-0" class="node default"><rect height="54" width="140.09722137451172" y="-27" x="-70.04861068725586" style="" class="basic label-container"></rect><g transform="translate(-40.04861068725586, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="80.09722137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NFCA_TASK</p></span></div></foreignObject></g></g><g transform="translate(314.1041717529297, 72)" id="flowchart-B-1" class="node default"><rect height="54" width="104.01388931274414" y="-27" x="-52.00694465637207" style="" class="basic label-container"></rect><g transform="translate(-22.00694465637207, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="44.01388931274414"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">HAL层</p></span></div></foreignObject></g></g><g transform="translate(78.04861450195312, 146)" id="flowchart-C-2" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">硬件中断</p></span></div></foreignObject></g></g></g></g></g></svg>

### 2. 命令处理流程

c



复制



下载

```
void hal_write(const uint8_t* data, size_t len) {
    // 1. 获取硬件锁
    pthread_mutex_lock(&hal_mutex);
    
    // 2. 写入设备
    write(g_hal_fd, data, len);
    
    // 3. 启动超时计时器
    start_response_timer();
    
    // 4. 释放锁
    pthread_mutex_unlock(&hal_mutex);
}
```

### 3. 事件处理流程

c



复制



下载

```
void hal_event_handler(tHAL_NFC_EVENT event, tHAL_NFC_STATUS status) {
    switch (event) {
        case HAL_NFC_OPEN_CPLT_EVT:
            // 处理设备打开完成事件
            nfa_dm_hal_open_complete(status);
            break;
            
        case HAL_NFC_DATA_EVT:
            // 处理接收数据事件
            nfc_ncif_process_data((uint8_t*)p_data, len);
            break;
            
        case HAL_NFC_ERROR_EVT:
            // 处理错误事件
            nfc_error_handler(status);
            break;
    }
}
```

### 4. 优先级管理机制

#### HAL层优先级体系：

| 优先级   | 事件类型   | 响应时间要求 |
| :------- | :--------- | :----------- |
| 0 (最高) | 硬件错误   | < 10ms       |
| 1        | RF发现通知 | < 50ms       |
| 2        | 数据接收   | < 100ms      |
| 3        | 命令响应   | < 200ms      |
| 4 (最低) | 状态通知   | > 200ms      |

#### 实现代码：

c



复制



下载

```
void hal_process_event_queue() {
    while (!priority_queue_empty()) {
        hal_event_t event = priority_queue_pop();
        
        switch (event.priority) {
            case PRIORITY_CRITICAL:
                handle_critical_event(event);
                break;
                
            case PRIORITY_HIGH:
                if (can_preempt()) handle_high_priority(event);
                else queue_push_front(event); // 重新排队
                break;
                
            default:
                handle_normal_event(event);
        }
    }
}
```

## HAL层与协议栈的交互

### 1. 关键接口函数

| 接口函数               | 调用方向 | 功能描述        |
| :--------------------- | :------- | :-------------- |
| `hal_open()`           | NFCA→HAL | 初始化NFC控制器 |
| `hal_write()`          | NFCA→HAL | 发送NCI命令     |
| `hal_event_callback()` | HAL→NFCA | 事件通知回调    |
| `hal_core_reset()`     | NFCA→HAL | 复位NFC控制器   |
| `hal_power_cycle()`    | NFCA→HAL | 电源周期管理    |

### 2. 典型交互场景：标签发现

图表

代码







下载

硬件HAL层NFCA_TASK硬件HAL层NFCA_TASKhal_write(DISCOVER_CMD)发送RF发现命令检测到标签(中断)读取标签数据hal_event_callback(TAG_DETECTED)hal_write(ACTIVATE_CMD)激活标签通信返回标签IDhal_event_callback(TAG_ACTIVATED)

## 中断处理机制

### 1. 中断处理流程

c



复制



下载

```
// 驱动层中断处理
irqreturn_t nfc_interrupt(int irq, void *dev_id) {
    // 1. 读取中断状态寄存器
    uint32_t status = readl(reg_base + INT_STATUS_REG);
    
    // 2. 确认中断
    writel(status, reg_base + INT_CLEAR_REG);
    
    // 3. 分类处理
    if (status & DATA_RX_INT) {
        wake_up_interruptible(&rx_wait_queue);
    }
    else if (status & ERROR_INT) {
        schedule_work(&error_work);
    }
    
    return IRQ_HANDLED;
}

// HAL层数据处理
static void data_rx_worker(struct work_struct *work) {
    uint8_t buffer[MAX_BUFFER_SIZE];
    
    // 1. 从硬件FIFO读取数据
    int len = nfc_read_data(buffer);
    
    // 2. 生成NCI事件
    tNFC_HAL_EVT event = {
        .event = HAL_NFC_DATA_EVT,
        .data = buffer,
        .len = len
    };
    
    // 3. 投递到协议栈
    post_hal_event(event, PRIORITY_HIGH);
}
```

### 2. 中断优化技术

1. **嵌套中断处理**：

   - 高优先级中断可抢占低优先级处理
   - 实现硬件错误即时响应

2. **批处理优化**：

   c

   

   复制

   

   下载

   ```
   while (has_more_data()) {
       process_data_chunk();
       if (time_exceeded(MAX_ISR_TIME)) 
           break; // 剩余数据下次处理
   }
   ```

3. **软中断分流**：

   - 时间敏感操作在硬中断处理
   - 数据解析等耗时操作移交工作队列

## 电源管理调度

### 1. 电源状态机

图表

代码







下载

<svg role="graphics-document document" viewBox="-15.186285400390625 -15.186285400390625 334.0982788085937 378.3725708007812" class="statediagram mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-30" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(143.602px, 0px) scale(0.618079);"><g><defs><marker orient="auto" markerUnits="userSpaceOnUse" markerHeight="14" markerWidth="20" refY="7" refX="19" id="mermaid-svg-30_stateDiagram-barbEnd"><path d="M 19,7 L9,13 L14,7 L9,1 Z"></path></marker></defs><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge0" d="M161.295,22L161.295,26.167C161.295,30.333,161.295,38.667,161.295,47C161.295,55.333,161.295,63.667,161.295,67.833L161.295,72"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge1" d="M137.852,112L130.624,118.167C123.396,124.333,108.939,136.667,108.939,149C108.939,161.333,123.396,173.667,130.624,179.833L137.852,186"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge2" d="M121.753,224.715L108.271,231.096C94.789,237.476,67.825,250.238,58.98,262.786C50.135,275.333,59.409,287.667,64.046,293.833L68.683,300"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge3" d="M98.761,300L103.398,293.833C108.035,287.667,117.309,275.333,125.702,263C134.094,250.667,141.605,238.333,145.36,232.167L149.116,226"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge4" d="M173.376,226L177.101,232.167C180.826,238.333,188.276,250.667,195.679,263C203.082,275.333,210.439,287.667,214.118,293.833L217.796,300"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge5" d="M241.656,300L245.334,293.833C249.012,287.667,256.369,275.333,248.966,263C241.562,250.667,219.399,238.333,208.317,232.167L197.236,226"></path><path marker-end="url(#mermaid-svg-30_stateDiagram-barbEnd)" style="fill:none;" class="edge-thickness-normal edge-pattern-solid transition" id="edge6" d="M184.738,186L191.966,179.833C199.195,173.667,213.651,161.333,213.651,149C213.651,136.667,199.195,124.333,191.966,118.167L184.738,112"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"></span></div></foreignObject></g></g><g transform="translate(94.48263740539551, 149)" class="edgeLabel"><g transform="translate(-56.04166793823242, -12)" class="label"><foreignObject height="24" width="112.08333587646484"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">hal_power_on()</p></span></div></foreignObject></g></g><g transform="translate(40.86111068725586, 263)" class="edgeLabel"><g transform="translate(-32.86111068725586, -12)" class="label"><foreignObject height="24" width="65.72222137451172"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">RF场激活</p></span></div></foreignObject></g></g><g transform="translate(126.58333206176758, 263)" class="edgeLabel"><g transform="translate(-32.86111068725586, -12)" class="label"><foreignObject height="24" width="65.72222137451172"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">RF场消失</p></span></div></foreignObject></g></g><g transform="translate(195.72569274902344, 263)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">超时</p></span></div></foreignObject></g></g><g transform="translate(263.72569274902344, 263)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">事件触发</p></span></div></foreignObject></g></g><g transform="translate(228.1076374053955, 149)" class="edgeLabel"><g transform="translate(-57.58333206176758, -12)" class="label"><foreignObject height="24" width="115.16666412353516"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="background-color: rgb(88, 88, 88); text-align: center; color: rgb(204, 204, 204);"><p style="margin: 0px; background-color: rgb(88, 88, 88);">hal_power_off()</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(161.2951374053955, 15)" id="state-root_start-0" class="node default"><circle height="14" width="14" r="7" class="state-start"></circle></g><g transform="translate(161.2951374053955, 92)" id="state-POWER_OFF-6" class="node  statediagram-state"><rect height="40" width="103.19444274902344" y="-20" x="-51.59722137451172" ry="5" rx="5" style="" class="basic label-container"></rect><g transform="translate(-43.59722137451172, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="87.19444274902344"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="color: rgb(224, 223, 223);"><p style="margin: 0px;">POWER_OFF</p></span></div></foreignObject></g></g><g transform="translate(161.2951374053955, 206)" id="state-STANDBY-6" class="node  statediagram-state"><rect height="40" width="79.08333206176758" y="-20" x="-39.54166603088379" ry="5" rx="5" style="" class="basic label-container"></rect><g transform="translate(-31.54166603088379, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="63.08333206176758"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="color: rgb(224, 223, 223);"><p style="margin: 0px;">STANDBY</p></span></div></foreignObject></g></g><g transform="translate(83.72222137451172, 320)" id="state-ACTIVE-3" class="node  statediagram-state"><rect height="40" width="66.72222137451172" y="-20" x="-33.36111068725586" ry="5" rx="5" style="" class="basic label-container"></rect><g transform="translate(-25.36111068725586, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="50.72222137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="color: rgb(224, 223, 223);"><p style="margin: 0px;">ACTIVE</p></span></div></foreignObject></g></g><g transform="translate(229.72569274902344, 320)" id="state-LOW_POWER-5" class="node  statediagram-state"><rect height="40" width="108.125" y="-20" x="-54.0625" ry="5" rx="5" style="" class="basic label-container"></rect><g transform="translate(-46.0625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="92.125"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="color: rgb(224, 223, 223);"><p style="margin: 0px;">LOW_POWER</p></span></div></foreignObject></g></g></g></g></g></svg>

### 2. 电源管理接口

c



复制



下载

```
void hal_power_management(bool enable) {
    if (enable) {
        // 进入低功耗模式
        ioctl(fd, NFC_SET_POWER_MODE, LOW_POWER);
        set_polling_interval(1000); // 降低轮询频率
    } else {
        // 恢复全功率模式
        ioctl(fd, NFC_SET_POWER_MODE, FULL_POWER);
        set_polling_interval(50); // 正常轮询频率
    }
}
```

## 性能优化技术

### 1. 零拷贝数据传输

c



复制



下载

```
void hal_handle_rx_data() {
    // 1. 直接映射DMA缓冲区
    void *dma_buf = mmap_device_dma(rx_dma_handle);
    
    // 2. 协议栈直接访问
    g_event_cb(HAL_NFC_DATA_EVT, dma_buf, len);
    
    // 3. 处理完成后解除映射
    munmap_device_dma(dma_buf);
}
```

### 2. 命令流水线处理

c



复制



下载

```
void hal_write_pipelined(const uint8_t *cmd1, const uint8_t *cmd2) {
    // 1. 同时提交多个命令
    dma_submit(cmd1, len1);
    dma_submit(cmd2, len2);
    
    // 2. 等待最后一个响应
    wait_for_response(LAST_CMD_TOKEN);
}
```

### 3. 自适应轮询机制

c



复制



下载

```
void hal_adjust_polling() {
    // 根据RF场强度动态调整轮询间隔
    if (rf_field_strength > THRESHOLD_HIGH) {
        interval = MIN_POLL_INTERVAL;
    } 
    else if (rf_field_strength > THRESHOLD_LOW) {
        interval = DEFAULT_POLL_INTERVAL;
    }
    else {
        interval = MAX_POLL_INTERVAL;
    }
    
    set_polling_timer(interval);
}
```

## 总结：HAL层调度特点

1. **事件驱动架构**：
   - 硬件中断触发事件
   - 优先级队列调度处理
   - 回调机制通知协议栈
2. **双通道通信**：
   - 下行命令通道（协议栈→HAL）
   - 上行事件通道（HAL→协议栈）
3. **实时性保障**：
   - 中断嵌套处理
   - 优先级抢占
   - 硬件加速
4. **资源优化**：
   - DMA零拷贝传输
   - 动态电源管理
   - 自适应轮询
5. **分层隔离**：
   - 硬件细节封装在驱动层
   - 协议规范实现在HAL
   - 提供标准接口给协议栈

通过这种设计，HAL层在保证实时性能的同时，实现了硬件与协议栈的解耦，使NFC系统能够高效、稳定地运行在各种硬件平台上。









nativenfcmanager.cpp中nfcManager_doInitialize的nfa_init（）,和nfa_enable（）是怎么工作的









已深度思考（用时 64 秒）



在 `nfcManager_doInitialize` 函数中，`nfa_init()` 和 `nfa_enable()` 是初始化 NFC 协议栈并启用 NFC 功能的关键步骤。下面我将详细解释这两个函数的工作过程及其在 NFC 启动中的作用。

\### 1. `nfa_init()`

`nfa_init()` 函数用于初始化 NFC 协议栈的各个模块。它设置全局变量和回调函数，准备 NFC 协议栈运行所需的环境。

\#### 主要工作内容：

1. **初始化控制块**：

   \- 清除 NFA 控制块（`nfa_cb`）的内容，确保从干净的状态开始。

   \- 设置默认状态和配置。

2. **注册回调函数**：

   \- 设置 DM（设备管理）和 NFA 之间的回调接口，使得事件可以在协议栈的不同层之间传递。

   \- 例如，设置 `nfa_dm_cb.p_dm_cback` 指向 `nfa_dm_evt_hdlr` 函数，该函数用于处理来自下层的设备管理事件。

3. **初始化子模块**：

   \- 调用 `nfa_dm_init()` 初始化设备管理模块。

   \- 调用 `nfa_p2p_init()` 初始化点对点模块（用于 LLCP 和 SNEP）。

   \- 调用 `nfa_snep_init()` 初始化 SNEP 协议模块。

   \- 调用 `nfa_ee_init()` 初始化执行环境（NFC 控制器中的多个执行环境，如 SIM 卡、嵌入式安全元件等）。

   \- 调用 `nfa_hci_init()` 初始化主机控制器接口（如果支持 HCI）。

4. **设置默认配置**：

   \- 初始化协议栈的默认配置参数，如 RF 发现频率、超时时间等。

\#### 代码示例（简化）：

\```c++

void nfa_init(void) {

  memset(&nfa_cb, 0, sizeof(tNFA_CB));

  /* 注册 DM 回调 */

  nfa_dm_cb.p_dm_cback = nfa_dm_evt_hdlr;

  /* 初始化子模块 */

  nfa_dm_init();

  nfa_p2p_init();

  nfa_snep_init();

  nfa_ee_init();

  nfa_hci_init();

  /* 其他初始化 */

  ...

}

\```

\### 2. `nfa_enable()`

`nfa_enable()` 函数用于启动 NFC 协议栈。在调用 `nfa_init()` 初始化后，调用 `nfa_enable()` 来激活 NFC 功能，包括启动 RF 发现过程。

\#### 主要工作内容：

1. **设置启用完成回调**：

   \- 函数参数中传入一个回调函数指针（`nfa_dm_enable_cplt_callback`），当 NFC 协议栈完全启动后，将通过该回调通知上层。

2. **配置非易失性内存（NVRAM）**：

   \- 从存储设备（如 flash）中读取 NFC 相关的配置数据（如使能状态、RF 配置等）。

3. **启动 NFA 设备管理（DM）模块**：

   \- 调用 `nfa_dm_enable()` 函数，该函数负责：

​     \- 初始化底层硬件（通过 HAL 层）。

​     \- 注册事件处理函数。

​     \- 设置协议栈状态为正在启动。

4. **处理启动序列**：

   \- 发送 `NFA_DM_API_ENABLE_EVT` 事件到 NFA DM 模块的任务队列。

   \- 在 `nfa_dm_enable()` 中，会进一步调用 `nfc_enable()`（这是更底层的 NFC 控制器初始化函数）。

5. **底层初始化流程**：

   \- `nfc_enable()` 会初始化 NFC 控制器（通过 HAL 层的 `hal_open` 等函数），加载固件，配置参数。

   \- 完成后，通过回调函数通知 NFA DM 模块。

6. **发送启用完成事件**：

   \- 当底层初始化完成且 NFC 控制器就绪后，NFA DM 模块会发送 `NFA_DM_ENABLE_EVT` 事件。

   \- 最终调用上层传入的回调函数（`nfa_dm_enable_cplt_callback`），通知 NFC 协议栈已启动。

\#### 代码示例（简化）：

\```c++

void nfa_enable(tNFA_DM_CBACK* p_cback, tNFA_ENABLE_CBACK* p_enable_cback) {

  tNFA_DM_API_ENABLE dm_api_enable;

  /* 设置启用完成回调 */

  nfa_dm_cb.p_enable_cback = p_enable_cback;

  /* 构建并发送启用事件 */

  dm_api_enable.hdr.event = NFA_DM_API_ENABLE_EVT;

  dm_api_enable.p_dm_cback = p_cback;

  nfa_sys_sendmsg(&dm_api_enable);

}

/* 在 NFA DM 模块中处理启用事件 */

void nfa_dm_enable(tNFA_DM_MSG* p_data) {

  tNFA_DM_API_ENABLE* p_enable = (tNFA_DM_API_ENABLE*)p_data;

  /* 保存回调函数 */

  nfa_dm_cb.p_dm_cback = p_enable->p_dm_cback;

  /* 调用底层 NFC_Enable */

  nfc_enable(nfa_dm_module_init_cback);

}

/* 底层初始化完成后的回调 */

static void nfa_dm_module_init_cback(tNFC_STATUS status) {

  if (status == NFC_STATUS_OK) {

​    /* 设置状态为已启用 */

​    nfa_dm_cb.flags |= NFA_DM_FLAGS_ENABLED;

​    /* 通知上层 */

​    if (nfa_dm_cb.p_enable_cback) {

​      nfa_dm_cb.p_enable_cback(NFA_STATUS_OK);

​    }

  }

}

\```

\### 在 `nfcManager_doInitialize` 中的调用流程

在 Android 的 `nfcManager_doInitialize` 函数中，这两个函数被调用来初始化并启用 NFC 协议栈：

1. **初始化 NFA**：

   \```c++

   nfa_init();

   \```

2. **启用 NFA**：

   \```c++

   nfa_enable(&nfa_dm_cback, nfaDeviceManagementCallback);

   \```

   \- 其中 `nfa_dm_cback` 是处理 NFA 事件的回调函数集合。

   \- `nfaDeviceManagementCallback` 是当启用完成时调用的回调函数。

\### 总结

\- **`nfa_init()`**：负责初始化协议栈的各个模块，设置回调接口，准备运行环境。

\- **`nfa_enable()`**：启动协议栈，初始化底层硬件，加载配置，并最终激活 NFC 功能。完成后通过回调通知上层。

这两个函数是 NFC 协议栈启动的核心步骤，确保协议栈从初始化状态进入可工作状态，为后续的 RF 发现、标签读写等操作做好准备。

# `nfcManager_doInitialize`中的`nfa_init()`和`nfa_enable()`工作机制详解

在Android NFC栈中，`nfcManager_doInitialize`是Java层到Native层的入口点，而`nfa_init()`和`nfa_enable()`是启动NFC协议栈的核心函数。以下是它们的工作机制：

## 一、整体调用流程

图表

代码







下载

HAL层设备管理层NFA模块nfcManager_doInitializeHAL层设备管理层NFA模块nfcManager_doInitializenfa_init()nfa_dm_init()初始化回调注册nfa_enable()nfa_dm_enable()HAL_NfcOpen()打开完成回调启用完成通知返回初始化状态

## 二、nfa_init() 深度解析

### 1. 功能目标

- 初始化NFA（NFC Forum Abstraction）层数据结构
- 注册所有子模块
- 设置默认配置参数

### 2. 关键代码流程

c



复制



下载

```
void nfa_init(void)
{
    memset(&nfa_cb, 0, sizeof(tNFA_CB));  // 清除控制块
    
    /* 初始化子模块 */
    nfa_dm_init();      // 设备管理
    nfa_ee_init();      // 执行环境
    nfa_p2p_init();     // 点对点通信
    nfa_snep_init();    // SNEP协议
    nfa_rw_init();      // 标签读写
    nfa_ce_init();      // 卡模拟
    
    /* 设置默认配置 */
    nfa_set_default_config();
    
    /* 注册系统回调 */
    nfa_sys_register(NFA_ID_DM, &nfa_dm_sys_reg);
    nfa_sys_register(NFA_ID_EE, &nfa_ee_sys_reg);
    // ...其他模块注册
    
    /* 创建NFA任务 */
    GKI_create_task((TASKPTR)nfa_task, TASK_MEDIA, "NFA_TASK", nullptr, 0, nullptr, nullptr);
}
```

### 3. 核心数据结构初始化

c



复制



下载

```
typedef struct {
    tNFA_DM_CB         dm_cb;      // 设备管理控制块
    tNFA_EE_CB         ee_cb;      // 执行环境控制块
    tNFA_P2P_CB        p2p_cb;     // P2P控制块
    tNFA_RW_CB         rw_cb;      // 读写控制块
    tNFA_STATUS        state;      // 当前状态
    BOOLEAN            enable_flag; // 启用标志
} tNFA_CB;

static tNFA_CB nfa_cb;  // 全局NFA控制块
```

## 三、nfa_enable() 深度解析

### 1. 功能目标

- 激活NFC硬件
- 启动协议栈服务
- 建立HAL层连接
- 初始化RF发现流程

### 2. 完整工作流程

c



复制



下载

```
tNFA_STATUS nfa_enable(tNFA_DM_CBACK* p_dm_cback, 
                      tNFA_CONN_CBACK* p_conn_cback)
{
    /* 1. 检查状态 */
    if (nfa_cb.state != NFA_STATE_INITIAL)
        return NFA_STATUS_FAILED;
    
    /* 2. 注册回调 */
    nfa_dm_enable(p_dm_cback);      // 设备管理回调
    nfa_conn_enable(p_conn_cback);  // 连接事件回调
    
    /* 3. 初始化硬件 */
    tHAL_NFC_STATUS status = HAL_NfcOpen(nfa_hci_cback, nfa_dm_cback);
    
    /* 4. 加载配置 */
    nfa_dm_get_config();
    
    /* 5. 启动状态机 */
    nfa_sys_enable_subsystems();
    
    /* 6. 设置标志 */
    nfa_cb.enable_flag = TRUE;
    nfa_cb.state = NFA_STATE_IDLE;
    
    return NFA_STATUS_OK;
}
```

### 3. HAL层交互细节

`HAL_NfcOpen()`调用栈：

图表

代码







下载

<svg role="graphics-document document" viewBox="-11.734722137451172 -11.734722137451172 258.1638870239258 717.4694442749023" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-28" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(281.295px, 0px) scale(0.251874);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-28_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-28_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-28_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-28_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-28_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-28_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M117.347,62L117.347,66.167C117.347,70.333,117.347,78.667,117.347,86.333C117.347,94,117.347,101,117.347,104.5L117.347,108"></path><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M117.347,166L117.347,170.167C117.347,174.333,117.347,182.667,117.347,190.333C117.347,198,117.347,205,117.347,208.5L117.347,212"></path><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M117.347,270L117.347,274.167C117.347,278.333,117.347,286.667,117.347,294.333C117.347,302,117.347,309,117.347,312.5L117.347,316"></path><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_0" d="M117.347,374L117.347,378.167C117.347,382.333,117.347,390.667,117.347,398.333C117.347,406,117.347,413,117.347,416.5L117.347,420"></path><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_0" d="M117.347,478L117.347,482.167C117.347,486.333,117.347,494.667,117.347,502.333C117.347,510,117.347,517,117.347,520.5L117.347,524"></path><path marker-end="url(#mermaid-svg-28_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_0" d="M117.347,582L117.347,586.167C117.347,590.333,117.347,598.667,117.347,606.333C117.347,614,117.347,621,117.347,624.5L117.347,628"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(117.34722137451172, 35)" id="flowchart-A-0" class="node default"><rect height="54" width="139.69444274902344" y="-27" x="-69.84722137451172" style="" class="basic label-container"></rect><g transform="translate(-39.84722137451172, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="79.69444274902344"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">nfa_enable</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 139)" id="flowchart-B-1" class="node default"><rect height="54" width="157.61111450195312" y="-27" x="-78.80555725097656" style="" class="basic label-container"></rect><g transform="translate(-48.80555725097656, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="97.61111450195312"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">HAL_NfcOpen</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 243)" id="flowchart-C-3" class="node default"><rect height="54" width="125.23611450195312" y="-27" x="-62.61805725097656" style="" class="basic label-container"></rect><g transform="translate(-32.61805725097656, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="65.23611450195312"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">hal_open</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 347)" id="flowchart-D-5" class="node default"><rect height="54" width="218.69444274902344" y="-27" x="-109.34722137451172" style="" class="basic label-container"></rect><g transform="translate(-79.34722137451172, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="158.69444274902344"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">ioctl NFC_SET_POWER</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 451)" id="flowchart-E-7" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">加载固件</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 555)" id="flowchart-F-9" class="node default"><rect height="54" width="184.0138931274414" y="-27" x="-92.0069465637207" style="" class="basic label-container"></rect><g transform="translate(-62.0069465637207, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="124.0138931274414"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">创建HAL事件线程</p></span></div></foreignObject></g></g><g transform="translate(117.34722137451172, 659)" id="flowchart-G-11" class="node default"><rect height="54" width="156" y="-27" x="-78" style="" class="basic label-container"></rect><g transform="translate(-48, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">注册回调函数</p></span></div></foreignObject></g></g></g></g></g></svg>

### 4. 状态机转换

text



复制



下载

```
NFA_STATE_INITIAL → NFA_STATE_IDLE → NFA_STATE_DISCOVERY
```

## 四、NFA任务调度机制

### 1. 任务主循环

c



复制



下载

```
uint16_t nfa_task(uint16_t event, void* p_data)
{
    switch (event) {
        case NFA_DM_API_ENABLE_EVT:
            handle_enable_event(p_data);
            break;
            
        case NFA_DM_RF_FIELD_EVT:
            handle_rf_field_event(p_data);
            break;
            
        case NFA_CE_ACTIVATED_EVT:
            handle_card_emulation_event(p_data);
            break;
            
        // 处理其他20+种事件...
    }
    return 0;
}
```

### 2. 事件处理优先级

| 优先级   | 事件类型   | 处理延迟要求 |
| :------- | :--------- | :----------- |
| 0 (最高) | RF场检测   | < 5ms        |
| 1        | 卡激活通知 | < 10ms       |
| 2        | 数据接收   | < 20ms       |
| 3        | 命令响应   | < 50ms       |
| 4        | 配置更新   | > 100ms      |

## 五、与HAL层的协同工作

### 1. 回调机制

c



复制



下载

```
// HAL到NFA的通知通道
static void hal_event_callback(tHAL_NFC_EVENT event, tHAL_NFC_STATUS status) {
    switch (event) {
        case HAL_NFC_OPEN_CPLT_EVT:
            nfa_dm_send_event(NFA_DM_ENABLE_EVT, status);
            break;
            
        case HAL_NFC_POST_INIT_CPLT_EVT:
            nfa_dm_send_event(NFA_DM_POST_INIT_EVT, NULL);
            break;
            
        case HAL_NFC_PRE_DISCOVER_EVT:
            nfa_dm_send_event(NFA_DM_PREDISCOVER_EVT, NULL);
            break;
    }
}
```

### 2. 数据流路径

图表

代码







下载

<svg role="graphics-document document" viewBox="-6.45 -6.45 833.6500000000001 141.89999999999998" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-27" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(0px, 36px) scale(1);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-27_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-27_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-27_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-27_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-27_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-27_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-27_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M132,58.766L138.845,57.305C145.69,55.844,159.38,52.922,172.421,52.926C185.462,52.929,197.854,55.858,204.05,57.323L210.246,58.787"></path><path marker-end="url(#mermaid-svg-27_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M318.153,54.347L327.653,51.123C337.153,47.898,356.153,41.449,374.486,38.225C392.819,35,410.486,35,419.319,35L428.153,35"></path><path marker-end="url(#mermaid-svg-27_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M550.514,35L560.014,35C569.514,35,588.514,35,606.872,37.5C625.231,39.999,642.947,44.999,651.806,47.499L660.664,49.998"></path><path marker-end="url(#mermaid-svg-27_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_B_0" d="M664.514,92.915L655.014,95.596C645.514,98.277,626.514,103.638,597.65,106.319C568.787,109,530.06,109,491.333,109C452.606,109,413.88,109,385.647,105.99C357.415,102.979,339.678,96.959,330.809,93.949L321.941,90.938"></path><path marker-end="url(#mermaid-svg-27_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_A_0" d="M214.139,84.293L207.294,85.911C200.449,87.528,186.759,90.764,173.721,91.06C160.684,91.356,148.298,88.713,142.105,87.391L135.912,86.069"></path></g><g class="edgeLabels"><g transform="translate(173.06944465637207, 50)" class="edgeLabel"><g transform="translate(-16, -12)" class="label"><foreignObject height="24" width="32"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">中断</p></span></div></foreignObject></g></g><g transform="translate(375.152774810791, 35)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">事件回调</p></span></div></foreignObject></g></g><g transform="translate(607.5138893127441, 35)" class="edgeLabel"><g transform="translate(-32, -12)" class="label"><foreignObject height="24" width="64"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">处理决策</p></span></div></foreignObject></g></g><g transform="translate(491.3333320617676, 109)" class="edgeLabel"><g transform="translate(-34.01388931274414, -12)" class="label"><foreignObject height="24" width="68.02777862548828"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">hal_write</p></span></div></foreignObject></g></g><g transform="translate(173.06944465637207, 94)" class="edgeLabel"><g transform="translate(-16.06944465637207, -12)" class="label"><foreignObject height="24" width="32.13888931274414"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"><p style="margin: 0px; background-color: rgb(88, 88, 88);">ioctl</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(70, 72)" id="flowchart-A-0" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">物理设备</p></span></div></foreignObject></g></g><g transform="translate(266.1458320617676, 72)" id="flowchart-B-1" class="node default"><rect height="54" width="104.01388931274414" y="-27" x="-52.00694465637207" style="" class="basic label-container"></rect><g transform="translate(-22.00694465637207, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="44.01388931274414"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">HAL层</p></span></div></foreignObject></g></g><g transform="translate(491.3333320617676, 35)" id="flowchart-C-3" class="node default"><rect height="54" width="118.36111068725586" y="-27" x="-59.18055534362793" style="" class="basic label-container"></rect><g transform="translate(-29.18055534362793, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="58.36111068725586"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NFA任务</p></span></div></foreignObject></g></g><g transform="translate(738.6319465637207, 72)" id="flowchart-D-5" class="node default"><rect height="54" width="148.23611450195312" y="-27" x="-74.11805725097656" style="" class="basic label-container"></rect><g transform="translate(-44.11805725097656, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="88.23611450195312"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">NCI命令生成</p></span></div></foreignObject></g></g></g></g></g></svg>

## 六、关键初始化的时序控制

### 1. 启动时序要求

| 阶段        | 允许最大时间 | 实际典型值 |
| :---------- | :----------- | :--------- |
| HAL层初始化 | 500ms        | 100-200ms  |
| 固件加载    | 300ms        | 50-150ms   |
| RF校准      | 200ms        | 50-100ms   |
| 完整启动    | 1000ms       | 300-700ms  |

### 2. 超时处理机制

c



复制



下载

```
void nfa_enable_timeout_handler(TIMER_LIST_ENT* p_tle)
{
    if (!nfa_cb.enable_flag) {
        // 启动超时处理
        nfa_dm_disable(NFA_DM_DISABLE_TIMEOUT);
        
        // 通知Java层
        nfa_dm_cback(NFA_DM_ENABLE_EVT, 
                    (tNFA_DM_CBACK_DATA*)&disable_data);
    }
}
```

## 七、错误处理机制

### 1. 错误分类处理

c



复制



下载

```
tNFA_STATUS handle_hal_error(tHAL_NFC_STATUS status)
{
    switch (status) {
        case HAL_NFC_STATUS_ERR_TRANSPORT:
            return NFA_STATUS_CONNECTION_FAILED;
            
        case HAL_NFC_STATUS_ERR_CMD_TIMEOUT:
            return NFA_STATUS_TIMEOUT;
            
        case HAL_NFC_STATUS_INSUFFICIENT_RESOURCES:
            return NFA_STATUS_BUFFER_FULL;
            
        default:
            return NFA_STATUS_FAILED;
    }
}
```

### 2. 错误恢复流程

text



复制



下载

```
1. 记录错误日志
2. 尝试硬件复位
3. 重新加载固件
4. 恢复默认配置
5. 重新进入发现模式
```

## 八、与Android框架的集成

### 1. JNI层通知

c



复制



下载

```
// 初始化完成回调
static void nfaDeviceManagementCallback(uint8_t event, 
                                       tNFA_DM_CBACK_DATA* eventData)
{
    switch (event) {
        case NFA_DM_ENABLE_EVT:
            // 通知Java层
            env->CallVoidMethod(nfcManager, gCachedNfcManagerNotifyNfcMessage, 
                               "enable-complete");
            break;
    }
}
```

### 2. 状态同步机制

java



复制



下载

```
// Java层同步
public synchronized boolean doInitialize() {
    try {
        // 调用native初始化
        int status = nfcManager_doInitialize();
        
        // 等待Native回调
        wait(ENABLE_TIMEOUT_MS); 
        
        return (status == NfcAdapter.STATUS_OK);
    } catch (InterruptedException e) {
        return false;
    }
}
```

## 九、性能优化技术

### 1. 延迟初始化

c



复制



下载

```
void nfa_enable_deferred_init()
{
    // 第一阶段：核心启动
    hal_open();
    
    // 延迟第二阶段
    GKI_send_event(NFA_TASK, NFA_DM_API_DEFERRED_INIT_EVT);
}

void handle_deferred_init()
{
    // 非关键组件初始化
    nfa_ee_init_vsc();
    nfa_rw_init_tech_detection();
    
    // 后台配置加载
    nfa_dm_load_persist_config();
}
```

### 2. 并行启动

图表

代码







下载

<svg role="graphics-document document" viewBox="-17.900694274902346 -17.900694274902346 393.8152740478515 521.8013885498046" class="flowchart mermaid-svg" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-svg-26" height="100%" style="max-width: 100%; transform-origin: 0px 0px; user-select: none; transform: translate(177.36px, 0px) scale(0.528297);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-26_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-26_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-26_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-svg-26_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-26_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-svg-26_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M136.01,59.407L127.343,64.006C118.676,68.605,101.341,77.802,92.674,85.901C84.007,94,84.007,101,84.007,104.5L84.007,108"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_C_0" d="M228.01,59.407L236.678,64.006C245.345,68.605,262.679,77.802,271.347,85.901C280.014,94,280.014,101,280.014,104.5L280.014,108"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_D_0" d="M84.007,166L84.007,170.167C84.007,174.333,84.007,182.667,84.007,190.333C84.007,198,84.007,205,84.007,208.5L84.007,212"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_E_0" d="M280.014,166L280.014,170.167C280.014,174.333,280.014,182.667,280.014,190.333C280.014,198,280.014,205,280.014,208.5L280.014,212"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_F_0" d="M84.007,270L84.007,274.167C84.007,278.333,84.007,286.667,91.271,294.688C98.535,302.708,113.063,310.417,120.327,314.271L127.591,318.125"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_0" d="M280.014,270L280.014,274.167C280.014,278.333,280.014,286.667,272.75,294.688C265.486,302.708,250.958,310.417,243.694,314.271L236.43,318.125"></path><path marker-end="url(#mermaid-svg-26_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_0" d="M182.01,374L182.01,378.167C182.01,382.333,182.01,390.667,182.01,398.333C182.01,406,182.01,413,182.01,416.5L182.01,420"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="background-color: rgba(88, 88, 88, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204); background-color: rgb(88, 88, 88); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(182.01041412353516, 35)" id="flowchart-A-0" class="node default"><rect height="54" width="92" y="-27" x="-46" style="" class="basic label-container"></rect><g transform="translate(-16, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="32"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">开始</p></span></div></foreignObject></g></g><g transform="translate(84.00694274902344, 139)" id="flowchart-B-1" class="node default"><rect height="54" width="152.0138931274414" y="-27" x="-76.0069465637207" style="" class="basic label-container"></rect><g transform="translate(-46.0069465637207, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="92.0138931274414"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">HAL层初始化</p></span></div></foreignObject></g></g><g transform="translate(280.0138854980469, 139)" id="flowchart-C-3" class="node default"><rect height="54" width="140" y="-27" x="-70" style="" class="basic label-container"></rect><g transform="translate(-40, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="80"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">内存池分配</p></span></div></foreignObject></g></g><g transform="translate(84.00694274902344, 243)" id="flowchart-D-5" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">固件加载</p></span></div></foreignObject></g></g><g transform="translate(280.0138854980469, 243)" id="flowchart-E-7" class="node default"><rect height="54" width="124" y="-27" x="-62" style="" class="basic label-container"></rect><g transform="translate(-32, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="64"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">任务创建</p></span></div></foreignObject></g></g><g transform="translate(182.01041412353516, 347)" id="flowchart-F-9" class="node default"><rect height="54" width="109.72222137451172" y="-27" x="-54.86111068725586" style="" class="basic label-container"></rect><g transform="translate(-24.86111068725586, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="49.72222137451172"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">RF校准</p></span></div></foreignObject></g></g><g transform="translate(182.01041412353516, 451)" id="flowchart-G-13" class="node default"><rect height="54" width="92" y="-27" x="-46" style="" class="basic label-container"></rect><g transform="translate(-16, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="32"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="fill: rgb(204, 204, 204); color: rgb(204, 204, 204);"><p style="margin: 0px;">完成</p></span></div></foreignObject></g></g></g></g></g></svg>

## 十、总结：nfa_init()与nfa_enable()的区别

| 特性           | nfa_init()   | nfa_enable()       |
| :------------- | :----------- | :----------------- |
| **目的**       | 静态初始化   | 动态激活           |
| **调用时机**   | 系统启动时   | 用户启用NFC时      |
| **硬件交互**   | 无           | 深度交互           |
| **耗时**       | < 50ms       | 100-700ms          |
| **可重复调用** | 否           | 是(禁用后重新启用) |
| **主要输出**   | 数据结构     | 运行状态           |
| **错误影响**   | 系统无法启动 | 功能暂时不可用     |
| **依赖关系**   | 独立执行     | 依赖nfa_init()     |

`nfa_init()`和`nfa_enable()`共同构成了Android NFC协议栈的启动框架：

- `nfa_init()`建立软件基础设施
- `nfa_enable()`激活硬件和运行时服务
- 两者通过精心设计的异步机制协同工作
- 与HAL层的紧密集成确保跨平台兼容性
- 分层错误处理和恢复机制保障稳定性

这种设计使Android NFC能够平衡启动速度、资源消耗和功能完整性，为用户提供流畅的NFC体验。